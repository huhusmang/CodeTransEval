public static int findKOr(int[] nums, int k) { int ans = 0; for (int i = 0; i < 31; i++) { int cnt1 = 0; for (int x : nums) { cnt1 += (x >> i) & 1; } if (cnt1 >= k) { ans |= 1 << i; } } return ans; }
public static long minSum(int[] nums1, int[] nums2) { long s1 = 0; boolean zero1 = false; for (int x : nums1) { if (x == 0) { zero1 = true; s1++; } else { s1 += x; } } long s2 = 0; boolean zero2 = false; for (int x : nums2) { if (x == 0) { zero2 = true; s2++; } else { s2 += x; } } if (!zero1 && s1 < s2 || !zero2 && s2 < s1) { return -1; } return Math.max(s1, s2); }
public static int lengthOfLongestSubsequence(List<Integer> nums, int target) { int[] f = new int[target + 1]; Arrays.fill(f, Integer.MIN_VALUE); f[0] = 0; int s = 0; for (int x : nums) { s = Math.min(s + x, target); for (int j = s; j >= x; j--) { f[j] = Math.max(f[j], f[j - x] + 1); } } return f[target] > 0 ? f[target] : -1; }
public static int minChanges(String s) { int ans = 0; for (int i = 0; i < s.length(); i += 2) { if (s.charAt(i) != s.charAt(i + 1)) { ans++; } } return ans; }
public static int minGroupsForValidAssignment(int[] nums) { Map<Integer, Integer> cnt = new HashMap<>(); for (int x : nums) { cnt.merge(x, 1, Integer::sum); } int k = nums.length; for (int c : cnt.values()) { k = Math.min(k, c); } for (; ; k--) { int ans = 0; for (int c : cnt.values()) { if (c / k < c % k) { ans = 0; break; } ans += (c + k) / (k + 1); } if (ans > 0) { return ans; } } }
public static int minimumSum(int[] nums) { int n = nums.length; int[] suf = new int[n]; suf[n - 1] = nums[n - 1]; for (int i = n - 2; i > 1; i--) { suf[i] = Math.min(suf[i + 1], nums[i]); } int ans = Integer.MAX_VALUE; int pre = nums[0]; for (int j = 1; j < n - 1; j++) { if (pre < nums[j] && nums[j] > suf[j + 1]) { ans = Math.min(ans, pre + nums[j] + suf[j + 1]); } pre = Math.min(pre, nums[j]); } return ans == Integer.MAX_VALUE ? -1 : ans; }
public static int[][] constructProductMatrix(int[][] grid) { final int MOD = 12345; int n = grid.length, m = grid[0].length; int[][] p = new int[n][m]; long suf = 1; for (int i = n - 1; i >= 0; i--) { for (int j = m - 1; j >= 0; j--) { p[i][j] = (int) suf; suf = suf * grid[i][j] % MOD; } } long pre = 1; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { p[i][j] = (int) (p[i][j] * pre % MOD); pre = pre * grid[i][j] % MOD; } } return p; }
public static String maximumOddBinaryNumber(String s) { int cnt1 = (int) s.chars().filter(c -> c == '1').count(); return '1'.repeat(cnt1 - 1) + '0'.repeat(s.length() - cnt1) + '1'; }
public static String shortestBeautifulSubstring(String S, int k) { if (S.replace('0', '').length() < k) { return ''; } char[] s = S.toCharArray(); String ans = S; int cnt1 = 0, left = 0; for (int right = 0; right < s.length; right++) { cnt1 += s[right] - '0'; while (cnt1 > k || s[left] == '0') { cnt1 -= s[left++] - '0'; } if (cnt1 == k) { String t = S.substring(left, right + 1); if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) { ans = t; } } } return ans; }
public static int addMinimum(String word) { var s = word.toCharArray(); int t = 1; for (int i = 1; i < s.length; ++i) if (s[i - 1] >= s[i]) ++t; return t * 3 - s.length; }
public static int validSubarraySize(int[] nums, int threshold) { var n = nums.length; var left = new int[n]; var st = new ArrayDeque<Integer>(); for (var i = 0; i < n; i++) { while (!st.isEmpty() && nums[st.peek()] >= nums[i]) st.pop(); left[i] = st.isEmpty() ? -1 : st.peek(); st.push(i); } var right = new int[n]; st = new ArrayDeque<>(); for (var i = n - 1; i >= 0; i--) { while (!st.isEmpty() && nums[st.peek()] >= nums[i]) st.pop(); right[i] = st.isEmpty() ? n : st.peek(); st.push(i); } for (var i = 0; i < n; ++i) { var k = right[i] - left[i] - 1; if (nums[i] > threshold / k) return k; } return -1; }
public static List<Integer> lastVisitedIntegers(List<String> words) { List<Integer> ans = new ArrayList<>(); List<Integer> a = new ArrayList<>(); int k = 0; for (String s : words) { if (s.charAt(0) != 'p') {  a.add(Integer.parseInt(s)); k = 0; } else { ans.add(++k > a.size() ? -1 : a.get(a.size() - k));  } } return ans; }
public static int minOperations(String s1, String s2, int x) { if (s1.equals(s2)) { return 0; } List<Integer> p = new ArrayList<>(); for (int i = 0; i < s1.length(); i++) { if (s1.charAt(i) != s2.charAt(i)) { p.add(i); } } if (p.size() % 2 != 0) { return -1; } int f0 = 0, f1 = x; for (int i = 1; i < p.size(); i++) { int newF = Math.min(f1 + x, f0 + (p.get(i) - p.get(i - 1)) * 2); f0 = f1; f1 = newF; } return f1 / 2; }
public static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) { Collections.sort(processorTime); tasks.sort(Collections.reverseOrder()); int ans = 0; for (int i = 0; i < processorTime.size(); i++) { ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4)); } return ans; }
public static int differenceOfSums(int n, int m) { return n * (n + 1) / 2 - n / m * (n / m + 1) * m; }
public static int minSizeSubarray(int[] nums, int target) { long total = 0; for (int x : nums) total += x; int n = nums.length; int ans = Integer.MAX_VALUE; int left = 0; long sum = 0; for (int right = 0; right < n * 2; right++) { sum += nums[right % n]; while (sum > target % total) { sum -= nums[left++ % n]; } if (sum == target % total) { ans = Math.min(ans, right - left + 1); } } return ans == Integer.MAX_VALUE ? -1 : ans + (int) (target / total) * n; }
public static long maximumTripletValue(int[] nums) { int n = nums.length; int[] sufMax = new int[n + 1]; for (int i = n - 1; i > 1; i--) { sufMax[i] = Math.max(sufMax[i + 1], nums[i]); } long ans = 0; int preMax = nums[0]; for (int j = 1; j < n - 1; j++) { ans = Math.max(ans, (long) (preMax - nums[j]) * sufMax[j + 1]); preMax = Math.max(preMax, nums[j]); } return ans; }
public static long maximumTripletValue(int[] nums) { int n = nums.length; int[] sufMax = new int[n + 1]; for (int i = n - 1; i > 1; i--) { sufMax[i] = Math.max(sufMax[i + 1], nums[i]); } long ans = 0; int preMax = nums[0]; for (int j = 1; j < n - 1; j++) { ans = Math.max(ans, (long) (preMax - nums[j]) * sufMax[j + 1]); preMax = Math.max(preMax, nums[j]); } return ans; }
public static int maxSubarrays(int[] nums) { int ans = 0; int a = -1;  for (int x : nums) { a &= x; if (a == 0) { ans++;  a = -1; } } return Math.max(ans, 1);  }
public static int minOperations(int[] nums) { var cnt = new HashMap<Integer, Integer>(); for (int x : nums) { cnt.merge(x, 1, Integer::sum); } int ans = 0; for (int c : cnt.values()) { if (c == 1) { return -1; } ans += (c + 2) / 3; } return ans; }
public static int minOperations(List<Integer> nums, int k) { int n = nums.size(); long u = (2L << k) - 2;  long s = 0; for (int i = n - 1; ; --i) { s |= 1L << nums.get(i); if ((s & u) == u) { return n - i; } } }
public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) { int ans = 0; int mx = Collections.min(stock) + budget; for (var com : composition) { int left = 0, right = mx + 1; while (left + 1 < right) {  int mid = (left + right) / 2; boolean ok = true; long money = 0; for (int i = 0; i < n; ++i) { if (stock.get(i) < (long) com.get(i) * mid) { money += ((long) com.get(i) * mid - stock.get(i)) * cost.get(i); if (money > budget) { ok = false; break; } } } if (ok) { left = mid; } else { right = mid; } } ans = Math.max(ans, left); } return ans; }
public static int countWays(List<Integer> nums) { int[] a = nums.stream().mapToInt(i -> i).toArray(); Arrays.sort(a); int n = a.length; int ans = a[0] > 0 ? 1 : 0;  for (int i = 0; i < n - 1; i++) { if (a[i] < i + 1 && i + 1 < a[i + 1]) { ans++; } } return ans + 1; }
public static int sumIndicesWithKSetBits(List<Integer> nums, int k) { int ans = 0, n = nums.size(); for (int i = 0; i < n; i++) { if (Integer.bitCount(i) == k) { ans += nums.get(i); } } return ans; }
public static int countPairs(List<List<Integer>> coordinates, int k) { int ans = 0; var cnt = new HashMap<Long, Integer>(); for (var p : coordinates) { int x = p.get(0), y = p.get(1); for (int i = 0; i <= k; i++) { ans += cnt.getOrDefault((x ^ i) * 2000000L + (y ^ (k - i)), 0); } cnt.merge(x * 2000000L + y, 1, Integer::sum); } return ans; }
public static int minimumRightShifts(List<Integer> nums) { int i = 1; int n = nums.size(); while (i < n && nums.get(i - 1) < nums.get(i)) { i++; } if (i == n) { return 0; } if (nums.get(0) < nums.get(n - 1)) { return -1; } int mid = i; i++; while (i < n && nums.get(i - 1) < nums.get(i)) { i++; } if (i < n) { return -1; } return n - mid; }
public static int minLengthAfterRemovals(List<Integer> nums) { int maxCnt = 0, cnt = 1; int pre = nums.get(0); int n = nums.size(); for(int i = 1; i < n; i++) { if(pre == nums.get(i)) cnt++; else { maxCnt = Math.max(maxCnt, cnt); pre = nums.get(i); cnt = 1; } } maxCnt = Math.max(maxCnt, cnt); if(maxCnt * 2 > n) return maxCnt - (n - maxCnt); else { if(n % 2 == 0) return 0; else return 1; } }
public static int numberOfPoints(List<List<Integer>> nums) { var diff = new int[102]; for (var p : nums) { diff[p.get(0)]++; diff[p.get(1) + 1]--; } int ans = 0, s = 0; for (int d : diff) { s += d; if (s > 0) { ans++; } } return ans; }
public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx && sy == fy) { return t != 1; } return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t; }
public static long countInterestingSubarrays(List<Integer> nums, int modulo, int k) { int n = nums.size(); long ans = 0; int[] preSum = new int[n+1]; for(int i=0;i<n;i++) preSum[i+1] = preSum[i] + (nums.get(i) % modulo == k?1:0); Map<Integer,Integer> map = new HashMap<>(); for(int i=0;i<=n;i++){ if(map.containsKey((preSum[i]%modulo - k + modulo)%modulo)) ans += map.get((preSum[i]%modulo - k + modulo)%modulo); map.put(preSum[i]%modulo,map.getOrDefault(preSum[i]%modulo,0)+1); } return ans; }
public static int minimumOperations(String num) { int len = num.length(); int zero = num.contains('0')? len - 1: len; return Math.min(f('00', num), Math.min( f('25', num), Math.min(f('50', num), Math.min(f('75', num), zero)))); } public static int f(String target, String num) { int i = num.lastIndexOf(target.substring(1)); if (i < 0) return num.length(); i = num.substring(0, i).lastIndexOf(target.substring(0,1)); if (i < 0) return num.length(); return num.length() - i - 2; }
public static int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i <= high; i++) { char[] s = Integer.toString(i).toCharArray(); int n = s.length; if (n % 2 > 0) { continue; } int sum = 0; for (int j = 0; j < n / 2; j++) { sum += s[j]; } for (int j = n / 2; j < n; j++) { sum -= s[j]; } if (sum == 0) { ans++; } } return ans; }
public static long maxSum(List<Integer> nums, int m, int k) { var a = nums.stream().mapToInt(i -> i).toArray(); long ans = 0, sum = 0; var cnt = new HashMap<Integer, Integer>(); for (int i = 0; i < k - 1; i++) {  sum += a[i]; cnt.merge(a[i], 1, Integer::sum); } for (int i = k - 1; i < nums.size(); i++) { sum += a[i];  cnt.merge(a[i], 1, Integer::sum); if (cnt.size() >= m) ans = Math.max(ans, sum); int out = a[i - k + 1]; sum -= out;  if (cnt.merge(out, -1, Integer::sum) == 0) cnt.remove(out); } return ans; }
public static boolean checkStrings(String s1, String s2) { var cnt1 = new int[2][26]; var cnt2 = new int[2][26]; for (int i = 0; i < s1.length(); i++) { cnt1[i % 2][s1.charAt(i) - 'a']++; cnt2[i % 2][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(cnt1, cnt2); }
public static boolean canBeEqual(String s1, String s2) { var cnt1 = new int[2][26]; var cnt2 = new int[2][26]; for (int i = 0; i < s1.length(); i++) { cnt1[i % 2][s1.charAt(i) - 'a']++; cnt2[i % 2][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(cnt1, cnt2); }
public static int furthestDistanceFromOrigin(String moves) { int cn = 0; int ans = 0; for (int i = 0; i < moves.length(); i++) { if (moves.charAt(i) == 'L') { ans--; } else if (moves.charAt(i) == 'R') { ans++; } else { cn++; } } return Math.abs(ans) + cn; }
public static int longestEqualSubarray(List<Integer> nums, int k) { int n = nums.size(), ans = 0; List<Integer>[] pos = new ArrayList[n + 1]; Arrays.setAll(pos, e -> new ArrayList<>()); for (int i = 0; i < n; i++) { int x = nums.get(i); pos[x].add(i - pos[x].size()); } for (var ps : pos) { if (ps.size() <= ans) continue; int left = 0; for (int right = 0; right < ps.size(); right++) { while (ps.get(right) - ps.get(left) > k)  left++; ans = Math.max(ans, right - left + 1); } } return ans; }
public static boolean isAcronym(List<String> words, String s) { if (words.size() != s.length()) return false; for (int i = 0; i < words.size(); i++) if (words.get(i).charAt(0) != s.charAt(i)) return false; return true; }
public static int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }
public static int minimumOperations(List<Integer> nums) { List<Integer> g = new ArrayList<>(); for (int x : nums) { int j = upperBound(g, x); if (j == g.size()) g.add(x); else g.set(j, x); } return nums.size() - g.size(); } public static int upperBound(List<Integer> g, int target) { int left = -1, right = g.size(); while (left + 1 < right) { int mid = (left + right) >>> 1; if (g.get(mid) <= target) left = mid; else right = mid; } return right; }
public static int countPairs(List<Integer> nums, int target) { Collections.sort(nums); int ans = 0, left = 0, right = nums.size() - 1; while (left < right) { if (nums.get(left) + nums.get(right) < target) { ans += right - left; left++; } else { right--; } } return ans; }
public static int minAbsoluteDifference(List<Integer> nums, int x) { var a = nums.stream().mapToInt(i -> i).toArray(); int ans = Integer.MAX_VALUE, n = a.length; var s = new TreeSet<Integer>(); s.add(Integer.MAX_VALUE);  s.add(Integer.MIN_VALUE / 2); for (int i = x; i < n; i++) { s.add(a[i - x]); int y = a[i]; ans = Math.min(ans, Math.min(s.ceiling(y) - y, y - s.floor(y))); } return ans; }
public static ListNode doubleIt(ListNode head) { if (head.val > 4) head = new ListNode(0, head); for (var cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null && cur.next.val > 4) cur.val++; } return head; }
public static int maxSum(int[] nums) { int ans = -1; var maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int v : nums) { int maxD = 0; for (int x = v; x > 0; x /= 10) maxD = Math.max(maxD, x % 10); ans = Math.max(ans, v + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], v); } return ans; }
public static String finalString(String s) { var q = new ArrayDeque<Character>(); var tail = true; for (var c : s.toCharArray()) { if (c == 'i') tail = !tail; else if (tail) q.addLast(c); else q.addFirst(c); } var ans = new StringBuilder(); for (var c : q) ans.append(c); if (!tail) ans.reverse(); return ans.toString(); }
public static boolean canSplitArray(List<Integer> nums, int m) { int n = nums.size(); if (n <= 2) return true; for (int i = 1; i < n; i++) if (nums.get(i - 1) + nums.get(i) >= m) return true; return false; }
public static int longestAlternatingSubarray(int[] a, int threshold) { int ans = 0; int i = 0; int n = a.length; while (i < n) { if (a[i] % 2 != 0 || a[i] > threshold) { i += 1; } else { int i0 = i; i += 1; while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) { i += 1; } ans = Math.max(ans, i - i0); } } return ans; }
public static int minimumSeconds(List<Integer> nums) { int n = nums.size(); Map<Integer, List<Integer>> map = new HashMap<>();  for(int i = 0; i < nums.size(); i++){ if(!map.containsKey(nums.get(i))) map.put(nums.get(i), new ArrayList<>()); map.get(nums.get(i)).add(i); } int ans = n / 2; for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){ List<Integer> list = entry.getValue(); list.add(list.get(0) + n); int mx = -1; for(int j = 1; j < list.size(); j++){ mx = Math.max(mx, (list.get(j) - list.get(j-1)) / 2); } ans = Math.min(ans, mx); }return ans; }
public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int h : hours) { if (h >= target) { ans++; } } return ans; }
public static List<String> splitWordsBySeparator(List<String> words, char separator) { List<String> rs = new ArrayList<>(); StringBuffer sb = new StringBuffer(); for (String word : words) { for (char c : word.toCharArray()) { if (c == separator) { if (sb.length() > 0) { rs.add(sb.toString()); sb = new StringBuffer(); } } else { sb.append(c); } } if (sb.length() > 0) { rs.add(sb.toString()); sb = new StringBuffer(); } } return rs; }
public static List<Integer> miniMaxSum(List<Integer> a) { int s = a.stream().mapToInt(Integer::intValue).sum(); int min = Collections.min(a); int max = Collections.max(a); return Arrays.asList(s - max, s - min); }
public static int pickingNumbers(List<Integer> a) { HashMap<Integer, Integer> d = new HashMap<>(); for (int num : a) { d.put(num, d.getOrDefault(num, 0) + 1); } int best = 0; for (int i = 0; i < 99; ++i) { best = Math.max(d.getOrDefault(i, 0) + d.getOrDefault(i + 1, 0), best); } return best; }
public static int summingSeries(long n) { return (int)((n % 1000000007) * (n % 1000000007) % 1000000007); }
public static List<Integer> matchingStrings(List<String> stringList, List<String> queries) { List<Integer> arr = new ArrayList<>(); for (String i : queries) { int k = 0; for (String j : stringList) { if (i.equals(j)) { k++; } } arr.add(k); } return arr; }
public static int bsearch(List<Integer> arr, int x) { int low = 0; int high = arr.size() - 1; int mid = 0; while (low <= high) { mid = low + (high - low) / 2; if (arr.get(mid) < x) { high = mid - 1; } else if (arr.get(mid) > x) { low = mid + 1; } else { return mid + 1; } } return low + 1; } public static List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) { LinkedHashSet<Integer> rankSet = new LinkedHashSet<>(ranked); List<Integer> rankNums = new ArrayList<>(rankSet); Collections.sort(rankNums, Collections.reverseOrder()); List<Integer> result = new ArrayList<>(); for (int score : player) { int rank = bsearch(rankNums, score); result.add(rank); } return result; }
public static long arrayManipulation(int n, List<List<Integer>> queries) { long[] arr = new long[n + 2]; long max = 0; long sum = 0;  for (List<Integer> query : queries) { arr[query.get(0)] += query.get(2); arr[query.get(1) + 1] -= query.get(2); }  for (long val : arr) { sum += val; if (sum > max) max = sum; } return max; }
public static SinglyLinkedListNode deleteNode(SinglyLinkedListNode llist, int position) { if (llist == null) { return null; } if (position == 0) { return llist.next; } SinglyLinkedListNode current = llist; for (int i = 0; current != null && i < position - 1; i++) { current = current.next; } if (current == null || current.next == null) { return llist; } SinglyLinkedListNode next = current.next.next; current.next = next; return llist; }
public static boolean evaluateTree(TreeNode root) { if (root.left == null) { return root.val == 1; } boolean l = evaluateTree(root.left); boolean r = evaluateTree(root.right); return root.val == 2 ? l || r : l && r; }
public static int andXorOr(List<Integer> a) { int m = 0; Stack<Integer> s = new Stack<>(); for (int i : a) { while (!s.isEmpty() && s.peek() >= i) { m = Math.max(m, i ^ s.pop()); } if (!s.isEmpty()) { m = Math.max(m, i ^ s.peek()); } s.push(i); } return m; }
public static List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) { Map<Integer, Integer> mp = new HashMap<>(); for (int num : brr) mp.put(num, mp.getOrDefault(num, 0) + 1); for (int num : arr) mp.put(num, mp.getOrDefault(num, 0) - 1);  List<Integer> result = new ArrayList<>(); for (Map.Entry<Integer, Integer> entry : mp.entrySet()) { if (entry.getValue() > 0) result.add(entry.getKey()); }  return result; }
public static long maximumSum(List<Long> a, long m) { long maxSum = 0; long currentSum = 0; TreeSet<Long> s = new TreeSet<>(); for (long number : a) { currentSum = (currentSum + number) % m; maxSum = Math.max(maxSum, currentSum); Long b = s.higher(currentSum); if (b != null) { long possibleMax = (currentSum - b + m) % m; maxSum = Math.max(maxSum, possibleMax); } s.add(currentSum); } return maxSum; }
public static int formingMagicSquare(List<List<Integer>> sList) { int[][] s = sList.stream()   .map(l -> l.stream().mapToInt(Integer::intValue).toArray())   .toArray(int[][]::new); int[][][] magicSquares = { {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}}, {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}}, {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}}, {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}}, {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}}, {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}}, {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}}, {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}} }; int minCost = 8 * 3; for (int[][] magicSquare : magicSquares) { int cost = 0; for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { cost += Math.abs(s[i][j] - magicSquare[i][j]); } } minCost = Math.min(cost, minCost); } return minCost; }
public static String isFibo(long n) { long start = 0; long last = 1; while (last <= n) { long tmp = last + start; start = last; last = tmp; if (last == n) { return 'IsFibo'; } } return 'IsNotFibo'; }
public static int solve(long l, long r) { Set<Long> seen = new HashSet<>(); Deque<Long> q = new ArrayDeque<>(); for (int i = 0; i < 10; i++) q.addLast((long)i); while (!q.isEmpty()) { long u = q.removeLast(); if (String.valueOf(u).length() >= 20) continue; if (seen.contains(u)) continue; seen.add(u); int length = String.valueOf(u).length(); for (int k = length; k < length + 5; k++) { if (String.valueOf(u * k).length() == k) { q.addLast(u * k); } } } int count = 0; for (long s : seen) { if (l <= s && s <= r) count++; } System.out.println('[' + l + ', ' + r + ']: ' + count); return count; }
public static List<String> cavityMap(List<String> grid) { for (int k = 1; k < grid.size() - 1; k++) { char[] row = grid.get(k).toCharArray(); String d = grid.get(k + 1); String u = grid.get(k - 1); for (int j = 1; j < row.length - 1; j++) { char left = row[j - 1]; char current = row[j]; char right = row[j + 1]; char down = d.charAt(j); char up = u.charAt(j); if (left < current && current > right && down < current && up < current) { row[j] = 'X'; } } grid.set(k, new String(row)); } return grid; }
public static long solve(int a, int b) { long m = a; long n = b; long ans = Math.min(((m-1)*n+(n-1)),((n-1)*m+(m-1))); return m*n-1; }
public static int minimumLoss(List<Long> price) { HashMap<Long, Integer> map = new HashMap<>(); for (int i = 0; i < price.size(); i++) { map.put(price.get(i),i); } Collections.sort(price); long min = Integer.MAX_VALUE; for (int i = 0; i < price.size()-1; i++) { long currentMin = price.get(i+1)-price.get(i); if(currentMin < min && map.get(price.get(i))>map.get(price.get(i+1))) min = currentMin;  } return (int)min; }
public static String dayOfProgrammer(int year) { if (year == 1918) { return '26.09.1918'; } boolean leapYear = true; if (year % 4 != 0 || (year > 1918 && year % 100 == 0 && year % 400 != 0)) { leapYear = false; } return (leapYear ? '12' : '13') + '.09.' + year; }
public static List<Integer> acmTeam(List<String> topic) { int teamLen = topic.size(); int topicLen = topic.get(0).length(); int maxKnown = 0; int maxTeams = 0; for (int i = 0; i < teamLen; i++) { String t1 = topic.get(i); for (int j = i + 1; j < teamLen; j++) { int know = 0; String t2 = topic.get(j); for (int k = 0; k < topicLen; k++) { if (t1.charAt(k) == '1' || t2.charAt(k) == '1') know++; } if (know == maxKnown) maxTeams++; else if (know > maxKnown) { maxKnown = know; maxTeams = 1; } } } List<Integer> result = new ArrayList<>(); result.add(maxKnown); result.add(maxTeams); return result; }
public static String timeInWords(int h, int m){ String[] hour = {'one', 'two', 'three', 'four',  'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve'}; String[] minutes = {'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', 'twenty', 'twenty one', 'twenty two', 'twenty three', 'twenty four', 'twenty five', 'twenty six', 'twenty seven', 'twenty eight', 'twenty nine'}; if (m == 0){ return hour[h - 1] + ' o' clock'; } else if (m == 15){ return 'quarter past ' + hour[h - 1]; } else if (m == 30){ return 'half past ' + hour[h - 1]; } else if (m == 45){ return 'quarter to ' + hour[h]; } else if (m == 1){ return minutes[m - 1] + ' minute past ' + hour[h - 1]; } else if (0 < m & m < 30){ return minutes[m - 1] + ' minutes past ' + hour[h - 1]; } else{ return minutes[60 - m - 1] + ' minutes to ' + hour[h]; } }
public static int collectTheCoins(int[] coins, int[][] edges) { int n = coins.length; List<Integer> g[] = new ArrayList[n]; Arrays.setAll(g, e -> new ArrayList<>()); var deg = new int[n]; for (var e : edges) { int x = e[0], y = e[1]; g[x].add(y); g[y].add(x);  deg[x]++; deg[y]++;  } int leftEdges = n - 1;  var q = new ArrayDeque<Integer>(); for (int i = 0; i < n; i++) { if (deg[i] == 1 && coins[i] == 0) {  q.add(i); } } while (!q.isEmpty()) { leftEdges--;  for (int y : g[q.poll()]) { if (--deg[y] == 1 && coins[y] == 0) {  q.add(y); } } } for (int i = 0; i < n; i++) { if (deg[i] == 1 && coins[i] == 1) {  q.add(i); } } leftEdges -= q.size();  for (int x : q) {  for (int y : g[x]) { if (--deg[y] == 1) {  leftEdges--;  } } } return Math.max(leftEdges * 2, 0); }
public static void matrixRotation(List<List<Integer>> matrix, int r) { int l = 0; int br = matrix.size(); int bc = matrix.get(0).size(); while (l < Math.min(br, bc) / 2) { int rr = r % (2 * (br + bc - 4 * l - 2)); while (rr-- > 0) { int buf = matrix.get(l).get(l); for (int j = l; j < bc - l - 1; ++j) { matrix.get(l).set(j, matrix.get(l).get(j + 1)); } for (int i = l; i < br - l - 1; ++i) { matrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1)); } for (int j = bc - l - 1; j > l; --j) { matrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1)); } for (int i = br - l - 1; i > l + 1; --i) { matrix.get(i).set(l, matrix.get(i - 1).get(l)); } matrix.get(l + 1).set(l, buf); } ++l; } for (List<Integer> row : matrix) { for (int elem : row) { System.out.print(elem + ' '); } System.out.println(); } }
public static int divisorSubstrings(int num, int k) { String s = Integer.toString(num); int n = s.length(); int res = 0; for (int i = 0; i <= n - k; ++i) { int tmp = Integer.parseInt(s.substring(i, i + k)); if (tmp != 0 && num % tmp == 0) { ++res; } } return res; }
public static List<Integer> solve(List<Integer> a) { List<Integer> result = new ArrayList<>(); int[] cum = new int[a.size()]; cum[0] = a.get(0); for (int i = 1; i < a.size(); i++) { cum[i] = cum[i-1] + a.get(i); } for (int i = 0; i < cum.length+1/2; i++) { if(cum[cum.length-1]%cum[i] == 0) { int temp = 0; for (int j = i+1; j < cum.length; j++) { temp += a.get(j); if (temp > cum[i]) break; if (temp%cum[i] == 0) temp = 0;  } if (temp == 0) result.add(cum[i]); } } return result; }
public static int maximumToys(List<Integer> prices, int k) { Collections.sort(prices); int toys = 0; for (int price : prices) { if (price <= k) { k -= price; toys++; } else { break; } } return toys; }
public static int sumOfSquares(int[] nums) { int ans = 0, n = nums.length; for (int i = 1; i <= n; i++) { if (n % i == 0) { ans += nums[i - 1] * nums[i - 1]; } } return ans; }
public static boolean checkArray(int[] nums, int k) { int n = nums.length, sumD = 0; var d = new int[n + 1]; for (int i = 0; i < n; i++) { sumD += d[i]; int x = nums[i]; x += sumD; if (x == 0) continue; if (x < 0 || i + k > n) return false; sumD -= x; d[i + k] += x; } return true; }
public static int maxNonDecreasingLength(int[] nums1, int[] nums2) { int n = nums1.length; if (n == 1) return 1; int[][] dp = new int[n][2]; dp[0][0] = dp[0][1] = 1; int ans = 0; for (int i = 1; i < n; i++) { dp[i][0] = dp[i][1] = 1; if (nums1[i] >= nums1[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][0]+1); if (nums1[i] >= nums2[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][1]+1); if (nums2[i] >= nums1[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][0]+1); if (nums2[i] >= nums2[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][1]+1); ans = Math.max(ans, Math.max(dp[i][0], dp[i][1])); } return ans; }
public static int maximumJumps(int[] nums, int target) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, -1); dp[0] = 0; for (int i = 1; i < n; ++i) { for (int j = 0; j < i; ++j) { if (Math.abs(nums[i] - nums[j]) <= target && dp[j] != -1) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } return dp[n - 1]; }
public static int theMaximumAchievableX(int num, int t) { return num + (t << 1); }
public static long[] countBlackBlocks(int m, int n, int[][] coordinates) { List<Long> ansList = new ArrayList<>(Collections.nCopies(5, 0L)); long sum = (long) (m - 1) * (n - 1); Set<Long> st = new HashSet<>(); int num = coordinates.length; for (int i = 0; i < num; i++) st.add((long) coordinates[i][0] * n + coordinates[i][1]); int[][][] arr = { {{0, -1}, {-1, -1}, {-1, 0}}, {{0, 1}, {-1, 0}, {-1, 1}}, {{0, -1}, {1, 0}, {1, -1}}, {{0, 1}, {1, 0}, {1, 1}} }; for (int i = 0; i < num; i++) { long x = coordinates[i][0], y = coordinates[i][1]; for (int[][] a : arr) { int cnt = 1; for (int[] direction : a) { long nx = x + direction[0], ny = y + direction[1]; if (nx < 0 || ny < 0 || nx >= m || ny >= n) { cnt = 0; break; } if (st.contains(nx * n + ny)) cnt++; } ansList.set(cnt, ansList.get(cnt) + 1); } } for (int i = 2; i <= 4; i++) ansList.set(i, ansList.get(i) / i); ansList.set(0, sum - ansList.get(1) - ansList.get(2) - ansList.get(3) - ansList.get(4)); long[] ans = ansList.stream().mapToLong(Long::longValue).toArray(); return ans; }
public static int minimumBeautifulSubstrings(String s) { final String[] fivePowersBinary = { '1', '101', '11001', '1111101', '1001110001', '110000110101', '11110100001001' }; int n = s.length(); int[] dp = new int[n + 1]; dp[n] = 0; for (int i = n - 1; i >= 0; i--) { dp[i] = 16; if (s.charAt(i) == '0') continue; for (String bin : fivePowersBinary) { if (i + bin.length() > n) break; if (s.substring(i, i + bin.length()).equals(bin)) { dp[i] = Math.min(dp[i], dp[i + bin.length()] + 1); } } } return dp[0] > n ? -1 : dp[0]; }
import java.util.Scanner; public static class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int x0 = scanner.nextInt(); int y0 = scanner.nextInt(); scanner.close(); int n = x0 * y0; int ans = 0; for (int i = x0; i <= y0; i++) { if (n % i == 0 && gcd(i, n / i) == x0 && lcm(i, n / i) == y0) { ans++; } } System.out.println(ans); } public static int gcd(int x, int y) { if (x < y) { int temp = x; x = y; y = temp; } int r = x % y; while (r != 0) { x = y; y = r; r = x % y; } return y; } public static int lcm(int x, int y) { if (x < y) { int temp = x; x = y; y = temp; } int m = x; while (x % y != 0) { x = x + m; } return x; } }
import java.util.Arrays; import java.util.Scanner; public static class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[][] a = new int[2][7];  for(int i = 0;i < 7;i++) {  for(int j = 0;j < 2;j++) { a[j][i] = sc.nextInt(); } } int[] b = new int[7];  int[] c = new int[7];  for(int i = 0;i < 7;i++) {  b[i] = a[0][i] + a[1][i]; c[i] = a[0][i] + a[1][i]; } boolean flag = false; for(int i = 0;i < 7;i++) { if(b[i] > 8) {  flag = true; } } if(flag) {  int day; Arrays.sort(b);  for(int i = 0;i < 7;i++) { if(b[6] == c[i]) { day = i+1; break;  } } System.out.println(day); }else { System.out.println(0); } } }
public static int maximumValue(String[] strs) { int res = 0; for (String s : strs) { boolean isDigits = true; int n = s.length(); for (int i = 0; i < n; ++i) { isDigits &= Character.isDigit(s.charAt(i)); } res = Math.max(res, isDigits ? Integer.parseInt(s) : n); } return res; }
public static int countBeautifulPairs(int[] nums) { int ans = 0; var cnt = new int[10]; for (int x : nums) { for (int y = 1; y < 10; y++) if (cnt[y] > 0 && gcd(x % 10, y) == 1) ans += cnt[y]; while (x >= 10) x /= 10; cnt[x]++; } return ans; } private static int gcd(int a, int b) { while (a != 0) { int tmp = a; a = b % a; b = tmp; } return b; }
public static int[] countServers(int n, int[][] logs, int x, int[] queries) { int nq = queries.length; var id = new Integer[nq]; for (int i = 0; i < nq; i++) id[i] = i; Arrays.sort(id, (i, j) -> queries[i] - queries[j]); Arrays.sort(logs, (a, b) -> a[1] - b[1]); int[] ans = new int[nq], cnt = new int[n + 1]; int outOfRange = n, left = 0, right = 0; for (int i : id) { while (right < logs.length && logs[right][1] <= queries[i]) if (cnt[logs[right++][0]]++ == 0) outOfRange--; while (left < logs.length && logs[left][1] < queries[i] - x) if (--cnt[logs[left++][0]] == 0) outOfRange++; ans[i] = outOfRange; } return ans; }
public static boolean isPossible(int n, List<List<Integer>> edges) { var g = new Set[n + 1]; Arrays.setAll(g, e -> new HashSet<Integer>()); for (var e : edges) { int x = e.get(0), y = e.get(1); g[x].add(y); g[y].add(x); } var odd = new ArrayList<Integer>(); for (var i = 1; i <= n; ++i) if (g[i].size() % 2 > 0) odd.add(i); var m = odd.size(); if (m == 0) return true; if (m == 2) { int x = odd.get(0), y = odd.get(1); if (!g[x].contains(y)) return true; for (var i = 1; i <= n; ++i) if (i != x && i != y && !g[i].contains(x) && !g[i].contains(y)) return true; return false; } if (m == 4) { int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3); return !g[a].contains(b) && !g[c].contains(d) || !g[a].contains(c) && !g[b].contains(d) || !g[a].contains(d) && !g[b].contains(c); } return false; }
public static int minExtraChar(String s, String[] dictionary) { var set = new HashSet<String>(dictionary.length); for (var str : dictionary) set.add(str); int n = s.length(); var f = new int[n + 1]; for (int i = 0; i < n; i++) { f[i + 1] = f[i] + 1; for (int j = 0; j < i+1; j++) { if (set.contains(s.substring(j, i + 1))) { f[i + 1] = Math.min(f[i + 1], f[j]); } } } return f[n]; }
public static int maximumPoints(int[][] edges, int[] coins, int k) { List<Integer>[] g = new ArrayList[coins.length]; Arrays.setAll(g, e -> new ArrayList<>()); for (int[] e : edges) { int x = e[0], y = e[1]; g[x].add(y); g[y].add(x); } return dfs(0, -1, g, coins, k)[0]; } private static int[] dfs(int x, int fa, List<Integer>[] g, int[] coins, int k) { int[] res1 = new int[14]; int[] res2 = new int[14]; for (int y : g[x]) { if (y == fa) continue; int[] r = dfs(y, x, g, coins, k); for (int j = 0; j < r.length; j++) { res1[j] += r[j]; if (j < 13) { res2[j] += r[j + 1]; } } } for (int j = 0; j < res1.length; j++) { res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1))); } return res1; }
public static int countCompleteComponents(int n, int[][] edges) { List<Integer>[] list = new ArrayList[n]; for (int i = 0; i < list.length; i++) { list[i] = new ArrayList<>(); } for (int i = 0; i < edges.length; i++) { list[edges[i][0]].add(edges[i][1]); list[edges[i][1]].add(edges[i][0]); } int ans = 0; boolean[] visited = new boolean[n]; for (int i = 0; i < n; i++) { if (!visited[i]) { int[] v = new int[1]; int[] e = new int[1]; dfs(list, visited, v, e, i); if (v[0] * (v[0] - 1) == e[0]) { ans++; } } } return ans; } public static void dfs(List<Integer>[] list, boolean[] visited, int[] v, int[] e, int current) { if (!visited[current]) { visited[current] = true; v[0]++; e[0] += list[current].size(); for (int n: list[current]) { dfs(list, visited, v, e, n); } } }
public static boolean reach(int x,int y,int[][] grid){ int n=grid.length; int m=grid[0].length; if (x==n-1&&y==m-1){ return true; } grid[x][y]=0; int x1=x;int y1=y+1; if (y1<m&&grid[x1][y1]==1){ boolean ret=reach(x1,y1,grid); if (ret){ return ret; } } int x2=x+1;int y2=y; if (x2<n&&grid[x2][y2]==1){ return reach(x2,y2,grid); } return false; } public static boolean isPossibleToCutPath(int[][] grid) { int n=grid.length; int m=grid[0].length; List<Integer> queue=new ArrayList<>(); boolean[][] rea=new boolean[n][m]; if (!reach(0,0,grid)){ return true; } grid[0][0]=1;grid[n-1][m-1]=1; if (!reach(0,0,grid)){ return true; } return false; }
public static boolean validPath(int n, int[][] edges, int source, int destination) { List<Integer>[] adj = new List[n]; for (int i = 0; i < n; i++) { adj[i] = new ArrayList<Integer>(); } for (int[] edge : edges) { int x = edge[0], y = edge[1]; adj[x].add(y); adj[y].add(x); } boolean[] visited = new boolean[n]; return dfs(source, destination, adj, visited); } public static boolean dfs(int source, int destination, List<Integer>[] adj, boolean[] visited) { if (source == destination) { return true; } visited[source] = true; for (int next : adj[source]) { if (!visited[next] && dfs(next, destination, adj, visited)) { return true; } } return false; }
public static boolean isSubPath(ListNode head, TreeNode root) { if(root==null) return false; return dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right); } public static boolean dfs(ListNode head,TreeNode root){ if(head==null) return true; if(root==null) return false; if(head.val!=root.val) return false; return dfs(head.next,root.left)||dfs(head.next,root.right); }
public static void inorder(TreeNode node, List<Integer> res) { if (node != null) { inorder(node.left, res); res.add(node.val); inorder(node.right, res); } } public static List<Integer> getAllElements(TreeNode root1, TreeNode root2) { List<Integer> nums1 = new ArrayList<>(), nums2 = new ArrayList<>(); inorder(root1, nums1); inorder(root2, nums2); List<Integer> merged = new ArrayList<>(); int p1 = 0, p2 = 0; while (true) { if (p1 == nums1.size()) { merged.addAll(nums2.subList(p2, nums2.size())); break; } if (p2 == nums2.size()) { merged.addAll(nums1.subList(p1, nums1.size())); break; } if (nums1.get(p1) < nums2.get(p2)) { merged.add(nums1.get(p1++)); } else { merged.add(nums2.get(p2++)); } } return merged; }
public static int maxLevelSum(TreeNode root) { List<Integer> sums = new ArrayList<>(); dfs(root, 0, sums); return sums.indexOf(Collections.max(sums)) + 1; } private static void dfs(TreeNode node, int level, List<Integer> sums) { if (node == null) return; if (level == sums.size()) { sums.add(node.val); } else { sums.set(level, sums.get(level) + node.val); } dfs(node.left, level + 1, sums); dfs(node.right, level + 1, sums); }
public static int sumRootToLeaf(TreeNode root) { return dfs(root, 0); } public static int dfs(TreeNode root, int val) { if (root == null) { return 0; } val = (val << 1) | root.val; if (root.left == null && root.right == null) { return val; } return dfs(root.left, val) + dfs(root.right, val); }
public static boolean isCousins(TreeNode root, int x, int y) { int[] xi = dfs(root, null, 0, x); int[] yi = dfs(root, null, 0, y); return xi[1] == yi[1] && xi[0] != yi[0]; } public static int[] dfs(TreeNode root, TreeNode fa, int depth, int t) { if (root == null) return new int[]{-1, -1}; if (root.val == t) { return new int[]{fa != null ? fa.val : 1, depth}; } int[] l = dfs(root.left, root, depth + 1, t); if (l[0] != -1) return l; return dfs(root.right, root, depth + 1, t); }
public static int longestSquareStreak(int[] nums) { int ans = 0; Set<Integer> s = new HashSet<>(); for (int num : nums) { s.add(num); } for (int x : s) { int cnt = 0; while (s.contains(x)) { cnt += 1; if (x > Math.sqrt(Integer.MAX_VALUE)) break; x *= x; } ans = Math.max(ans, cnt); } return ans > 1 ? ans : -1; }
public static int appendCharacters(String s, String t) { int j = 0, m = t.length(); for (char c : s.toCharArray()) { if (c == t.charAt(j)) { j++; if (j == m) return 0; } } return m - j; }