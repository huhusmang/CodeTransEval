int findKOr(vector<int>& nums, int k) { int ans = 0; for (int i = 0; i < 31; i++) { int cnt1 = 0; for (int x : nums) { cnt1 += (x >> i) & 1; } if (cnt1 >= k) { ans |= 1 << i; } } return ans; }
long long minSum(vector<int>& nums1, vector<int>& nums2) { long long s1 = 0; bool zero1 = false; for (int x : nums1) { if (x == 0) { zero1 = true; s1++; } else { s1 += x; } } long long s2 = 0; bool zero2 = false; for (int x : nums2) { if (x == 0) { zero2 = true; s2++; } else { s2 += x; } } if (!zero1 && s1 < s2 || !zero2 && s2 < s1) { return -1; } return max(s1, s2); }
int lengthOfLongestSubsequence(vector<int> &nums, int target) { vector<int> f(target + 1, INT_MIN); f[0] = 0; int s = 0; for (int x : nums) { s = min(s + x, target); for (int j = s; j >= x; j--) { f[j] = max(f[j], f[j - x] + 1); } } return f[target] > 0 ? f[target] : -1; }
int minChanges(string s) { int ans = 0; for (int i = 0; i < s.length(); i += 2) { ans += s[i] != s[i + 1]; } return ans; }
int minGroupsForValidAssignment(vector<int>& nums) { unordered_map<int, int> cnt; for (int x : nums) { cnt[x]++; } int k = min_element(cnt.begin(), cnt.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->second; for (; ; k--) { int ans = 0; for (auto &[_, c] : cnt) { if (c / k < c % k) { ans = 0; break; } ans += (c + k) / (k + 1); } if (ans) { return ans; } } }
int minimumSum(vector<int>& nums) { int n = nums.size(); vector<int> suf(n); suf[n - 1] = nums[n - 1]; for (int i = n - 2; i > 1; i--) { suf[i] = min(suf[i + 1], nums[i]); } int ans = INT_MAX; int pre = nums[0]; for (int j = 1; j < n - 1; j++) { if (pre < nums[j] && nums[j] > suf[j + 1]) { ans = min(ans, pre + nums[j] + suf[j + 1]); } pre = min(pre, nums[j]); } return ans == INT_MAX ? -1 : ans; }
vector<vector<int>> constructProductMatrix(vector<vector<int>> &grid) { const int MOD = 12345; int n = grid.size(), m = grid[0].size(); vector<vector<int>> p(n, vector<int>(m)); long long suf = 1; for (int i = n - 1; i >= 0; i--) { for (int j = m - 1; j >= 0; j--) { p[i][j] = suf; suf = suf * grid[i][j] % MOD; } } long long pre = 1; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { p[i][j] = p[i][j] * pre % MOD; pre = pre * grid[i][j] % MOD; } } return p; }
string maximumOddBinaryNumber(string s) { int cnt1 = count(s.begin(), s.end(), '1'); return string(cnt1 - 1, '1') + string(s.length() - cnt1, '0') + '1'; }
string shortestBeautifulSubstring(string s, int k) { if (count(s.begin(), s.end(), '1') < k) { return ''; } string ans = s; int cnt1 = 0, left = 0; for (int right = 0; right < s.length(); right++) { cnt1 += s[right] - '0'; while (cnt1 > k || s[left] == '0') { cnt1 -= s[left++] - '0'; } if (cnt1 == k) { string t = s.substr(left, right - left + 1); if (t.length() < ans.length() || t.length() == ans.length() && t < ans) { ans = move(t); } } } return ans; }
int addMinimum(string s) { int t = 1; for (int i = 1; i < s.length(); ++i) t += s[i - 1] >= s[i]; return t * 3 - s.length(); }
int validSubarraySize(vector<int> &nums, int threshold) { int n = nums.size(); int left[n]; stack<int> s; for (int i = 0; i < n; ++i) { while (!s.empty() && nums[s.top()] >= nums[i]) s.pop(); left[i] = s.empty() ? -1 : s.top(); s.push(i); } int right[n]; s = stack<int>(); for (int i = n - 1; i >= 0; --i) { while (!s.empty() && nums[s.top()] >= nums[i]) s.pop(); right[i] = s.empty() ? n : s.top(); s.push(i); } for (int i = 0; i < n; ++i) { int k = right[i] - left[i] - 1; if (nums[i] > threshold / k) return k; } return -1; }
vector<int> lastVisitedIntegers(vector<string> &words) { vector<int> ans, a; int k = 0; for (auto &s: words) { if (s[0] != 'p') {  a.push_back(stoi(s)); k = 0; } else { ans.push_back(++k > a.size() ? -1 : a[a.size() - k]);  } } return ans; }
int minOperations(string s1, string s2, int x) { if (s1 == s2) return 0; vector<int> p; for (int i = 0; i < s1.size(); i++) if (s1[i] != s2[i]) p.push_back(i); if (p.size() % 2) return -1; int f0 = 0, f1 = x; for (int i = 1; i < p.size(); i++) { int new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2); f0 = f1; f1 = new_f; } return f1 / 2; }
int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) { sort(processorTime.begin(), processorTime.end()); sort(tasks.begin(), tasks.end(), greater<int>()); int ans = 0; for (int i = 0; i < processorTime.size(); i++) { ans = max(ans, processorTime[i] + tasks[i * 4]); } return ans; }
int differenceOfSums(int n, int m) { return n * (n + 1) / 2 - n / m * (n / m + 1) * m; }
int minSizeSubarray(vector<int> &nums, int target) { long long total = accumulate(nums.begin(), nums.end(), 0LL); int n = nums.size(); int ans = INT_MAX; int left = 0; long long sum = 0; for (int right = 0; right < n * 2; right++) { sum += nums[right % n]; while (sum > target % total) { sum -= nums[left++ % n]; } if (sum == target % total) { ans = min(ans, right - left + 1); } } return ans == INT_MAX ? -1 : ans + target / total * n; }
long long maximumTripletValue(vector<int> &nums) { int n = nums.size(); vector<int> suf_max(n + 1, 0); for (int i = n - 1; i > 1; i--) { suf_max[i] = max(suf_max[i + 1], nums[i]); } long long ans = 0; int pre_max = nums[0]; for (int j = 1; j < n - 1; j++) { ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]); pre_max = max(pre_max, nums[j]); } return ans; }
long long maximumTripletValue(vector<int> &nums) { int n = nums.size(); vector<int> suf_max(n + 1, 0); for (int i = n - 1; i > 1; i--) { suf_max[i] = max(suf_max[i + 1], nums[i]); } long long ans = 0; int pre_max = nums[0]; for (int j = 1; j < n - 1; j++) { ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]); pre_max = max(pre_max, nums[j]); } return ans; }
int maxSubarrays(vector<int> &nums) { int ans = 0; int a = -1;  for (int x : nums) { a &= x; if (a == 0) { ans++;  a = -1; } } return max(ans, 1);  }
int minOperations(vector<int> &nums) { unordered_map<int, int> cnt; for (int x : nums) { cnt[x]++; } int ans = 0; for (auto &[_, c] : cnt) { if (c == 1) { return -1; } ans += (c + 2) / 3; } return ans; }
int minOperations(std::vector<int>& nums, int k) { int n = nums.size(); long long u = (2LL << k) - 2; long long s = 0; for (int i = n - 1; ; --i) { s |= 1LL << nums[i]; if ((s & u) == u) { return n - i; } } }
int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>> &composition, vector<int> &stock, vector<int> &cost) { int ans = 0; int mx = *min_element(stock.begin(), stock.end()) + budget; for (auto &com: composition) { auto check = [&](long long num) -> bool { long long money = 0; for (int i = 0; i < n; i++) { if (stock[i] < com[i] * num) { money += (com[i] * num - stock[i]) * cost[i]; if (money > budget) { return false; } } } return true; }; int left = 0, right = mx + 1; while (left + 1 < right) {  int mid = (left + right) / 2; (check(mid) ? left : right) = mid; } ans = max(ans, left); } return ans; }
int countWays(vector<int> &nums) { sort(nums.begin(), nums.end()); int n = nums.size(); int ans = nums[0] > 0;  for (int i = 0; i < n - 1; i++) { if (nums[i] < i + 1 && i + 1 < nums[i + 1]) { ans++; } } return ans + 1; }
int sumIndicesWithKSetBits(vector<int> &nums, int k) { int ans = 0, n = nums.size(); for (int i = 0; i < n; i++) { if (__builtin_popcount(i) == k) { ans += nums[i]; } } return ans; }
int countPairs(vector<vector<int>> &coordinates, int k) { int ans = 0; unordered_map<long long, int> cnt; for (auto &p: coordinates) { for (int i = 0; i <= k; i++) { auto it = cnt.find((p[0] ^ i) * 2000000LL + (p[1] ^ (k - i))); if (it != cnt.end()) { ans += it->second; } } cnt[p[0] * 2000000LL + p[1]]++; } return ans; }
int minimumRightShifts(vector<int>& nums) { int i = 1; int n = nums.size(); while (i < n && nums[i - 1] < nums[i]) { i++; } if (i == n) { return 0; } if (nums[0] < nums[n - 1]) { return -1; } int mid = i; i++; while (i < n && nums[i - 1] < nums[i]) { i++; } if (i < n) { return -1; } return n - mid; }
int minLengthAfterRemovals(vector<int> &nums) { int maxCnt = 0, cnt = 1, pre = nums[0]; int n = nums.size(); for(int i = 1; i < n; ++i) { if(pre == nums[i]) cnt++; else { maxCnt = max(maxCnt, cnt); pre = nums[i]; cnt = 1; } } maxCnt = max(maxCnt, cnt); if(maxCnt * 2 > n) return maxCnt - (n - maxCnt); else { if(n % 2 == 0) return 0; else return 1; } }
int numberOfPoints(vector<vector<int>> &nums) { int diff[102]{}; for (auto &p: nums) { diff[p[0]]++; diff[p[1] + 1]--; } int ans = 0, s = 0; for (int d: diff) { s += d; ans += s > 0; } return ans; }
bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx && sy == fy) return t != 1; return max(abs(sx - fx), abs(sy - fy)) <= t; }
long countInterestingSubarrays(vector<int> nums, int modulo, int k) { int n = nums.size(); long ans = 0; vector<int> preSum(n+1); for(int i=0;i<n;i++) preSum[i+1] = preSum[i] + (nums[i] % modulo == k?1:0); unordered_map<int,int> map; for(int i=0;i<=n;i++){ if(map.count((preSum[i]%modulo - k + modulo)%modulo)) ans += map[(preSum[i]%modulo - k + modulo)%modulo]; map[preSum[i]%modulo]++; } return ans; }
int minimumOperations(std::string num) { int len = num.length(); int zero = num.find('0') != std::string::npos ? len - 1 : len; return std::min({f('00', num), f('25', num), f('50', num), f('75', num), zero}); } int f(std::string target, std::string num) { int i = num.rfind(target[1]); if (i < 0) return num.length(); i = num.substr(0, i).rfind(target[0]); if (i < 0) return num.length(); return num.length() - i - 2; }
int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i <= high; i++) { string s = to_string(i); int n = s.length(); if (n % 2 > 0) { continue; } int sum = 0; for (int j = 0; j < n / 2; j++) { sum += s[j]; } for (int j = n / 2; j < n; j++) { sum -= s[j]; } if (sum == 0) { ans++; } } return ans; }
long long maxSum(vector<int> &nums, int m, int k) { long long ans = 0, sum = 0; unordered_map<int, int> cnt; for (int i = 0; i < k - 1; i++) {  sum += nums[i]; cnt[nums[i]]++; } for (int i = k - 1; i < nums.size(); i++) { sum += nums[i];  cnt[nums[i]]++; if (cnt.size() >= m) ans = max(ans, sum); int out = nums[i - k + 1]; sum -= out;  if (--cnt[out] == 0) cnt.erase(out); } return ans; }
bool checkStrings(string s1, string s2) { int cnt1[2][26]{}, cnt2[2][26]{}; for (int i = 0; i < s1.length(); i++) { cnt1[i % 2][s1[i] - 'a']++; cnt2[i % 2][s2[i] - 'a']++; } return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0; }
bool canBeEqual(string s1, string s2) { int cnt1[2][26]{}, cnt2[2][26]{}; for (int i = 0; i < s1.length(); i++) { cnt1[i % 2][s1[i] - 'a']++; cnt2[i % 2][s2[i] - 'a']++; } return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0; }
int furthestDistanceFromOrigin(string moves) { int cn = 0; int ans = 0; for (int i = 0; i < moves.length(); i++) { if (moves[i] == 'L') { ans--; } else if (moves[i] == 'R') { ans++; } else { cn++; } } return abs(ans) + cn; }
int longestEqualSubarray(vector<int> &nums, int k) { int n = nums.size(), ans = 0; vector<vector<int>> pos(n + 1); for (int i = 0; i < n; i++) pos[nums[i]].push_back(i - pos[nums[i]].size()); for (auto &ps: pos) { if (ps.size() <= ans) continue; int left = 0; for (int right = 0; right < ps.size(); right++) { while (ps[right] - ps[left] > k)  left++; ans = max(ans, right - left + 1); } } return ans; }
bool isAcronym(vector<string> &words, string s) { if (words.size() != s.length()) return false; for (int i = 0; i < words.size(); i++) if (words[i][0] != s[i]) return false; return true; }
int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }
int minimumOperations(vector<int>& nums) { vector<int> g; for (int x : nums) { int j = upperBound(g, x); if (j == g.size()) g.push_back(x); else g[j] = x; } return nums.size() - g.size(); } int upperBound(vector<int>& g, int target) { int left = -1; int right = g.size(); while (left + 1 < right) { int mid = left + (right - left) / 2; if (g[mid] <= target) left = mid; else right = mid; } return right; }
int countPairs(vector<int> &nums, int target) { sort(nums.begin(), nums.end()); int ans = 0, left = 0, right = nums.size() - 1; while (left < right) { if (nums[left] + nums[right] < target) { ans += right - left; left++; } else { right--; } } return ans; }
int minAbsoluteDifference(vector<int> &nums, int x) { int ans = INT_MAX, n = nums.size(); set<int> s = {INT_MIN / 2, INT_MAX};  for (int i = x; i < n; i++) { s.insert(nums[i - x]); int y = nums[i]; auto it = s.lower_bound(y);  ans = min(ans, min(*it - y, y - *prev(it)));  } return ans; }
ListNode *doubleIt(ListNode *head) { if (head->val > 4) head = new ListNode(0, head); for (auto cur = head; cur; cur = cur->next) { cur->val = cur->val * 2 % 10; if (cur->next && cur->next->val > 4) cur->val++; } return head; }
int maxSum(vector<int> &nums) { int ans = -1; vector<int> max_val(10, INT_MIN); for (int v: nums) { int max_d = 0; for (int x = v; x; x /= 10) max_d = max(max_d, x % 10); ans = max(ans, v + max_val[max_d]); max_val[max_d] = max(max_val[max_d], v); } return ans; }
string finalString(string s) { deque<char> q; bool tail = true; for (char c: s) { if (c == 'i') tail = !tail; else if (tail) q.push_back(c); else q.push_front(c); } return tail ? string(q.begin(), q.end()) : string(q.rbegin(), q.rend()); }
bool canSplitArray(vector<int> &nums, int m) { int n = nums.size(); if (n <= 2) return true; for (int i = 1; i < n; i++) if (nums[i - 1] + nums[i] >= m) return true; return false; }
int longestAlternatingSubarray(vector<int>& a, int threshold) { int ans = 0; int i = 0; int n = a.size(); while (i < n) { if (a[i] % 2 || a[i] > threshold) { i += 1; } else { int i0 = i; i += 1; while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) { i += 1; } ans = max(ans, i - i0); } } return ans; }
int minimumSeconds(vector<int>& nums) { int n = nums.size(); unordered_map<int, vector<int>> umap; for (int i = 0; i < n; i++) { umap[nums[i]].push_back(i); } int ans = n; for (auto &iter : umap) { auto &v = iter.second; v.push_back(v[0] + n); int mx = - 1; for (int i = 1; i < v.size(); i++) { mx = max(mx, (v[i] - v[i - 1]) / 2); } ans = min(ans, mx); } return ans; }
int numberOfEmployeesWhoMetTarget(vector<int> &hours, int target) { int ans = 0; for (int h: hours) { ans += h >= target; } return ans; }
vector<string> splitWordsBySeparator(vector<string>& words, char separator) { vector<string>ans;  function<void(string)> func = [&](string str){ string t=''; for(char i:str){ if(i==' ')continue; if(i==separator){ if(t.size())ans.push_back(t); t=''; }else t+=i; } if(t.size())ans.push_back(t); }; for(auto i:words){ func(i); } return ans; }
vector<int> miniMaxSum(vector<int>& a) { for (int i = 0; i < a.size(); ++i) { a[i] = static_cast<int>(a[i]); } int s = accumulate(a.begin(), a.end(), 0); auto [minIt, maxIt] = minmax_element(a.begin(), a.end()); return {s - *maxIt, s - *minIt}; }
int pickingNumbers(const vector<int>& a) { unordered_map<int, int> d; for (int num : a) { ++d[num]; } int best = 0; for (int i = 0; i < 99; ++i) { best = max(d[i] + d[i + 1], best); } return best; }
int summingSeries(long n) {   return (n * n) % 1000000007; }
vector<int> matchingStrings(const vector<string>& stringList, const vector<string>& queries) { vector<int> arr; for (const auto& i : queries) { int k = 0; for (const auto& j : stringList) { if (i == j) { ++k; } } arr.push_back(k); } return arr; }
int bsearch(const vector<int>& arr, int x) { int low = 0; int high = arr.size() - 1; int mid = 0; while (low <= high) { mid = low + (high - low) / 2; if (arr[mid] < x) { high = mid - 1; } else if (arr[mid] > x) { low = mid + 1; } else { return mid + 1; } } return low + 1; } vector<int> climbingLeaderboard(vector<int>& ranked, const vector<int>& player) { unordered_set<int> rank_set(ranked.begin(), ranked.end()); vector<int> rank_nums(rank_set.begin(), rank_set.end()); sort(rank_nums.begin(), rank_nums.end(), greater<int>()); vector<int> result; for (int score : player) { int rank = bsearch(rank_nums, score); result.push_back(rank); } return result; }
long arrayManipulation(int n, vector<vector<int>> queries) { vector<long> arr(n + 2, 0); long max = 0; long sum = 0;  for(auto query: queries){ arr[query[0]] += query[2]; arr[query[1] + 1] -= query[2]; }  for (auto val : arr){ sum += val; if(sum > max) max = sum; } return max; }
SinglyLinkedListNode* deleteNode(SinglyLinkedListNode* llist, int position) { if (llist == nullptr) { return nullptr; } if (position == 0) { SinglyLinkedListNode* newHead = llist->next; delete llist;  return newHead; } SinglyLinkedListNode* current = llist; for (int i = 0; current != nullptr && i < position - 1; ++i) { current = current->next; } if (current == nullptr || current->next == nullptr) { return llist; } SinglyLinkedListNode* nodeToDelete = current->next; current->next = current->next->next; delete nodeToDelete;  return llist; }
bool evaluateTree(TreeNode* root) { if (!root->left) { return root->val; } bool l = evaluateTree(root->left); bool r = evaluateTree(root->right); return root->val == 2 ? l or r : l and r; }
int andXorOr(vector<int> &a) { int m = 0; stack<int> s; for (int i : a) { while (!s.empty() && s.top() >= i) { m = max(m, i ^ s.top()); s.pop(); } if (!s.empty()) { m = max(m, i ^ s.top()); } s.push(i); } return m; }
vector<int> missingNumbers(vector<int> arr, vector<int> brr) { map<int, int> mp; for(int i = 0; i < brr.size(); i++) mp[brr[i]]++; for(int i = 0; i < arr.size(); i++) mp[arr[i]]--; map<int, int>::iterator it; vector<int> result; for(it = mp.begin(); it != mp.end(); it++) if(it->second > 0) result.push_back(it->first);  return result; }
long maximumSum(vector<long> &a, long m) { long long max=0, sum=0; set<long long> s; for (auto i=a.begin() ; i!=a.end() ; i++) { sum=(sum+*i)%m; if (sum>max) max=sum; auto b=s.upper_bound(sum); if (b!=s.end()) { long long possiblemax=(sum-*b+m)%m; if (possiblemax>max) max=possiblemax; } s.insert(sum); } return max; }
int formingMagicSquare(vector<vector<int>>& s) { vector<vector<vector<int>>> magicSquares = { {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}}, {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}}, {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}}, {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}}, {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}}, {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}}, {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}}, {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}} }; int minCost = 8 * 3; for (const auto& magicSquare : magicSquares) { int cost = 0; for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { cost += abs(s[i][j] - magicSquare[i][j]); } } minCost = min(cost, minCost); } return minCost; }
string isFibo(long long n) { long long start = 0, last = 1; while (last <= n) { long long tmp = last + start; start = last; last = tmp; if (last == n) { return 'IsFibo'; } } return 'IsNotFibo'; }
int solve(long long l, long long r) { set<long long> seen; deque<long long> q; for (int i = 0; i < 10; ++i) q.push_back(i); while (!q.empty()) { long long u = q.back(); q.pop_back(); if (to_string(u).length() >= 20) continue; if (seen.find(u) != seen.end()) continue; seen.insert(u); int length = to_string(u).length(); for (int k = length; k < length + 5; ++k) { if (to_string(u * k).length() == k) { q.push_back(u * k); } } } int count = 0; for (const auto &s : seen) { if (l <= s && s <= r) count++; } cout << '[' << l << ', ' << r << ']: ' << count << endl; return count; }
vector<string> cavityMap(vector<string> grid) { for (size_t k = 1; k < grid.size() - 1; ++k) { for (size_t j = 1; j < grid[k].size() - 1; ++j) { if (grid[k][j - 1] < grid[k][j] && grid[k][j] > grid[k][j + 1] && grid[k + 1][j] < grid[k][j] && grid[k - 1][j] < grid[k][j]) { grid[k][j] = 'X'; } } } return grid; }
long solve(int a, int b) { long m = a; long n = b; long ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1))); return m*n - 1; }
int minimumLoss(vector<long> price) { unordered_map<long, int> map; for (int i = 0; i < price.size(); ++i) { map[price[i]] = i; } sort(price.begin(), price.end()); long min = numeric_limits<int>::max(); for (int i = 0; i < price.size() - 1; ++i) { long currentMin = price[i + 1] - price[i]; if (currentMin < min && map[price[i]] > map[price[i + 1]]) min = currentMin; } return static_cast<int>(min); }
string dayOfProgrammer(int year) { if (year == 1918) { return '26.09.1918'; } bool leap_year = true; if ((year % 4 != 0) || (year > 1918 && year % 100 == 0 && year % 400 != 0)) { leap_year = false; } return leap_year ? '12.09.' + to_string(year) : '13.09.' + to_string(year); }
vector<int> acmTeam(const vector<string>& topic) { int teamLen = topic.size(); int topicLen = topic[0].size(); int maxKnown = 0; int maxTeams = 0; for (int i = 0; i < teamLen; ++i) { const string& t1 = topic[i]; for (int j = i + 1; j < teamLen; ++j) { int know = 0; const string& t2 = topic[j]; for (int k = 0; k < topicLen; ++k) { if (t1[k] == '1' || t2[k] == '1') ++know; } if (know == maxKnown) ++maxTeams; else if (know > maxKnown) { maxKnown = know; maxTeams = 1; } } } return {maxKnown, maxTeams}; }
string timeInWords(int h, int m) { vector<string> hour = {'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine',   'ten', 'eleven', 'twelve'}; vector<string> minutes = {'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen',  'seventeen', 'eighteen', 'nineteen', 'twenty', 'twenty one', 'twenty two',  'twenty three', 'twenty four', 'twenty five', 'twenty six', 'twenty seven',  'twenty eight', 'twenty nine'}; if (m == 0) { return hour[h - 1] + ' o' clock'; } else if (m == 15) { return 'quarter past ' + hour[h - 1]; } else if (m == 30) { return 'half past ' + hour[h - 1]; } else if (m == 45) { return 'quarter to ' + hour[h % 12]; } else if (m == 1) { return minutes[m - 1] + ' minute past ' + hour[h - 1]; } else if (m > 0 && m < 30) { return minutes[m - 1] + ' minutes past ' + hour[h - 1]; } else { return minutes[60 - m - 1] + ' minutes to ' + hour[h % 12]; } }
int collectTheCoins(vector<int> &coins, vector<vector<int>> &edges) { int n = coins.size(); vector<vector<int>> g(n); vector<int> deg(n); for (auto &e: edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x);  deg[x]++; deg[y]++;  } int left_edges = n - 1;  vector<int> q; for (int i = 0; i < n; i++) if (deg[i] == 1 && coins[i] == 0)  q.push_back(i); while (!q.empty()) { left_edges--;  int x = q.back(); q.pop_back(); for (int y: g[x]) if (--deg[y] == 1 && coins[y] == 0)  q.push_back(y); } for (int i = 0; i < n; i++) if (deg[i] == 1 && coins[i])  q.push_back(i); left_edges -= q.size();  for (int x: q)  for (int y: g[x]) if (--deg[y] == 1)  left_edges--;  return max(left_edges * 2, 0); }
void matrixRotation(vector<vector<int>>& matrix, int r) { int l = 0; int br = matrix.size(); int bc = matrix[0].size(); while (l < min(br, bc) / 2) { int rr = r % (2 * (br + bc - 4 * l - 2)); while (rr--) { int buf = matrix[l][l]; for (int j = l; j < bc - l - 1; ++j) { matrix[l][j] = matrix[l][j + 1]; } for (int i = l; i < br - l - 1; ++i) { matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]; } for (int j = bc - l - 1; j > l; --j) { matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]; } for (int i = br - l - 1; i > l + 1; --i) { matrix[i][l] = matrix[i - 1][l]; } matrix[l + 1][l] = buf; } ++l; } for (const auto& row : matrix) { for (const auto& elem : row) { cout << elem << ' '; } cout << endl; } }
int divisorSubstrings(int num, int k) { string s = to_string(num); int n = s.size(); int res = 0; for (int i = 0; i <= n - k; ++i) { int tmp = stoi(s.substr(i, k)); if (tmp && num % tmp == 0) { ++res; } } return res; }
vector<int> solve(const vector<int>& a) { vector<int> result; vector<int> cum(a.size(), 0); cum[0] = a[0]; for (size_t i = 1; i < a.size(); i++) { cum[i] = cum[i - 1] + a[i]; } int total = cum.back(); for (size_t i = 0; i < cum.size(); i++) { if (total % cum[i] == 0) { size_t j = i + 1; int segment_sum = 0; while (j < a.size() && segment_sum < cum[i]) { segment_sum += a[j]; if (segment_sum == cum[i]) { segment_sum = 0; } j++; } if (segment_sum == 0 && (j == a.size() || cum[i] == total)) { result.push_back(cum[i]); } } } return result; }
int maximumToys(vector<int>& prices, int k) { sort(prices.begin(), prices.end()); int toys = 0; for (int price : prices) { if (price <= k) { k -= price; ++toys; } else { break; } } return toys; }
int sumOfSquares(vector<int> &nums) { int ans = 0, n = nums.size(); for (int i = 1; i <= n; i++) { if (n % i == 0) { ans += nums[i - 1] * nums[i - 1]; } } return ans; }
bool checkArray(vector<int> &nums, int k) { int n = nums.size(), sum_d = 0; vector<int> d(n + 1); for (int i = 0; i < n; i++) { sum_d += d[i]; int x = nums[i]; x += sum_d; if (x == 0) continue; if (x < 0 || i + k > n) return false; sum_d -= x; d[i + k] += x; } return true; }
int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) { int n = nums1.size(); if (n == 1) return 1; vector<vector<int>> dp(n, vector<int>(2, 1)); int ans = 0; for (int i = 1; i < n; i++) { dp[i][0] = dp[i][1] = 1; if (nums1[i] >= nums1[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][0]+1); if (nums1[i] >= nums2[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][1]+1); if (nums2[i] >= nums1[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][0]+1); if (nums2[i] >= nums2[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][1]+1); ans = max(ans, max(dp[i][0], dp[i][1])); } return ans; }
int maximumJumps(vector<int>& nums, int target) { vector<int> dp(nums.size()); dp[0] = 0; for(int i = 1; i < nums.size(); ++i) { int res = INT_MIN; for(int j = 0; j < i; ++j) { if(abs(nums[i] - nums[j]) <= target) res = max(res, dp[j] + 1); dp[i] = res; } } return dp.back() < 0 ? -1 : dp.back(); }
int theMaximumAchievableX(int num, int t){ return num+t*2; }
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& coordinates) { vector<long long> ans(5); long long sum = (long long)(m-1) * (n-1); unordered_set<long long> st; int num = coordinates.size(); for(int i = 0; i < num; i++) st.insert((long long)coordinates[i][0] * n + coordinates[i][1]); vector<vector<pair<int, int>>> arr(4); arr[0] = {{0, -1}, {-1, -1}, {-1, 0}}; arr[1] = {{0, 1}, {-1, 0}, {-1, 1}}; arr[2] = {{0, -1}, {1, 0}, {1, -1}}; arr[3] = {{0, 1}, {1, 0}, {1, 1}}; for(int i = 0; i < num; i++) { long long x = coordinates[i][0], y = coordinates[i][1]; for(auto &a : arr) { int cnt = 1; for(auto& [dx, dy] : a) { long long nx = x + dx, ny = y + dy; if(nx < 0 || ny < 0 || nx >= m || ny >= n) { cnt = 0; break; } if(st.count(nx * n + ny)) cnt++; } ans[cnt]++; } } for(int i = 2; i <= 4; i++) ans[i] /= i; ans[0] = sum - ans[1] - ans[2] - ans[3] - ans[4]; return ans; }
int minimumBeautifulSubstrings(string s) { if(s[0]==0) return -1; unordered_map<string,int>s1; int n = s.size(); s1['1']++; s1['101']++; s1['11001']++; s1['1111101']++; s1['1001110001']++; s1['110000110101']++; s1['11110100001001']++; string s2=''; vector<int>f(n+10,1e9); f[0]=0; for(int i =0;i<n;i++) for(int j =i;j<n;j++) { s2=''; for(int k=i;k<=j;k++) s2+=s[k]; if(s1.find(s2)!=s1.end()) f[j+1]=min(f[j+1],f[i]+1); } if(f[n]==1e9) return -1; return f[n]; }
#include<iostream> #include<cmath> using namespace std; typedef long long ll; int m,n,ans,flag; ll gcd(ll x,ll y) { if(y==0){return x;} return gcd(y,x%y); } int main() { cin>>n>>m; for(int i=1;i<=sqrt(1ll*m*n);i++) { if((1ll*n*m)%i==0&&gcd(i,(1ll*n*m)/i)==n) { ans++; if(1ll*i*i==1ll*n*m)  flag=1; } } cout<<ans*2-flag; return 0; }
#include <cstdio> #include <iostream> #include <cmath> #include <cstdlib> using namespace std; int main() {int a=0,b=0,max=0,day=0;  for(int i=1;i<=7;i++){cin>>a>>b; if(max<(a+b)&&(a+b)>8) {max=a+b;day=i;} else continue;}  cout<<day;  return 0; }
int maximumValue(vector<string>& strs) { int res = 0; for (auto& s : strs) { bool isDigits = true; for (char& c : s) { isDigits &= isdigit(c); } res = max(res, isDigits ? stoi(s) : (int)s.size()); } return res; }
int countBeautifulPairs(vector<int> &nums) { int ans = 0, cnt[10]{}; for (int x: nums) { for (int y = 1; y < 10; y++) if (cnt[y] && gcd(x % 10, y) == 1) ans += cnt[y]; while (x >= 10) x /= 10; cnt[x]++; } return ans; }
vector<int> countServers(int n, vector<vector<int>> &logs, int x, vector<int> &queries) { int nq = queries.size(), id[nq], cnt[n + 1]; memset(cnt, 0, sizeof(cnt)); iota(id, id + nq, 0); sort(id, id + nq, [&](int i, int j) { return queries[i] < queries[j]; }); sort(logs.begin(), logs.end(), [](const auto &a, const auto &b) { return a[1] < b[1]; }); vector<int> ans(nq); int out_of_range = n, left = 0, right = 0; for (int i: id) { while (right < logs.size() && logs[right][1] <= queries[i]) if (cnt[logs[right++][0]]++ == 0) out_of_range--; while (left < logs.size() && logs[left][1] < queries[i] - x) if (--cnt[logs[left++][0]] == 0) out_of_range++; ans[i] = out_of_range; } return ans; }
bool isPossible(int n, vector<vector<int>> &edges) { unordered_set<int> g[n + 1]; for (auto &e : edges) { int x = e[0], y = e[1]; g[x].insert(y); g[y].insert(x); } vector<int> odd; for (int i = 1; i <= n; ++i) if (g[i].size() % 2) odd.push_back(i); int m = odd.size(); if (m == 0) return true; if (m == 2) { int x = odd[0], y = odd[1]; if (!g[x].count(y)) return true; for (int i = 1; i <= n; ++i) if (i != x && i != y && !g[i].count(x) && !g[i].count(y)) return true; return false; } if (m == 4) { int a = odd[0], b = odd[1], c = odd[2], d = odd[3]; return !g[a].count(b) && !g[c].count(d) || !g[a].count(c) && !g[b].count(d) || !g[a].count(d) && !g[b].count(c); } return false; }
int minExtraChar(string s, vector<string> &dictionary) { unordered_set<string> set(dictionary.begin(), dictionary.end()); int n = s.size(); vector<int> f(n + 1); for (int i = 0; i < n; i++) { f[i + 1] = f[i] + 1; for (int j = 0; j < i+1; j++) { if (set.count(s.substr(j, i - j + 1))) { f[i + 1] = min(f[i + 1], f[j]); } } } return f[n]; }
int maximumPoints(vector<vector<int>> &edges, vector<int> &coins, int k) { vector<vector<int>> g(coins.size()); for (auto &e : edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x); } return dfs(0, -1, g, coins, k)[0]; } array<int, 14> dfs(int x, int fa, const vector<vector<int>> &g, const vector<int> &coins, int k) { array<int, 14> res1{}, res2{}; for (int y : g[x]) { if (y == fa) continue; auto r = dfs(y, x, g, coins, k); for (int j = 0; j < 14; j++) { res1[j] += r[j]; if (j < 13) { res2[j] += r[j + 1]; } } } for (int j = 0; j < 14; j++) { res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1))); } return res1; }
int countCompleteComponents(int n, vector<vector<int>> &edges) { vector<vector<int>> g(n); for (auto &e : edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x); } vector<int> vis(n, 0); int ans = 0, v, e; for (int i = 0; i < n; i++) { if (!vis[i]) { v = 0; e = 0; dfs(i, vis, g, v, e); ans += e == v * (v - 1); } } return ans; } void dfs(int x, vector<int> &vis, vector<vector<int>> &g, int &v, int &e) { vis[x] = 1; v++; e += g[x].size(); for (int y : g[x]) if (!vis[y]) dfs(y, vis, g, v, e); }
bool reach(int x, int y, vector<vector<int>>& grid) { int n = grid.size(); int m = grid[0].size(); if (x == n - 1 && y == m - 1) { return true; } grid[x][y] = 0; int x1 = x, y1 = y + 1; if (y1 < m && grid[x1][y1] == 1) { bool ret = reach(x1, y1, grid); if (ret) { return ret; } } int x2 = x + 1, y2 = y; if (x2 < n && grid[x2][y2] == 1) { return reach(x2, y2, grid); } return false; } bool isPossibleToCutPath(vector<vector<int>>& grid) { int n = grid.size(); int m = grid[0].size(); if (!reach(0, 0, grid)) { return true; } grid[0][0] = 1; grid[n - 1][m - 1] = 1; if (!reach(0, 0, grid)) { return true; } return false; }
bool validPath(int n, vector<vector<int>>& edges, int source, int destination) { vector<list<int>> adj(n); for (auto& edge : edges) { int x = edge[0], y = edge[1]; adj[x].push_back(y); adj[y].push_back(x); } vector<bool> visited(n, false); return dfs(source, destination, adj, visited); } bool dfs(int source, int destination, vector<list<int>>& adj, vector<bool>& visited) { if (source == destination) { return true; } visited[source] = true; for (int next : adj[source]) { if (!visited[next] && dfs(next, destination, adj, visited)) { return true; } } return false; }
bool dfs(TreeNode* rt, ListNode* head) { if (head == NULL) return true; if (rt == NULL) return false; if (rt->val != head->val) return false; return dfs(rt->left, head->next) || dfs(rt->right, head->next); } bool isSubPath(ListNode* head, TreeNode* root) { if (root == NULL) return false; return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right); }
void inorder(TreeNode *node, vector<int> &res) { if (node) { inorder(node->left, res); res.push_back(node->val); inorder(node->right, res); } } vector<int> getAllElements(TreeNode *root1, TreeNode *root2) { vector<int> nums1, nums2; inorder(root1, nums1); inorder(root2, nums2); vector<int> merged; auto p1 = nums1.begin(), p2 = nums2.begin(); while (true) { if (p1 == nums1.end()) { merged.insert(merged.end(), p2, nums2.end()); break; } if (p2 == nums2.end()) { merged.insert(merged.end(), p1, nums1.end()); break; } if (*p1 < *p2) { merged.push_back(*p1++); } else { merged.push_back(*p2++); } } return merged; }
int maxLevelSum(TreeNode* root) { std::vector<int> sums; dfs(root, 0, sums); return (int)(std::max_element(sums.begin(), sums.end()) - sums.begin()) + 1; } void dfs(TreeNode* node, int level, std::vector<int>& sums) { if (!node) return; if (level == sums.size()) { sums.push_back(node->val); } else { sums[level] += node->val; } dfs(node->left, level + 1, sums); dfs(node->right, level + 1, sums); }
int dfs(TreeNode *root, int val) { if (root == nullptr) { return 0; } val = (val << 1) | root->val; if (root->left == nullptr && root->right == nullptr) { return val; } return dfs(root->left, val) + dfs(root->right, val); } int sumRootToLeaf(TreeNode* root) { return dfs(root, 0); }
vector<int> dfs(TreeNode* root, TreeNode* fa, int depth, int t){ if(root ==nullptr)  return vector<int>{-1, -1}; if(root->val == t){ return vector<int>{fa != nullptr ? fa->val : 1, depth}; } vector<int> l = dfs(root->left, root, depth + 1, t); if(l[0] != -1)  return l; return dfs(root->right, root, depth + 1, t); } bool isCousins(TreeNode* root, int x, int y) { vector<int> xi = dfs(root, nullptr, 0, x); vector<int> yi = dfs(root, nullptr, 0, y); return xi[1] == yi[1] && xi[0] != yi[0]; }
int longestSquareStreak(vector<int>& nums) { int ans = 0; unordered_set<int> s(nums.begin(), nums.end()); for (int x : s) { int cnt = 0; while (s.find(x) != s.end()) { cnt += 1; if (x > std::sqrt(INT_MAX)) break; x *= x; } ans = max(ans, cnt); } return ans > 1 ? ans : -1; }
int appendCharacters(string s, string t) { int j = 0, m = t.size(); for (char c : s) { if (c == t[j]) { j += 1; if (j == m) return 0; } } return m - j; }