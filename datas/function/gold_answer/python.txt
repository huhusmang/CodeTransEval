def testfunc(nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt1 = 0\n        for x in nums:\n            cnt1 += x >> i & 1\n        if cnt1 >= k:\n            ans |= 1 << i\n    return ans
def minSum(nums1, nums2):\n    s1 = 0\n    zero1 = False\n    for x in nums1:\n        if x == 0:\n            zero1 = True\n            s1 += 1\n        else:\n            s1 += x\n    s2 = 0\n    zero2 = False\n    for x in nums2:\n        if x == 0:\n            zero2 = True\n            s2 += 1\n        else:\n            s2 += x\n    if (not zero1 and s1 < s2) or (not zero2 and s2 < s1):\n        return -1\n    return max(s1, s2)
def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    f = [0] + [-inf] * target\n    s = 0\n    for x in nums:\n        s = min(s + x, target)\n        for j in range(s, x - 1, -1):\n            if f[j] < f[j - x] + 1:\n                f[j] = f[j - x] + 1\n    return f[-1] if f[-1] > 0 else -1
def minChanges(s):\n    ans = 0\n    for i in range(0, len(s), 2):\n        ans += int(s[i] != s[i + 1])\n    return ans
def minGroupsForValidAssignment(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    k = len(nums)\n    for c in cnt.values():\n        k = min(k, c)\n    while True:\n        ans = 0\n        for c in cnt.values():\n            if c // k < c % k:\n                ans = 0\n                break\n            ans += (c + k) // (k + 1)\n        if ans > 0:\n            return ans\n        k -= 1
def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    suf = [0] * n\n    suf[-1] = nums[-1]\n    for i in range(n - 2, 1, -1):\n        suf[i] = min(suf[i + 1], nums[i])\n    ans = inf\n    pre = nums[0]\n    for j in range(1, n - 1):\n        if pre < nums[j] > suf[j + 1]:\n            ans = min(ans, pre + nums[j] + suf[j + 1])\n        pre = min(pre, nums[j])\n    return ans if ans < inf else -1
def constructProductMatrix(grid: List[List[int]]) -> List[List[int]]:\n    MOD = 12345\n    n, m = len(grid), len(grid[0])\n    p = [[0] * m for _ in range(n)]\n    suf = 1  \n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            p[i][j] = suf  \n            suf = suf * grid[i][j] % MOD\n    pre = 1  \n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            p[i][j] = p[i][j] * pre % MOD  \n            pre = pre * x % MOD\n    return p
def maximumOddBinaryNumber(s: str) -> str:\n    cnt1 = s.count('1')\n    return '1' * (cnt1 - 1) + '0' * (len(s) - cnt1) + '1'
def shortestBeautifulSubstring(s: str, k: int) -> str:\n    if s.count('1') < k:\n        return ''\n    ans = s\n    cnt1 = left = 0\n    for right, c in enumerate(s):\n        cnt1 += int(c)\n        while cnt1 > k or s[left] == '0':\n            cnt1 -= int(s[left])\n            left += 1\n        if cnt1 == k:\n            t = s[left: right + 1]\n            if len(t) < len(ans) or len(t) == len(ans) and t < ans:\n                ans = t\n    return ans
def addMinimum(s):\n    t = 1\n    for i in range(1, len(s)):\n        t += s[i - 1] >= s[i]\n    return t * 3 - len(s)
def validSubarraySize(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    left, st = [-1] * n, []\n    for i, v in enumerate(nums):\n        while st and nums[st[-1]] >= v: st.pop()\n        if st: left[i] = st[-1]\n        st.append(i)\n    right, st = [n] * n, [] \n    for i in range(n - 1, -1, -1):\n        while st and nums[st[-1]] >= nums[i]: st.pop()\n        if st: right[i] = st[-1]\n        st.append(i)\n    for num, l, r in zip(nums, left, right):\n        k = r - l - 1\n        if num > threshold // k: return k\n    return -1
def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    k = 0\n    for s in words:\n        if s[0] != 'p':  \n            nums.append(int(s))\n            k = 0\n        else:\n            k += 1\n            ans.append(-1 if k > len(nums) else nums[-k])  \n    return ans
def minOperations(s1, s2, x):\n    if s1 == s2:\n        return 0\n    p = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    if len(p) % 2:\n        return -1\n    f0, f1 = 0, x\n    for i in range(1, len(p)):\n        new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)\n        f0, f1 = f1, new_f\n    return f1 // 2
def minProcessingTime(processorTime: List[int], tasks: List[int]) -> int:\n        processorTime.sort()\n        tasks.sort(reverse=True)\n        return max(p + t for p, t in zip(processorTime, tasks[::4]))
def differenceOfSums(n: int, m: int) -> int:\n        return n * (n + 1) // 2 - n // m * (n // m + 1) * m
def minSizeSubarray(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    n = len(nums)\n    ans = inf\n    left = s = 0\n    for right in range(n * 2):\n        s += nums[right % n]\n        while s > target % total:\n            s -= nums[left % n]\n            left += 1\n        if s == target % total:\n            ans = min(ans, right - left + 1)\n    return ans + target // total * n if ans < inf else -1
def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans
def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans
def maxSubarrays(nums: List[int]) -> int:\n    ans = 0\n    a = -1\n    for x in nums:\n        a &= x\n        if a == 0:\n            ans += 1 \n            a = -1\n    return max(ans, 1) 
def minOperations(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    ans = 0\n    for c in cnt.values():\n        if c == 1:\n            return -1\n        ans += (c + 2) // 3\n    return ans
def minOperations(nums: List[int], k: int) -> int:\n    u = (2 << k) - 2  \n    s, n = 0, len(nums)\n    for i in range(n - 1, -1, -1):\n        s |= 1 << nums[i]\n        if (s & u) == u:\n            return n - i
def maxNumberOfAlloys(n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    ans = 0\n    mx = min(stock) + budget\n    for com in composition:\n        def check(num: int) -> int:\n            money = 0\n            for s, base, c in zip(stock, com, cost):\n                if s < base * num:\n                    money += (base * num - s) * c\n                    if money > budget:\n                        return False\n            return True\n        left, right = 0, mx + 1\n        while left + 1 < right:  \n            mid = (left + right) // 2\n            if check(mid):\n                left = mid\n            else:\n                right = mid\n        ans = max(ans, left)\n    return ans
def countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = nums[0] > 0  \n    for i, (x, y) in enumerate(pairwise(nums)):\n        if x < i + 1 < y:\n            ans += 1\n    return ans + 1  
def sumIndicesWithKSetBits(nums, k):\n    ans = 0\n    for i in range(len(nums)):\n        if bin(i).count('1') == k:\n            ans += nums[i]\n    return ans
def countPairs(coordinates: List[List[int]], k: int) -> int:\n    ans = 0\n    cnt = Counter()\n    for x, y in coordinates:\n        for i in range(k + 1):\n            ans += cnt[x ^ i, y ^ (k - i)]  \n        cnt[x, y] += 1  \n    return ans
def minimumRightShifts(nums: List[int]) -> int:\n    i, n = 1, len(nums)\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i == n:\n        return 0\n    if nums[0] < nums[-1]:\n        return -1\n    mid = i\n    i += 1\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i < n:\n        return -1\n    return n - mid
def minLengthAfterRemovals(nums):\n    maxCnt = cnt = 1\n    pre = nums[0]\n    n = len(nums)\n    for i in range(1, n):\n        if pre == nums[i]:\n            cnt += 1\n        else:\n            maxCnt = max(maxCnt, cnt)\n            pre = nums[i]\n            cnt = 1\n    maxCnt = max(maxCnt, cnt)\n    if maxCnt * 2 > n:\n        return maxCnt - (n - maxCnt)\n    else:\n        return 0 if n % 2 == 0 else 1
def numberOfPoints(nums):\n    diff = [0] * 102\n    for p in nums:\n        diff[p[0]] += 1\n        diff[p[1] + 1] -= 1\n    ans = s = 0\n    for d in diff:\n        s += d\n        ans += s > 0\n    return ans
def isReachableAtTime(sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n    if sx == fx and sy == fy:\n        return t != 1\n    return max(abs(sx - fx), abs(sy - fy)) <= t
def countInterestingSubarrays(nums, modulo, k):\n    n = len(nums)\n    ans = 0\n    preSum = [0] * (n + 1)\n    for i in range(n):\n        preSum[i+1] = preSum[i] + (1 if nums[i] % modulo == k else 0)\n    count_map = {}\n    for i in range(n + 1):\n        key = (preSum[i] % modulo - k + modulo) % modulo\n        if key in count_map:\n            ans += count_map[key]\n        count_map[preSum[i] % modulo] = count_map.get(preSum[i] % modulo, 0) + 1\n    return ans
def minimumOperations(num):\n    len_num = len(num)\n    zero = len_num - 1 if '0' in num else len_num\n    return min(f('00', num), f('25', num), f('50', num), f('75', num), zero)\ndef f(target, num):\n    try:\n        i = num.rfind(target[1])\n        if i < 0:\n            return len(num)\n        i = num[:i].rfind(target[0])\n        if i < 0:\n            return len(num)\n        return len(num) - i - 2\n    except IndexError:\n        return len(num)
def countSymmetricIntegers(low, high):\n    ans = 0\n    for i in range(low, high + 1):\n        s = str(i)\n        n = len(s)\n        if n % 2 > 0:\n            continue\n        sum = 0\n        for j in range(n // 2):\n            sum += int(s[j])\n        for j in range(n // 2, n):\n            sum -= int(s[j])\n        if sum == 0:\n            ans += 1\n    return ans
def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    s = sum(nums[:k - 1])  \n    cnt = Counter(nums[:k - 1])\n    for out, in_ in zip(nums, nums[k - 1:]):\n        s += in_  \n        cnt[in_] += 1\n        if len(cnt) >= m:\n            ans = max(ans, s)\n        s -= out  \n        cnt[out] -= 1\n        if cnt[out] == 0:\n            del cnt[out]\n    return ans
def checkStrings(s1, s2):\n    cnt1 = [[0] * 26, [0] * 26]\n    cnt2 = [[0] * 26, [0] * 26]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2
def canBeEqual(s1, s2):\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2
def furthestDistanceFromOrigin(moves):\n    cn = 0\n    ans = 0\n    for i in range(len(moves)):\n        if moves[i] == 'L':\n            ans -= 1\n        elif moves[i] == 'R':\n            ans += 1\n        else:\n            cn += 1\n    return abs(ans) + cn
def longestEqualSubarray(nums: List[int], k: int) -> int:\n    pos = [[] for _ in range(len(nums) + 1)]\n    for i, x in enumerate(nums):\n        pos[x].append(i - len(pos[x]))\n    ans = 0\n    for ps in pos:\n        if len(ps) <= ans: continue\n        left = 0\n        for right, p in enumerate(ps):\n            while p - ps[left] > k:  \n                left += 1\n            ans = max(ans, right - left + 1)\n    return ans
def isAcronym(words, s):\n    if len(words) != len(s):\n        return False\n    for i in range(len(words)):\n        if words[i][0] != s[i]:\n            return False\n    return True
def minimumSum(n: int, k: int) -> int:\n        m = min(k // 2, n)\n        return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2
def minimumOperations(nums):\n    g = []\n    for x in nums:\n        j = upper_bound(g, x)\n        if j == len(g):\n            g.append(x)\n        else:\n            g[j] = x\n    return len(nums) - len(g)\ndef upper_bound(g, target):\n    left, right = -1, len(g)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if g[mid] <= target:\n            left = mid\n        else:\n            right = mid\n    return right
def countPairs(nums: List[int], target: int) -> int:\n    nums.sort()\n    ans = left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            ans += right - left\n            left += 1\n        else:\n            right -= 1\n    return ans
def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    ans = float('inf') \n    pre = [float('inf')] \n    for i in range(len(nums)-x):\n        insort_left(pre, nums[i]) \n        index = bisect_left(pre, nums[i+x])\n        tmp = min(abs(pre[index]-nums[i+x]) for index in (index, index-1))\n        ans = min(ans, tmp)\n    return ans 
def doubleIt(head: Optional[ListNode]) -> Optional[ListNode]:\n    if head.val > 4:\n        head = ListNode(0, head)\n    cur = head\n    while cur:\n        cur.val = cur.val * 2 % 10\n        if cur.next and cur.next.val > 4:\n            cur.val += 1\n        cur = cur.next\n    return head
def maxSum(nums: List[int]) -> int:\n    ans = -1\n    max_val = [-inf] * 10\n    for v in nums:\n        max_d = max(map(int, str(v)))\n        ans = max(ans, v + max_val[max_d])\n        max_val[max_d] = max(max_val[max_d], v)\n    return ans
def finalString(s: str) -> str:\n    q = deque()\n    tail = True\n    for c in s:\n        if c == 'i':\n            tail = not tail  \n        elif tail:  \n            q.append(c)\n        else:  \n            q.appendleft(c)\n    return ''.join(q if tail else reversed(q))
def canSplitArray(nums, m):\n    n = len(nums)\n    if n <= 2: \n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False
def longestAlternatingSubarray(a: List[int], threshold: int) -> int:\n    ans, i, n = 0, 0, len(a)\n    while i < n:\n        if a[i] % 2 or a[i] > threshold:\n            i += 1\n        else:\n            i0 = i\n            i += 1\n            while i < n and a[i] <= threshold and a[i] % 2 != a[i - 1] % 2:\n                i += 1 \n            ans = max(ans, i - i0)\n    return ans
def minimumSeconds(nums: List[int]) -> int:\n    pos = defaultdict(list)\n    for i, x in enumerate(nums):\n        pos[x].append(i)\n    ans = n = len(nums)\n    for a in pos.values():\n        a.append(a[0] + n)\n        mx = max((j - i) // 2 for i, j in pairwise(a))\n        ans = min(ans, mx)\n    return ans
def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n        ans = 0\n        for h in hours:\n                if h >= target:\n                        ans += 1\n        return ans
def splitWordsBySeparator(words, separator):\n    ans = []\n    def func(str):\n        t = ''\n        for i in str:\n            if i == ' ':\n                continue\n            if i == separator:\n                if t:\n                    ans.append(t)\n                t = ''\n            else:\n                t += i\n        if t:\n            ans.append(t)\n\n    for i in words:\n        func(i)\n    return ans
def miniMaxSum(a):\n    for i in range(0, len(a)):\n        a[i] = int(a[i])\n    s = sum(a)\n    return [s - max(a), s - min(a)]
def pickingNumbers(a):\n    from collections import Counter\n    d = Counter(a)\n    best = 0\n    for i in range(99):\n        best = max(d[i] + d[i+1], best)\n    return best
def summingSeries(n):\n    return pow(n ,2, 1000000007)
def matchingStrings(stringList, queries):\n    k = 0\n    arr = []\n    for i in queries:\n        for j in stringList:\n            if i == j:\n                k += 1\n        arr.append(k)\n        k = 0\n        \n    return [i for i in arr]
def bsearch(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0  # ranking\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] > x:\n            low = mid + 1\n        elif arr[mid] < x:\n            high = mid - 1\n        else:\n            return mid + 1\n    return low + 1\ndef climbingLeaderboard(ranked, player):\n    from collections import OrderedDict\n    rank_nums = list(OrderedDict.fromkeys(ranked))\n    result = []\n    for score in player:\n        rank = bsearch(rank_nums, score)\n        result.append(rank)\n    return result
def arrayManipulation(n, queries):\n    arr = [0] * (n + 2)\n    max_val = 0\n    sum_val = 0\n    \n    for query in queries:\n        arr[query[0]] += query[2]\n        arr[query[1] + 1] -= query[2]\n    \n    for val in arr:\n        sum_val += val\n        max_val = max(max_val, sum_val)\n        \n    return max_val
def deleteNode(llist, position):\n    if not llist:\n        return \n    if position == 0:\n        return llist.next\n    current = previous = llist\n    pointer = 1\n    while pointer < position+1:\n        previous = current\n        current = current.next\n        pointer += 1\n    previous.next = current.next\n    return llist
def evaluateTree(root: Optional[TreeNode]) -> bool:\n    if root.left is None:\n        return bool(root.val)\n    l = evaluateTree(root.left)\n    r = evaluateTree(root.right)\n    return l or r if root.val == 2 else l and r
def andXorOr(a):\n    m = 0\n    s = []\n    for i in a:     \n        while s and s[-1] >= i:\n            m = max(m, i^s.pop())\n        if s:\n            m = max(m, i^s[-1])\n        s.append(i)\n    return m
def missingNumbers(arr, brr):\n    from collections import Counter\n    \n    mp = Counter(brr)\n    for num in arr:\n        mp[num] -= 1\n        \n    result = sorted([num for num, count in mp.items() if count > 0])\n    \n    return result
def maximumSum(a, m):\n    max_sum = 0\n    current_sum = 0\n    s = set()\n    for number in a:\n        current_sum = (current_sum + number) % m\n        max_sum = max(max_sum, current_sum)\n        b = next((x for x in s if x > current_sum), None)\n        if b is not None:\n            possible_max = (current_sum - b + m) % m\n            max_sum = max(max_sum, possible_max)\n        s.add(current_sum)\n    return max_sum
def formingMagicSquare(s):\n    magicSquares = [\n        [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\n        [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\n        [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\n        [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\n        [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\n        [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\n        [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\n        [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    ]\n    minCost = 8*3\n    for magicSquare in magicSquares:\n        cost = 0\n        for i in range(3):\n            for j in range(3):\n                cost += abs(s[i][j] - magicSquare[i][j])\n        minCost = min(cost , minCost)\n    return minCost 
def isFibo(n):\n    start = 0\n    last = 1\n    while last <= n:\n        tmp = last + start\n        start = last\n        last = tmp\n        if last== n:\n            return 'IsFibo'\n    return 'IsNotFibo'
def solve(l, r):\n    from collections import deque\n    seen = set()\n    q = deque()\n    q.extend(range(10))\n    while q:\n        u = q.pop()\n        if len(str(u)) >= 20:\n            continue\n        if u in seen:\n            continue\n        seen.add(u)\n        length = len(str(u))\n        for k in range(length, length + 5):\n            if len(str(u * k)) == k:\n                q.append(u * k)\n    print(f'[{l}, {r}]: {sum(l <= s <= r for s in seen)}')\n    return sum(l <= s <= r for s in seen)
def cavityMap(grid):\n    for k in range(1,len(grid)-1):\n        i = grid[k]\n        d = grid[k+1]\n        u = grid[k-1]\n        for j in range(1, len(grid)-1):\n            if (i[j-1] < i[j] > i[j+1]) and (d[j] <i[j] > u[j]):\n                x= list(grid[k])\n                x[j] = 'X'\n                grid[k] = ''.join(x)\n    return grid
def solve(a, b):\n    m = a\n    n = b\n    ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)))\n    return m*n - 1
def minimumLoss(price):\n    map_index = {p: i for i, p in enumerate(price)}\n    price.sort()\n    min_loss = float('inf')\n    for i in range(len(price) - 1):\n        current_loss = price[i+1] - price[i]\n        if current_loss < min_loss and map_index[price[i]] > map_index[price[i+1]]:\n            min_loss = current_loss\n    return int(min_loss)
def dayOfProgrammer(year):\n    if 1918==year:\n        return '26.09.1918'\n    leap_year = True\n    if year % 4 or year > 1918 and not year % 100 and year % 400:\n        leap_year = False\n    return '.'.join(['12' if leap_year else '13', '09', str(year)])
def acmTeam(topic):\n    teamLen = len(topic)\n    topicLen = len(topic[0])\n    maxKnown = 0\n    maxTeams = 0\n    for i in range(teamLen):\n        t1 = topic[i]\n        for j in range(i + 1, teamLen):\n            know = 0\n            t2 = topic[j]\n            for k in range(topicLen):\n                if t1[k] == '1' or t2[k] == '1':\n                    know += 1\n            if know == maxKnown:\n                maxTeams += 1\n            elif know > maxKnown:\n                maxKnown = know\n                maxTeams = 1\n    return [maxKnown, maxTeams]
def timeInWords(h, m):\n    hour = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve']\n    minutes = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen',\n               'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', 'twenty', \n               'twenty one', 'twenty two', 'twenty three', 'twenty four', 'twenty five', \n               'twenty six', 'twenty seven', 'twenty eight', 'twenty nine']\n    if m == 0:\n        return hour[h - 1] + ' o' clock'\n    elif m == 15:\n        return 'quarter past ' + hour[h - 1]\n    elif m == 30:\n        return 'half past ' + hour[h - 1]\n    elif m == 45:\n        return 'quarter to ' + hour[(h % 12)]\n    elif m == 1:\n        return minutes[m - 1] + ' minute past ' + hour[h - 1]\n    elif 0 < m < 30:\n        return minutes[m - 1] + ' minutes past ' + hour[h - 1]\n    else:\n        return minutes[60 - m - 1] + ' minutes to ' + hour[h % 12]
def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)  \n    deg = list(map(len, g))  \n    left_edges = n - 1      \n    q = []\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c == 0:  \n            q.append(i)\n    while q:\n        left_edges -= 1  \n        for y in g[q.pop()]:\n            deg[y] -= 1\n            if deg[y] == 1 and coins[y] == 0:  \n                q.append(y)\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c:  \n            q.append(i)\n    left_edges -= len(q)  \n    for x in q:  \n        for y in g[x]:\n            deg[y] -= 1\n            if deg[y] == 1:  \n                left_edges -= 1  \n    return max(left_edges * 2, 0)
def matrixRotation(matrix, r):\n    l, br, bc = 0, len(matrix), len(matrix[0])\n    while l < min(br, bc) / 2:\n        rr = r % (2 * (br + bc - l * 4 - 2))\n        while (rr) != 0:\n            rr -= 1\n            buf = matrix[l][l]\n            for j in range(l, bc - l - 1):\n                matrix[l][j] = matrix[l][j + 1]\n            for i in range(l, br - l - 1):\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]\n            for j in range(bc - l - 1, l, -1):\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]\n            for i in range(br - l - 1, l + 1, -1):\n                matrix[i][l] = matrix[i - 1][l]\n            matrix[l + 1][l] = buf\n        l += 1\n    for row in matrix:\n        print(' '.join(map(lambda s: str(s), row)))
def divisorSubstrings(num: int, k: int) -> int:\n    s = str(num)\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        tmp = int(s[i:i+k])\n        if tmp != 0 and num % tmp == 0:\n            res += 1\n    return res
def solve(a):\n    result = []\n    cum = [0] * len(a)\n    cum[0] = a[0]\n    for i in range(1, len(a)):\n        cum[i] = cum[i-1] + a[i]\n    total = cum[-1]\n    for i in range(len(cum)):\n        if total % cum[i] == 0:\n            j = i + 1\n            segment_sum = 0\n            while j < len(a) and segment_sum < cum[i]:\n                segment_sum += a[j]\n                if segment_sum == cum[i]:\n                    segment_sum = 0\n                j += 1\n            if segment_sum == 0 and (j == len(a) or cum[i] == total):\n                result.append(cum[i])\n    return result
def maximumToys(prices, k):\n    prices = sorted(prices)\n    toys = 0\n    for i in prices:\n        if i <= k:\n            k = k - i\n            toys = toys + 1\n        else:\n            break\n    return toys
def sumOfSquares(nums):\n    ans = 0\n    n = len(nums)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            ans += nums[i - 1] ** 2\n    return ans
def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    d = [0] * (n + 1)\n    sum_d = 0\n    for i, x in enumerate(nums):\n        sum_d += d[i]\n        x += sum_d\n        if x == 0: continue  \n        if x < 0 or i + k > n: return False  \n        sum_d -= x  \n        d[i + k] += x\n    return True
def maxNonDecreasingLength(nums1, nums2):\n    n = len(nums1)\n    if n == 1:\n        return 1\n    dp = [[1] * 2 for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        dp[i][0] = dp[i][1] = 1\n        if nums1[i] >= nums1[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][0] + 1)\n        if nums1[i] >= nums2[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\n        if nums2[i] >= nums1[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][0] + 1)\n        if nums2[i] >= nums2[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\n        ans = max(ans, max(dp[i][0], dp[i][1]))\n    return ans
def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-inf] * n\n    f[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= target:\n                f[i] = max(f[i], f[j] + 1)\n    return -1 if f[-1] < 0 else f[-1]
def theMaximumAchievableX(num: int, t: int) -> int:\n        return num + t * 2
def countBlackBlocks(m, n, coordinates):\n    ans = [0] * 5\n    sum_blocks = (m - 1) * (n - 1)\n    st = set((x * n + y) for x, y in coordinates)\n    arr = [\n        [(0, -1), (-1, -1), (-1, 0)],\n        [(0, 1), (-1, 0), (-1, 1)],\n        [(0, -1), (1, 0), (1, -1)],\n        [(0, 1), (1, 0), (1, 1)]\n    ]\n    for x, y in coordinates:\n        for a in arr:\n            cnt = 1\n            for dx, dy in a:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or ny < 0 or nx >= m or ny >= n:\n                    cnt = 0\n                    break\n                if (nx * n + ny) in st:\n                    cnt += 1\n            ans[cnt] += 1\n    for i in range(2, 5):\n        ans[i] //= i\n    ans[0] = sum_blocks - sum(ans[1:])\n    return ans
def minimumBeautifulSubstrings(s):\n    if s[0] == '0':\n        return -1\n    beautiful_strings = {'1', '101', '11001', '1111101', '1001110001', '110000110101', '11110100001001'}\n    n = len(s)\n    f = [float('inf')] * (n + 10)\n    f[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            current_substring = s[i:j+1]\n            if current_substring in beautiful_strings:\n                f[j+1] = min(f[j+1], f[i] + 1)\n    if f[n] == float('inf'):\n        return -1\n    return f[n]
def main():\n    x0, y0 = map(int, input().split())\n    def gcd(x, y):  \n        if x < y:\n            x, y = y, x\n        r = x % y  \n        while r != 0:\n            x = y\n            y = r\n            r = x % y\n        return y\n    def lcm(x, y):  \n        if x < y:\n            x, y = y, x\n        m = x\n        while x % y != 0:\n            x = x+m\n        return x\n    n = x0 * y0  \n    ans = 0\n    for i in range(x0,y0+1):  \n        if n % i == 0 and gcd(i, n // i) == x0 and lcm(i, n // i) == y0:  \n            ans += 1\n    print(ans)
def main():\n    c=0\n    max=0\n    for i in range(1,8):\n        a, b = map(int, input().split())\n        sum=a+b\n        if(a+b>8 and a+b>max):\n            max=sum\n            c=i\n    print(c)
def maximumValue(strs: List[str]) -> int:\n    res = 0\n    for s in strs:\n        is_digits = all(c.isdigit() for c in s)\n        res = max(res, int(s) if is_digits else len(s))\n    return res
def countBeautifulPairs(nums: List[int]) -> int:\n    ans, cnt = 0, [0] * 10\n    for x in nums:\n        for y in range(1, 10):\n            if cnt[y] and gcd(x % 10, y) == 1:\n                ans += cnt[y]\n        while x >= 10: x //= 10\n        cnt[x] += 1\n    return ans
def countServers(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    logs.sort(key=lambda p: p[1])  \n    ans = [0] * len(queries)\n    cnt = [0] * (n + 1)\n    out_of_range = n\n    left = right = 0\n    for qi, q in sorted(enumerate(queries), key=lambda p: p[1]):\n        while right < len(logs) and logs[right][1] <= q:  \n            i = logs[right][0]\n            if cnt[i] == 0: out_of_range -= 1\n            cnt[i] += 1\n            right += 1\n        while left < len(logs) and logs[left][1] < q - x:  \n            i = logs[left][0]\n            cnt[i] -= 1\n            if cnt[i] == 0: out_of_range += 1\n            left += 1\n        ans[qi] = out_of_range\n    return ans
def isPossible(n: int, edges: List[List[int]]) -> bool:\n    g = defaultdict(set)\n    for x, y in edges:\n        g[x].add(y)\n        g[y].add(x)\n    odd = [i for i, nb in g.items() if len(nb) % 2]\n    m = len(odd)\n    if m == 0: return True\n    if m == 2:\n        x, y = odd\n        return x not in g[y] or any(\n            i != x and i != y and x not in g[i] and y not in g[i]\n            for i in range(1, n + 1))\n    if m == 4:\n        a, b, c, d = odd\n        return b not in g[a] and d not in g[c] or \\n                c not in g[a] and d not in g[b] or \\n                d not in g[a] and c not in g[b]\n    return False
def minExtraChar(s: str, dictionary: List[str]) -> int:\n    d = set(dictionary)\n    n = len(s)\n    f = [0] * (n + 1)\n    for i in range(n):\n        f[i + 1] = f[i] + 1  \n        for j in range(i + 1):  \n            if s[j:i + 1] in d:\n                f[i + 1] = min(f[i + 1], f[j])\n    return f[n]
def maximumPoints(edges: List[List[int]], coins: List[int], k: int) -> int:\n    g = [[] for _ in coins]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    return dfs(0, -1, g, coins, k)[0]\ndef dfs(x: int, fa: int, g, coins, k) -> List[int]:\n    res1 = [0] * 14\n    res2 = [0] * 14\n    for y in g[x]:\n        if y == fa: continue\n        r = dfs(y, x, g, coins, k)\n        for j, v in enumerate(r):\n            res1[j] += v\n            if j < 13:\n                res2[j] += r[j + 1]\n    for j, (r1, r2) in enumerate(zip(res1, res2)):\n        res1[j] = max(r1 + (coins[x] >> j) - k, r2 + (coins[x] >> (j + 1)))\n    return res1
def dfs(x: int, g: List[List[int]], vis: List[bool], counts: List[int]) -> None:\n    vis[x] = True\n    counts[0] += 1\n    counts[1] += len(g[x])\n    for y in g[x]:\n        if not vis[y]:\n            dfs(y, g, vis, counts)\ndef countCompleteComponents(n: int, edges: List[List[int]]) -> int:\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    vis = [False] * n\n    ans = 0\n    for i in range(n):\n        if not vis[i]:\n            counts = [0, 0]\n            dfs(i, g, vis, counts)\n            v, e = counts\n            ans += e == v * (v - 1)\n    return ans
def reach(x: int, y: int, grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if x == n - 1 and y == m - 1:\n        return True\n    grid[x][y] = 0\n    x1, y1 = x, y + 1\n    if y1 < m and grid[x1][y1] == 1:\n        ret = reach(x1, y1, grid)\n        if ret:\n            return ret\n    x2, y2 = x + 1, y\n    if x2 < n and grid[x2][y2] == 1:\n        return reach(x2, y2, grid)\n    return False\ndef isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if not reach(0, 0, grid):\n        return True\n    grid[0][0], grid[n - 1][m - 1] = 1, 1\n    if not reach(0, 0, grid):\n        return True\n    return False
def validPath(n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    adj = {i: [] for i in range(n)}\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    return dfs(source, destination, adj, visited)\ndef dfs(source: int, destination: int, adj: dict, visited: List[bool]) -> bool:\n    if source == destination:\n        return True\n    visited[source] = True\n    for next in adj[source]:\n        if not visited[next] and dfs(next, destination, adj, visited):\n            return True\n    return False
def dfs(head: ListNode, rt: TreeNode) -> bool:\n    if not head:\n        return True\n    if not rt:\n        return False\n    if rt.val != head.val:\n        return False\n    return dfs(head.next, rt.left) or dfs(head.next, rt.right)\ndef isSubPath(head: ListNode, root: TreeNode) -> bool:\n    if not root:\n        return False\n    return dfs(head, root) or isSubPath(head, root.left) or isSubPath(head, root.right)
def inorder(node, res):\n    if node:\n        inorder(node.left, res)\n        res.append(node.val)\n        inorder(node.right, res)\ndef getAllElements(root1, root2):\n    nums1, nums2 = [], []\n    inorder(root1, nums1)\n    inorder(root2, nums2)\n    merged = []\n    p1, p2 = 0, 0\n    while True:\n        if p1 == len(nums1):\n            merged.extend(nums2[p2:])\n            break\n        if p2 == len(nums2):\n            merged.extend(nums1[p1:])\n            break\n        if nums1[p1] < nums2[p2]:\n            merged.append(nums1[p1])\n            p1 += 1\n        else:\n            merged.append(nums2[p2])\n            p2 += 1\n    return merged
def maxLevelSum(root: Optional[TreeNode]) -> int:\n    sums = []\n    dfs(root, 0, sums)\n    return sums.index(max(sums)) + 1  \ndef dfs(node: TreeNode, level: int, sums) -> None:\n    if level == len(sums):\n        sums.append(node.val)\n    else:\n        sums[level] += node.val\n    if node.left:\n        dfs(node.left, level + 1, sums)\n    if node.right:\n        dfs(node.right, level + 1, sums)
def sumRootToLeaf(root: Optional[TreeNode]) -> int:\n    return dfs(root, 0)\ndef dfs(node: Optional[TreeNode], val: int) -> int:\n    if node is None:\n        return 0\n    val = (val << 1) | node.val\n    if node.left is None and node.right is None:\n        return val\n    return dfs(node.left, val) + dfs(node.right, val)
def dfs(root, fa, depth, t):\n    if root is None:\n        return [-1, -1]\n    if root.val == t:\n        return [fa.val if fa else -1, depth]\n    l = dfs(root.left, root, depth + 1, t)\n    if l[0] != -1:\n        return l\n    return dfs(root.right, root, depth + 1, t)\ndef isCousins(root, x, y):\n    xi = dfs(root, None, 0, x)\n    yi = dfs(root, None, 0, y)\n    return xi[1] == yi[1] and xi[0] != yi[0]
def longestSquareStreak(nums: List[int]) -> int:\n    ans, s = 0, set(nums)\n    for x in s:\n        cnt = 0\n        while x in s:\n            cnt += 1\n            x *= x\n        ans = max(ans, cnt)\n    return ans if ans > 1 else -1
def appendCharacters(s: str, t: str) -> int:\n    j, m = 0, len(t)\n    for c in s:\n        if c == t[j]:\n            j += 1\n            if j == m: return 0\n    return m - j