{"task": "python_java", "problem_id": 1, "prediction_id": 0, "pro_prediction": "public static int findKOr(int[] nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += x >> i & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}", "main_fun_name": "findKOr", "raw_prediction": "\"```java\\npublic int findKOr(int[] nums, int k) {\\n    int ans = 0;\\n    for (int i = 0; i < 31; i++) {\\n        int cnt1 = 0;\\n        for (int x : nums) {\\n            cnt1 += x >> i & 1;\\n        }\\n        if (cnt1 >= k) {\\n            ans |= 1 << i;\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def findKOr(nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt1 = 0\n        for x in nums:\n            cnt1 += x >> i & 1\n        if cnt1 >= k:\n            ans |= 1 << i\n    return ans", "tl_gold_code": "public static int findKOr(int[] nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 2, "prediction_id": 0, "pro_prediction": "public static long minSum(int[] nums1, int[] nums2) {\n    long s1 = 0;\n    boolean zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1 += 1;\n        } else {\n            s1 += x;\n        }\n    }\n    long s2 = 0;\n    boolean zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2 += 1;\n        } else {\n            s2 += x;\n        }\n    }\n    if ((!zero1 && s1 < s2) || (!zero2 && s2 < s1)) {\n        return -1;\n    }\n    return Math.max(s1, s2);\n}", "main_fun_name": "minSum", "raw_prediction": "\"```java\\npublic long minSum(int[] nums1, int[] nums2) {\\n    long s1 = 0;\\n    boolean zero1 = false;\\n    for (int x : nums1) {\\n        if (x == 0) {\\n            zero1 = true;\\n            s1 += 1;\\n        } else {\\n            s1 += x;\\n        }\\n    }\\n    long s2 = 0;\\n    boolean zero2 = false;\\n    for (int x : nums2) {\\n        if (x == 0) {\\n            zero2 = true;\\n            s2 += 1;\\n        } else {\\n            s2 += x;\\n        }\\n    }\\n    if ((!zero1 && s1 < s2) || (!zero2 && s2 < s1)) {\\n        return -1;\\n    }\\n    return Math.max(s1, s2);\\n}\\n```\"", "sl_gold_code": "def minSum(nums1, nums2):\n    s1 = 0\n    zero1 = False\n    for x in nums1:\n        if x == 0:\n            zero1 = True\n            s1 += 1\n        else:\n            s1 += x\n    s2 = 0\n    zero2 = False\n    for x in nums2:\n        if x == 0:\n            zero2 = True\n            s2 += 1\n        else:\n            s2 += x\n    if (not zero1 and s1 < s2) or (not zero2 and s2 < s1):\n        return -1\n    return max(s1, s2)", "tl_gold_code": "public static long minSum(int[] nums1, int[] nums2) {\n    long s1 = 0;\n    boolean zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long s2 = 0;\n    boolean zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if (!zero1 && s1 < s2 || !zero2 && s2 < s1) {\n        return -1;\n    }\n    return Math.max(s1, s2);\n}"}
{"task": "python_java", "problem_id": 3, "prediction_id": 0, "pro_prediction": "public static int lengthOfLongestSubsequence(List<Integer> nums, int target) {\n        int[] f = new int[target + 1];\n        Arrays.fill(f, Integer.MIN_VALUE);\n        f[0] = 0;\n        int s = 0;\n        for (int x : nums) {\n            s = Math.min(s + x, target);\n            for (int j = s; j > x - 1; j--) {\n                if (f[j] < f[j - x] + 1) {\n                    f[j] = f[j - x] + 1;\n                }\n            }\n        }\n        return f[target] > 0 ? f[target] : -1;\n    }", "main_fun_name": "lengthOfLongestSubsequence", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int lengthOfLongestSubsequence(List<Integer> nums, int target) {\\n        int[] f = new int[target + 1];\\n        Arrays.fill(f, Integer.MIN_VALUE);\\n        f[0] = 0;\\n        int s = 0;\\n        for (int x : nums) {\\n            s = Math.min(s + x, target);\\n            for (int j = s; j > x - 1; j--) {\\n                if (f[j] < f[j - x] + 1) {\\n                    f[j] = f[j - x] + 1;\\n                }\\n            }\\n        }\\n        return f[target] > 0 ? f[target] : -1;\\n    }\\n}\\n```\"", "sl_gold_code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    f = [0] + [-inf] * target\n    s = 0\n    for x in nums:\n        s = min(s + x, target)\n        for j in range(s, x - 1, -1):\n            if f[j] < f[j - x] + 1:\n                f[j] = f[j - x] + 1\n    return f[-1] if f[-1] > 0 else -1", "tl_gold_code": "public static int lengthOfLongestSubsequence(List<Integer> nums, int target) {\n    int[] f = new int[target + 1];\n    Arrays.fill(f, Integer.MIN_VALUE);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = Math.min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = Math.max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}"}
{"task": "python_java", "problem_id": 4, "prediction_id": 0, "pro_prediction": "public static int minChanges(String s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += Integer.parseInt(s.charAt(i) != s.charAt(i + 1) ? \"1\" : \"0\");\n    }\n    return ans;\n}", "main_fun_name": "minChanges", "raw_prediction": "\"```java\\npublic int minChanges(String s) {\\n    int ans = 0;\\n    for (int i = 0; i < s.length(); i += 2) {\\n        ans += Integer.parseInt(s.charAt(i) != s.charAt(i + 1) ? \\\"1\\\" : \\\"0\\\");\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def minChanges(s):\n    ans = 0\n    for i in range(0, len(s), 2):\n        ans += int(s[i] != s[i + 1])\n    return ans", "tl_gold_code": "public static int minChanges(String s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s.charAt(i) != s.charAt(i + 1)) {\n            ans++;\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 5, "prediction_id": 0, "pro_prediction": "public static int minGroupsForValidAssignment(int[] nums) {\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int x : nums) {\n        cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n    }\n    int k = nums.length;\n    for (int c : cnt.values()) {\n        k = Math.min(k, c);\n    }\n    while (true) {\n        int ans = 0;\n        for (int c : cnt.values()) {\n            if (c / k < c % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c + k) / (k + 1);\n        }\n        if (ans > 0) {\n            return ans;\n        }\n        k--;\n    }\n}", "main_fun_name": "minGroupsForValidAssignment", "raw_prediction": "\"```java\\npublic int minGroupsForValidAssignment(int[] nums) {\\n    Map<Integer, Integer> cnt = new HashMap<>();\\n    for (int x : nums) {\\n        cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n    }\\n    int k = nums.length;\\n    for (int c : cnt.values()) {\\n        k = Math.min(k, c);\\n    }\\n    while (true) {\\n        int ans = 0;\\n        for (int c : cnt.values()) {\\n            if (c / k < c % k) {\\n                ans = 0;\\n                break;\\n            }\\n            ans += (c + k) / (k + 1);\\n        }\\n        if (ans > 0) {\\n            return ans;\\n        }\\n        k--;\\n    }\\n}\\n```\"", "sl_gold_code": "def minGroupsForValidAssignment(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    k = len(nums)\n    for c in cnt.values():\n        k = min(k, c)\n    while True:\n        ans = 0\n        for c in cnt.values():\n            if c // k < c % k:\n                ans = 0\n                break\n            ans += (c + k) // (k + 1)\n        if ans > 0:\n            return ans\n        k -= 1", "tl_gold_code": "public static int minGroupsForValidAssignment(int[] nums) {\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int x : nums) {\n        cnt.merge(x, 1, Integer::sum);\n    }\n    int k = nums.length;\n    for (int c : cnt.values()) {\n        k = Math.min(k, c);\n    }\n    for (; ; k--) {\n        int ans = 0;\n        for (int c : cnt.values()) {\n            if (c / k < c % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c + k) / (k + 1);\n        }\n        if (ans > 0) {\n            return ans;\n        }\n    }\n}"}
{"task": "python_java", "problem_id": 6, "prediction_id": 0, "pro_prediction": "public static int minimumSum(int[] nums) {\n    int n = nums.length;\n    int[] suf = new int[n];\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 0; i--) {\n        suf[i] = Math.min(suf[i + 1], nums[i]);\n    }\n    int ans = Integer.MAX_VALUE;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = Math.min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = Math.min(pre, nums[j]);\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n}", "main_fun_name": "minimumSum", "raw_prediction": "\"```java\\npublic int minimumSum(int[] nums) {\\n    int n = nums.length;\\n    int[] suf = new int[n];\\n    suf[n - 1] = nums[n - 1];\\n    for (int i = n - 2; i > 0; i--) {\\n        suf[i] = Math.min(suf[i + 1], nums[i]);\\n    }\\n    int ans = Integer.MAX_VALUE;\\n    int pre = nums[0];\\n    for (int j = 1; j < n - 1; j++) {\\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\\n            ans = Math.min(ans, pre + nums[j] + suf[j + 1]);\\n        }\\n        pre = Math.min(pre, nums[j]);\\n    }\\n    return ans == Integer.MAX_VALUE ? -1 : ans;\\n}\\n```\"", "sl_gold_code": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    suf = [0] * n\n    suf[-1] = nums[-1]\n    for i in range(n - 2, 1, -1):\n        suf[i] = min(suf[i + 1], nums[i])\n    ans = inf\n    pre = nums[0]\n    for j in range(1, n - 1):\n        if pre < nums[j] > suf[j + 1]:\n            ans = min(ans, pre + nums[j] + suf[j + 1])\n        pre = min(pre, nums[j])\n    return ans if ans < inf else -1", "tl_gold_code": "public static int minimumSum(int[] nums) {\n    int n = nums.length;\n    int[] suf = new int[n];\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = Math.min(suf[i + 1], nums[i]);\n    }\n    int ans = Integer.MAX_VALUE;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = Math.min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = Math.min(pre, nums[j]);\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n}"}
{"task": "python_java", "problem_id": 7, "prediction_id": 0, "pro_prediction": "public static int[][] constructProductMatrix(int[][] grid) {\n    int MOD = 12345;\n    int n = grid.length;\n    int m = grid[0].length;\n    int[][] p = new int[n][m];\n    int suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    int pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = p[i][j] * pre % MOD;\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}", "main_fun_name": "constructProductMatrix", "raw_prediction": "\"```java\\nint[][] constructProductMatrix(int[][] grid) {\\n    int MOD = 12345;\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int[][] p = new int[n][m];\\n    int suf = 1;\\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = m - 1; j >= 0; j--) {\\n            p[i][j] = suf;\\n            suf = suf * grid[i][j] % MOD;\\n        }\\n    }\\n    int pre = 1;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            p[i][j] = p[i][j] * pre % MOD;\\n            pre = pre * grid[i][j] % MOD;\\n        }\\n    }\\n    return p;\\n}\\n```\"", "sl_gold_code": "def constructProductMatrix(grid: List[List[int]]) -> List[List[int]]:\n    MOD = 12345\n    n, m = len(grid), len(grid[0])\n    p = [[0] * m for _ in range(n)]\n    suf = 1  \n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            p[i][j] = suf  \n            suf = suf * grid[i][j] % MOD\n    pre = 1  \n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            p[i][j] = p[i][j] * pre % MOD  \n            pre = pre * x % MOD\n    return p", "tl_gold_code": "public static int[][] constructProductMatrix(int[][] grid) {\n    final int MOD = 12345;\n    int n = grid.length, m = grid[0].length;\n    int[][] p = new int[n][m];\n    long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = (int) suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = (int) (p[i][j] * pre % MOD);\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}"}
{"task": "python_java", "problem_id": 8, "prediction_id": 0, "pro_prediction": "public static String maximumOddBinaryNumber(String s) {\n        int cnt1 = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '1') {\n                cnt1++;\n            }\n        }\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (i < cnt1 - 1 || s.charAt(i) == '1') {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n        return result.toString();\n    }", "main_fun_name": "maximumOddBinaryNumber", "raw_prediction": "\"```java\\npublic class Main {\\n    public static void main(String[] args) {\\n        System.out.println(maximumOddBinaryNumber(\\\"1100\\\")); // Output: \\\"1011\\\"\\n    }\\n\\n    public static String maximumOddBinaryNumber(String s) {\\n        int cnt1 = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == '1') {\\n                cnt1++;\\n            }\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < cnt1 - 1 || s.charAt(i) == '1') {\\n                result.append('1');\\n            } else {\\n                result.append('0');\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```\"", "sl_gold_code": "def maximumOddBinaryNumber(s: str) -> str:\n    cnt1 = s.count('1')\n    return '1' * (cnt1 - 1) + '0' * (len(s) - cnt1) + '1'", "tl_gold_code": "public static String maximumOddBinaryNumber(String s) {\n    int cnt1 = (int) s.chars().filter(c -> c == '1').count();\n    return \"1\".repeat(cnt1 - 1) + \"0\".repeat(s.length() - cnt1) + \"1\";\n}"}
{"task": "python_java", "problem_id": 9, "prediction_id": 0, "pro_prediction": "public static String shortestBeautifulSubstring(String s, int k) {\n    if (s.count('1') < k) {\n        return \"\";\n    }\n    String ans = s;\n    int cnt1 = 0;\n    int left = 0;\n    for (int right = 0; right < s.length(); right++) {\n        char c = s.charAt(right);\n        cnt1 += Character.getNumericValue(c);\n        while (cnt1 > k || s.charAt(left) == '0') {\n            cnt1 -= Character.getNumericValue(s.charAt(left));\n            left++;\n        }\n        if (cnt1 == k) {\n            String t = s.substring(left, right + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}", "main_fun_name": "shortestBeautifulSubstring", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\npublic String shortestBeautifulSubstring(String s, int k) {\\n    if (s.count('1') < k) {\\n        return \\\"\\\";\\n    }\\n    String ans = s;\\n    int cnt1 = 0;\\n    int left = 0;\\n    for (int right = 0; right < s.length(); right++) {\\n        char c = s.charAt(right);\\n        cnt1 += Character.getNumericValue(c);\\n        while (cnt1 > k || s.charAt(left) == '0') {\\n            cnt1 -= Character.getNumericValue(s.charAt(left));\\n            left++;\\n        }\\n        if (cnt1 == k) {\\n            String t = s.substring(left, right + 1);\\n            if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {\\n                ans = t;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    if s.count('1') < k:\n        return ''\n    ans = s\n    cnt1 = left = 0\n    for right, c in enumerate(s):\n        cnt1 += int(c)\n        while cnt1 > k or s[left] == '0':\n            cnt1 -= int(s[left])\n            left += 1\n        if cnt1 == k:\n            t = s[left: right + 1]\n            if len(t) < len(ans) or len(t) == len(ans) and t < ans:\n                ans = t\n    return ans", "tl_gold_code": "public static String shortestBeautifulSubstring(String S, int k) {\n    if (S.replace(\"0\", \"\").length() < k) {\n        return \"\";\n    }\n    char[] s = S.toCharArray();\n    String ans = S;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length; right++) {\n        cnt1 += s[right] - '0';\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= s[left++] - '0';\n        }\n        if (cnt1 == k) {\n            String t = S.substring(left, right + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 10, "prediction_id": 0, "pro_prediction": "public static int addMinimum(String s) {\n    int t = 1;\n    for (int i = 1; i < s.length(); i++) {\n        t += s.charAt(i - 1) >= s.charAt(i) ? 1 : 0;\n    }\n    return t * 3 - s.length();\n}", "main_fun_name": "addMinimum", "raw_prediction": "\"```java\\npublic int addMinimum(String s) {\\n    int t = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n        t += s.charAt(i - 1) >= s.charAt(i) ? 1 : 0;\\n    }\\n    return t * 3 - s.length();\\n}\\n```\"", "sl_gold_code": "def addMinimum(s):\n    t = 1\n    for i in range(1, len(s)):\n        t += s[i - 1] >= s[i]\n    return t * 3 - len(s)", "tl_gold_code": "public static int addMinimum(String word) {\n    var s = word.toCharArray();\n    int t = 1;\n    for (int i = 1; i < s.length; ++i)\n        if (s[i - 1] >= s[i])\n            ++t;\n    return t * 3 - s.length;\n}"}
{"task": "python_java", "problem_id": 11, "prediction_id": 0, "pro_prediction": "public static int maxIncreasingGroups(List<Integer> usageLimits) {\n        Integer[] ul = usageLimits.stream().sorted().toArray(Integer[]::new);\n        int remain = 0;\n        int require = 1;\n        for (Integer num : ul) {\n            remain += num;\n            if (remain >= require) {\n                remain -= require;\n                require++;\n            }\n        }\n        return require - 1;\n    }", "main_fun_name": "maxIncreasingGroups", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        List<Integer> usageLimits = Arrays.asList(1, 2, 3, 4, 5);\\n        System.out.println(maxIncreasingGroups(usageLimits)); // Output should be 5\\n    }\\n\\n    public static int maxIncreasingGroups(List<Integer> usageLimits) {\\n        Integer[] ul = usageLimits.stream().sorted().toArray(Integer[]::new);\\n        int remain = 0;\\n        int require = 1;\\n        for (Integer num : ul) {\\n            remain += num;\\n            if (remain >= require) {\\n                remain -= require;\\n                require++;\\n            }\\n        }\\n        return require - 1;\\n    }\\n}\\n```\"", "sl_gold_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    ul = sorted(usageLimits)\n    remain = 0\n    require = 1\n    for num in ul:\n        remain += num\n        if remain >= require:\n            remain -= require \n            require += 1 \n    return require - 1", "tl_gold_code": "public static int maxIncreasingGroups(List<Integer> usageLimits) {\n    Collections.sort(usageLimits);\n    long remain = 0;\n    int require = 1;\n    for (int num : usageLimits) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require++;\n        }\n    }\n    return require - 1;\n}"}
{"task": "python_java", "problem_id": 12, "prediction_id": 0, "pro_prediction": "public static List<Integer> lastVisitedIntegers(List<String> words) {\n    List<Integer> ans = new ArrayList<>();\n    List<Integer> nums = new ArrayList<>();\n    int k = 0;\n    for (String s : words) {\n        if (!s.startsWith(\"p\")) {\n            nums.add(Integer.parseInt(s));\n            k = 0;\n        } else {\n            k++;\n            ans.add(k > nums.size() ? -1 : nums.get(nums.size() - k));\n        }\n    }\n    return ans;\n}", "main_fun_name": "lastVisitedIntegers", "raw_prediction": "\"```java\\nimport java.util.List;\\n\\npublic List<Integer> lastVisitedIntegers(List<String> words) {\\n    List<Integer> ans = new ArrayList<>();\\n    List<Integer> nums = new ArrayList<>();\\n    int k = 0;\\n    for (String s : words) {\\n        if (!s.startsWith(\\\"p\\\")) {\\n            nums.add(Integer.parseInt(s));\\n            k = 0;\\n        } else {\\n            k++;\\n            ans.add(k > nums.size() ? -1 : nums.get(nums.size() - k));\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    k = 0\n    for s in words:\n        if s[0] != 'p':  \n            nums.append(int(s))\n            k = 0\n        else:\n            k += 1\n            ans.append(-1 if k > len(nums) else nums[-k])  \n    return ans", "tl_gold_code": "public static List<Integer> lastVisitedIntegers(List<String> words) {\n    List<Integer> ans = new ArrayList<>();\n    List<Integer> a = new ArrayList<>();\n    int k = 0;\n    for (String s : words) {\n        if (s.charAt(0) != 'p') { \n            a.add(Integer.parseInt(s));\n            k = 0;\n        } else {\n            ans.add(++k > a.size() ? -1 : a.get(a.size() - k)); \n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 13, "prediction_id": 0, "pro_prediction": "public static int minOperations(String s1, String s2, int x) {\n    if (s1.equals(s2)) {\n        return 0;\n    }\n    int[] p = new int[s1.length()];\n    int j = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            p[j++] = i;\n        }\n    }\n    if (j % 2 != 0) {\n        return -1;\n    }\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < j; i++) {\n        int new_f = Math.min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}", "main_fun_name": "minOperations", "raw_prediction": "\"```java\\npublic int minOperations(String s1, String s2, int x) {\\n    if (s1.equals(s2)) {\\n        return 0;\\n    }\\n    int[] p = new int[s1.length()];\\n    int j = 0;\\n    for (int i = 0; i < s1.length(); i++) {\\n        if (s1.charAt(i) != s2.charAt(i)) {\\n            p[j++] = i;\\n        }\\n    }\\n    if (j % 2 != 0) {\\n        return -1;\\n    }\\n    int f0 = 0, f1 = x;\\n    for (int i = 1; i < j; i++) {\\n        int new_f = Math.min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\\n        f0 = f1;\\n        f1 = new_f;\\n    }\\n    return f1 / 2;\\n}\\n```\"", "sl_gold_code": "def minOperations(s1, s2, x):\n    if s1 == s2:\n        return 0\n    p = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    if len(p) % 2:\n        return -1\n    f0, f1 = 0, x\n    for i in range(1, len(p)):\n        new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)\n        f0, f1 = f1, new_f\n    return f1 // 2", "tl_gold_code": "public static int minOperations(String s1, String s2, int x) {\n    if (s1.equals(s2)) {\n        return 0;\n    }\n    List<Integer> p = new ArrayList<>();\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            p.add(i);\n        }\n    }\n    if (p.size() % 2 != 0) {\n        return -1;\n    }\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int newF = Math.min(f1 + x, f0 + (p.get(i) - p.get(i - 1)) * 2);\n        f0 = f1;\n        f1 = newF;\n    }\n    return f1 / 2;\n}"}
{"task": "python_java", "problem_id": 14, "prediction_id": 0, "pro_prediction": "public static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\n        Arrays.sort(processorTime);\n        Arrays.sort(tasks, Collections.reverseOrder());\n        int maxTime = 0;\n        for (int i = 0; i < processorTime.size(); i++) {\n            maxTime = Math.max(maxTime, processorTime.get(i) + tasks.get(i));\n        }\n        return maxTime;\n    }", "main_fun_name": "minProcessingTime", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class ProcessorTimeCalculator {\\n\\n    public static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\\n        Arrays.sort(processorTime);\\n        Arrays.sort(tasks, Collections.reverseOrder());\\n        int maxTime = 0;\\n        for (int i = 0; i < processorTime.size(); i++) {\\n            maxTime = Math.max(maxTime, processorTime.get(i) + tasks.get(i));\\n        }\\n        return maxTime;\\n    }\\n\\n    public static void main(String[] args) {\\n        List<Integer> processorTime = Arrays.asList(1, 3, 2);\\n        List<Integer> tasks = Arrays.asList(4, 5, 6);\\n        System.out.println(minProcessingTime(processorTime, tasks)); // Output should be 7\\n    }\\n}\\n```\"", "sl_gold_code": "def minProcessingTime(processorTime: List[int], tasks: List[int]) -> int:\n        processorTime.sort()\n        tasks.sort(reverse=True)\n        return max(p + t for p, t in zip(processorTime, tasks[::4]))", "tl_gold_code": "public static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\n    Collections.sort(processorTime);\n    tasks.sort(Collections.reverseOrder());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4));\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 15, "prediction_id": 0, "pro_prediction": "public static int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - (n / m) * ((n / m) + 1) * m;\n}", "main_fun_name": "differenceOfSums", "raw_prediction": "\"```java\\npublic int differenceOfSums(int n, int m) {\\n    return n * (n + 1) / 2 - (n / m) * ((n / m) + 1) * m;\\n}\\n```\"", "sl_gold_code": "def differenceOfSums(n: int, m: int) -> int:\n        return n * (n + 1) // 2 - n // m * (n // m + 1) * m", "tl_gold_code": "public static int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}"}
{"task": "python_java", "problem_id": 16, "prediction_id": 0, "pro_prediction": "public static int minSizeSubarray(int[] nums, int target) {\n        int total = 0;\n        for (int num : nums) {\n            total += num;\n        }\n        int n = nums.length;\n        int ans = Integer.MAX_VALUE;\n        int left = 0, s = 0;\n        for (int right = 0; right < 2 * n; right++) {\n            s += nums[right % n];\n            while (s > target % total) {\n                s -= nums[left % n];\n                left++;\n            }\n            if (s == target % total) {\n                ans = Math.min(ans, right - left + 1);\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans + target / total * n;\n    }", "main_fun_name": "minSizeSubarray", "raw_prediction": "\"```java\\npublic class Solution {\\n    public int minSizeSubarray(int[] nums, int target) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int left = 0, s = 0;\\n        for (int right = 0; right < 2 * n; right++) {\\n            s += nums[right % n];\\n            while (s > target % total) {\\n                s -= nums[left % n];\\n                left++;\\n            }\\n            if (s == target % total) {\\n                ans = Math.min(ans, right - left + 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans + target / total * n;\\n    }\\n}\\n```\"", "sl_gold_code": "def minSizeSubarray(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    n = len(nums)\n    ans = inf\n    left = s = 0\n    for right in range(n * 2):\n        s += nums[right % n]\n        while s > target % total:\n            s -= nums[left % n]\n            left += 1\n        if s == target % total:\n            ans = min(ans, right - left + 1)\n    return ans + target // total * n if ans < inf else -1", "tl_gold_code": "public static int minSizeSubarray(int[] nums, int target) {\n    long total = 0;\n    for (int x : nums) total += x;\n    int n = nums.length;\n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = Math.min(ans, right - left + 1);\n        }\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans + (int) (target / total) * n;\n}"}
{"task": "python_java", "problem_id": 17, "prediction_id": 0, "pro_prediction": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] suf_max = new int[n + 1];\n    for (int i = n - 1; i > 0; i--) {\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int pre_max = 0;\n    for (int j = 0; j < n; j++) {\n        ans = Math.max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = Math.max(pre_max, nums[j]);\n    }\n    return ans;\n}", "main_fun_name": "maximumTripletValue", "raw_prediction": "\"```java\\npublic long maximumTripletValue(int[] nums) {\\n    int n = nums.length;\\n    int[] suf_max = new int[n + 1];\\n    for (int i = n - 1; i > 0; i--) {\\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\\n    }\\n    long ans = 0;\\n    int pre_max = 0;\\n    for (int j = 0; j < n; j++) {\\n        ans = Math.max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\\n        pre_max = Math.max(pre_max, nums[j]);\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans", "tl_gold_code": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] sufMax = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        sufMax[i] = Math.max(sufMax[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int preMax = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (preMax - nums[j]) * sufMax[j + 1]);\n        preMax = Math.max(preMax, nums[j]);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 18, "prediction_id": 0, "pro_prediction": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] suf_max = new int[n + 1];\n    for (int i = n - 1; i > 0; i--) {\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int pre_max = 0;\n    for (int j = 0; j < n; j++) {\n        ans = Math.max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = Math.max(pre_max, nums[j]);\n    }\n    return ans;\n}", "main_fun_name": "maximumTripletValue", "raw_prediction": "\"```java\\npublic long maximumTripletValue(int[] nums) {\\n    int n = nums.length;\\n    int[] suf_max = new int[n + 1];\\n    for (int i = n - 1; i > 0; i--) {\\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\\n    }\\n    long ans = 0;\\n    int pre_max = 0;\\n    for (int j = 0; j < n; j++) {\\n        ans = Math.max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\\n        pre_max = Math.max(pre_max, nums[j]);\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans", "tl_gold_code": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] sufMax = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        sufMax[i] = Math.max(sufMax[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int preMax = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (preMax - nums[j]) * sufMax[j + 1]);\n        preMax = Math.max(preMax, nums[j]);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 19, "prediction_id": 0, "pro_prediction": "public static int maxSubarrays(int[] nums) {\n    int ans = 0;\n    int a = -1;\n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++;\n            a = -1;\n        }\n    }\n    return Math.max(ans, 1);\n}", "main_fun_name": "maxSubarrays", "raw_prediction": "\"```java\\npublic int maxSubarrays(int[] nums) {\\n    int ans = 0;\\n    int a = -1;\\n    for (int x : nums) {\\n        a &= x;\\n        if (a == 0) {\\n            ans++;\\n            a = -1;\\n        }\\n    }\\n    return Math.max(ans, 1);\\n}\\n```\"", "sl_gold_code": "def maxSubarrays(nums: List[int]) -> int:\n    ans = 0\n    a = -1\n    for x in nums:\n        a &= x\n        if a == 0:\n            ans += 1 \n            a = -1\n    return max(ans, 1)", "tl_gold_code": "public static int maxSubarrays(int[] nums) {\n    int ans = 0;\n    int a = -1; \n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++; \n            a = -1;\n        }\n    }\n    return Math.max(ans, 1); \n}"}
{"task": "python_java", "problem_id": 20, "prediction_id": 0, "pro_prediction": "public static int minOperations(int[] nums) {\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int x : nums) {\n        cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n    }\n    int ans = 0;\n    for (int c : cnt.values()) {\n        if (c == 1) {\n            return -1;\n        }\n        ans += (c + 2) / 3;\n    }\n    return ans;\n}", "main_fun_name": "minOperations", "raw_prediction": "\"```java\\npublic int minOperations(int[] nums) {\\n    Map<Integer, Integer> cnt = new HashMap<>();\\n    for (int x : nums) {\\n        cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n    }\\n    int ans = 0;\\n    for (int c : cnt.values()) {\\n        if (c == 1) {\\n            return -1;\\n        }\\n        ans += (c + 2) / 3;\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def minOperations(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    ans = 0\n    for c in cnt.values():\n        if c == 1:\n            return -1\n        ans += (c + 2) // 3\n    return ans", "tl_gold_code": "public static int minOperations(int[] nums) {\n    var cnt = new HashMap<Integer, Integer>();\n    for (int x : nums) {\n        cnt.merge(x, 1, Integer::sum);\n    }\n    int ans = 0;\n    for (int c : cnt.values()) {\n        if (c == 1) {\n            return -1;\n        }\n        ans += (c + 2) / 3;\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 21, "prediction_id": 0, "pro_prediction": "public static int minOperations(List<Integer> nums, int k) {\n    int u = (2 << k) - 2;\n    int s = 0, n = nums.size();\n    for (int i = n - 1; i >= 0; i--) {\n        s |= 1 << nums.get(i);\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n    return 0;\n}", "main_fun_name": "minOperations", "raw_prediction": "\"```java\\npublic int minOperations(List<Integer> nums, int k) {\\n    int u = (2 << k) - 2;\\n    int s = 0, n = nums.size();\\n    for (int i = n - 1; i >= 0; i--) {\\n        s |= 1 << nums.get(i);\\n        if ((s & u) == u) {\\n            return n - i;\\n        }\\n    }\\n    return 0;\\n}\\n```\"", "sl_gold_code": "def minOperations(nums: List[int], k: int) -> int:\n    u = (2 << k) - 2  \n    s, n = 0, len(nums)\n    for i in range(n - 1, -1, -1):\n        s |= 1 << nums[i]\n        if (s & u) == u:\n            return n - i", "tl_gold_code": "public static int minOperations(List<Integer> nums, int k) {\n    int n = nums.size();\n    long u = (2L << k) - 2; \n    long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1L << nums.get(i);\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}"}
{"task": "python_java", "problem_id": 22, "prediction_id": 0, "pro_prediction": "public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n        int ans = 0;\n        int mx = Math.min(stock.get(0)) + budget;\n        for (List<Integer> com : composition) {\n            boolean check(int num) {\n                int money = 0;\n                for (int i = 0; i < stock.size(); i++) {\n                    if (stock.get(i) < com.get(i) * num) {\n                        money += (com.get(i) * num - stock.get(i)) * cost.get(i);\n                        if (money > budget) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n\n            int left = 0, right = mx + 1;\n            while (left + 1 < right) {\n                int mid = (left + right) / 2;\n                if (check(mid)) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n            ans = Math.max(ans, left);\n        }\n        return ans;\n    }\n\npublic static boolean check(int num) {\n                int money = 0;\n                for (int i = 0; i < stock.size(); i++) {\n                    if (stock.get(i) < com.get(i) * num) {\n                        money += (com.get(i) * num - stock.get(i)) * cost.get(i);\n                        if (money > budget) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }", "main_fun_name": "maxNumberOfAlloys", "raw_prediction": "\"```java\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\\n        int ans = 0;\\n        int mx = Math.min(stock.get(0)) + budget;\\n        for (List<Integer> com : composition) {\\n            boolean check(int num) {\\n                int money = 0;\\n                for (int i = 0; i < stock.size(); i++) {\\n                    if (stock.get(i) < com.get(i) * num) {\\n                        money += (com.get(i) * num - stock.get(i)) * cost.get(i);\\n                        if (money > budget) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n                return true;\\n            }\\n\\n            int left = 0, right = mx + 1;\\n            while (left + 1 < right) {\\n                int mid = (left + right) / 2;\\n                if (check(mid)) {\\n                    left = mid;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n            ans = Math.max(ans, left);\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def maxNumberOfAlloys(n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    ans = 0\n    mx = min(stock) + budget\n    for com in composition:\n        def check(num: int) -> int:\n            money = 0\n            for s, base, c in zip(stock, com, cost):\n                if s < base * num:\n                    money += (base * num - s) * c\n                    if money > budget:\n                        return False\n            return True\n        left, right = 0, mx + 1\n        while left + 1 < right:  \n            mid = (left + right) // 2\n            if check(mid):\n                left = mid\n            else:\n                right = mid\n        ans = max(ans, left)\n    return ans", "tl_gold_code": "public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n    int ans = 0;\n    int mx = Collections.min(stock) + budget;\n    for (var com : composition) {\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) { \n            int mid = (left + right) / 2;\n            boolean ok = true;\n            long money = 0;\n            for (int i = 0; i < n; ++i) {\n                if (stock.get(i) < (long) com.get(i) * mid) {\n                    money += ((long) com.get(i) * mid - stock.get(i)) * cost.get(i);\n                    if (money > budget) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            if (ok) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        ans = Math.max(ans, left);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 23, "prediction_id": 0, "pro_prediction": "public static int countWays(List<Integer> nums) {\n        nums.sort();\n        int n = nums.size();\n        int ans = nums.get(0) > 0 ? 1 : 0;\n        for (int i = 0; i < n - 1; ++i) {\n            if (nums.get(i) < i + 1 && i + 1 < nums.get(i + 1)) {\n                ++ans;\n            }\n        }\n        return ans + 1;\n    }", "main_fun_name": "countWays", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int countWays(List<Integer> nums) {\\n        nums.sort();\\n        int n = nums.size();\\n        int ans = nums.get(0) > 0 ? 1 : 0;\\n        for (int i = 0; i < n - 1; ++i) {\\n            if (nums.get(i) < i + 1 && i + 1 < nums.get(i + 1)) {\\n                ++ans;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```\"", "sl_gold_code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = nums[0] > 0  \n    for i, (x, y) in enumerate(pairwise(nums)):\n        if x < i + 1 < y:\n            ans += 1\n    return ans + 1", "tl_gold_code": "public static int countWays(List<Integer> nums) {\n    int[] a = nums.stream().mapToInt(i -> i).toArray();\n    Arrays.sort(a);\n    int n = a.length;\n    int ans = a[0] > 0 ? 1 : 0; \n    for (int i = 0; i < n - 1; i++) {\n        if (a[i] < i + 1 && i + 1 < a[i + 1]) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}"}
{"task": "python_java", "problem_id": 24, "prediction_id": 0, "pro_prediction": "public static int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (Integer.bitCount(i) == k) {\n            ans += nums.get(i);\n        }\n    }\n    return ans;\n}", "main_fun_name": "sumIndicesWithKSetBits", "raw_prediction": "\"```java\\npublic int sumIndicesWithKSetBits(List<Integer> nums, int k) {\\n    int ans = 0;\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (Integer.bitCount(i) == k) {\\n            ans += nums.get(i);\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def sumIndicesWithKSetBits(nums, k):\n    ans = 0\n    for i in range(len(nums)):\n        if bin(i).count('1') == k:\n            ans += nums[i]\n    return ans", "tl_gold_code": "public static int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (Integer.bitCount(i) == k) {\n            ans += nums.get(i);\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 25, "prediction_id": 0, "pro_prediction": "public static int countPairs(List<List<Integer>> coordinates, int k) {\n        int ans = 0;\n        Map<Integer, Map<Integer, Integer>> cnt = new HashMap<>();\n        for (List<Integer> coordinate : coordinates) {\n            int x = coordinate.get(0);\n            int y = coordinate.get(1);\n            for (int i = 0; i <= k; i++) {\n                int xorX = x ^ i;\n                int xorY = y ^ (k - i);\n                ans += cnt.getOrDefault(xorX, new HashMap<>()).getOrDefault(xorY, 0);\n            }\n            cnt.put(x, cnt.getOrDefault(x, new HashMap<>()).merge(y, 1));\n        }\n        return ans;\n    }", "main_fun_name": "countPairs", "raw_prediction": "\"```java\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class Main {\\n    public static int countPairs(List<List<Integer>> coordinates, int k) {\\n        int ans = 0;\\n        Map<Integer, Map<Integer, Integer>> cnt = new HashMap<>();\\n        for (List<Integer> coordinate : coordinates) {\\n            int x = coordinate.get(0);\\n            int y = coordinate.get(1);\\n            for (int i = 0; i <= k; i++) {\\n                int xorX = x ^ i;\\n                int xorY = y ^ (k - i);\\n                ans += cnt.getOrDefault(xorX, new HashMap<>()).getOrDefault(xorY, 0);\\n            }\\n            cnt.put(x, cnt.getOrDefault(x, new HashMap<>()).merge(y, 1));\\n        }\\n        return ans;\\n    }\\n\\n    public static void main(String[] args) {\\n        List<List<Integer>> coordinates = List.of(List.of(1, 1), List.of(2, 3), List.of(3, 4));\\n        int k = 2;\\n        System.out.println(countPairs(coordinates, k)); // Output: 5\\n    }\\n}\\n```\"", "sl_gold_code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    ans = 0\n    cnt = Counter()\n    for x, y in coordinates:\n        for i in range(k + 1):\n            ans += cnt[x ^ i, y ^ (k - i)]  \n        cnt[x, y] += 1  \n    return ans", "tl_gold_code": "public static int countPairs(List<List<Integer>> coordinates, int k) {\n    int ans = 0;\n    var cnt = new HashMap<Long, Integer>();\n    for (var p : coordinates) {\n        int x = p.get(0), y = p.get(1);\n        for (int i = 0; i <= k; i++) {\n            ans += cnt.getOrDefault((x ^ i) * 2000000L + (y ^ (k - i)), 0);\n        }\n        cnt.merge(x * 2000000L + y, 1, Integer::sum);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 26, "prediction_id": 0, "pro_prediction": "public static int minimumRightShifts(List<Integer> nums) {\n    int i = 1, n = nums.size();\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums.get(0) < nums.get(n - 1)) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}", "main_fun_name": "minimumRightShifts", "raw_prediction": "\"```java\\nimport java.util.List;\\n\\npublic int minimumRightShifts(List<Integer> nums) {\\n    int i = 1, n = nums.size();\\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\\n        i++;\\n    }\\n    if (i == n) {\\n        return 0;\\n    }\\n    if (nums.get(0) < nums.get(n - 1)) {\\n        return -1;\\n    }\\n    int mid = i;\\n    i++;\\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\\n        i++;\\n    }\\n    if (i < n) {\\n        return -1;\\n    }\\n    return n - mid;\\n}\\n```\"", "sl_gold_code": "def minimumRightShifts(nums: List[int]) -> int:\n    i, n = 1, len(nums)\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i == n:\n        return 0\n    if nums[0] < nums[-1]:\n        return -1\n    mid = i\n    i += 1\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i < n:\n        return -1\n    return n - mid", "tl_gold_code": "public static int minimumRightShifts(List<Integer> nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums.get(0) < nums.get(n - 1)) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}"}
{"task": "python_java", "problem_id": 27, "prediction_id": 0, "pro_prediction": "public static int minLengthAfterRemovals(List<Integer> nums) {\n    int maxCnt = 1;\n    int cnt = 1;\n    int pre = nums.get(0);\n    int n = nums.size();\n    for (int i = 1; i < n; i++) {\n        if (pre == nums.get(i)) {\n            cnt++;\n        } else {\n            maxCnt = Math.max(maxCnt, cnt);\n            pre = nums.get(i);\n            cnt = 1;\n        }\n    }\n    maxCnt = Math.max(maxCnt, cnt);\n    if (maxCnt * 2 > n) {\n        return maxCnt - (n - maxCnt);\n    } else {\n        return n % 2 == 0 ? 0 : 1;\n    }\n}", "main_fun_name": "minLengthAfterRemovals", "raw_prediction": "\"```java\\npublic int minLengthAfterRemovals(List<Integer> nums) {\\n    int maxCnt = 1;\\n    int cnt = 1;\\n    int pre = nums.get(0);\\n    int n = nums.size();\\n    for (int i = 1; i < n; i++) {\\n        if (pre == nums.get(i)) {\\n            cnt++;\\n        } else {\\n            maxCnt = Math.max(maxCnt, cnt);\\n            pre = nums.get(i);\\n            cnt = 1;\\n        }\\n    }\\n    maxCnt = Math.max(maxCnt, cnt);\\n    if (maxCnt * 2 > n) {\\n        return maxCnt - (n - maxCnt);\\n    } else {\\n        return n % 2 == 0 ? 0 : 1;\\n    }\\n}\\n```\"", "sl_gold_code": "def minLengthAfterRemovals(nums):\n    maxCnt = cnt = 1\n    pre = nums[0]\n    n = len(nums)\n    for i in range(1, n):\n        if pre == nums[i]:\n            cnt += 1\n        else:\n            maxCnt = max(maxCnt, cnt)\n            pre = nums[i]\n            cnt = 1\n    maxCnt = max(maxCnt, cnt)\n    if maxCnt * 2 > n:\n        return maxCnt - (n - maxCnt)\n    else:\n        return 0 if n % 2 == 0 else 1", "tl_gold_code": "public static int minLengthAfterRemovals(List<Integer> nums) {\n    int maxCnt = 0, cnt = 1;\n    int pre = nums.get(0);\n    int n = nums.size();\n    for(int i = 1; i < n; i++) {\n        if(pre == nums.get(i)) cnt++;\n        else {\n            maxCnt = Math.max(maxCnt, cnt);\n            pre = nums.get(i);\n            cnt = 1;\n        }\n    }\n    maxCnt = Math.max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}"}
{"task": "python_java", "problem_id": 28, "prediction_id": 0, "pro_prediction": "public static int numberOfPoints(List<List<Integer>> nums) {\n    int[] diff = new int[102];\n    for (List<Integer> p : nums) {\n        diff[p.get(0)]++;\n        diff[p.get(1) + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d : diff) {\n        s += d;\n        ans += s > 0 ? 1 : 0;\n    }\n    return ans;\n}", "main_fun_name": "numberOfPoints", "raw_prediction": "\"```java\\npublic int numberOfPoints(List<List<Integer>> nums) {\\n    int[] diff = new int[102];\\n    for (List<Integer> p : nums) {\\n        diff[p.get(0)]++;\\n        diff[p.get(1) + 1]--;\\n    }\\n    int ans = 0, s = 0;\\n    for (int d : diff) {\\n        s += d;\\n        ans += s > 0 ? 1 : 0;\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def numberOfPoints(nums):\n    diff = [0] * 102\n    for p in nums:\n        diff[p[0]] += 1\n        diff[p[1] + 1] -= 1\n    ans = s = 0\n    for d in diff:\n        s += d\n        ans += s > 0\n    return ans", "tl_gold_code": "public static int numberOfPoints(List<List<Integer>> nums) {\n    var diff = new int[102];\n    for (var p : nums) {\n        diff[p.get(0)]++;\n        diff[p.get(1) + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d : diff) {\n        s += d;\n        if (s > 0) {\n            ans++;\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 29, "prediction_id": 0, "pro_prediction": "public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy) {\n        return t != 1;\n    }\n    return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t;\n}", "main_fun_name": "isReachableAtTime", "raw_prediction": "\"```java\\nboolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\\n    if (sx == fx && sy == fy) {\\n        return t != 1;\\n    }\\n    return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t;\\n}\\n```\"", "sl_gold_code": "def isReachableAtTime(sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n    if sx == fx and sy == fy:\n        return t != 1\n    return max(abs(sx - fx), abs(sy - fy)) <= t", "tl_gold_code": "public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy) {\n        return t != 1;\n    }\n    return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t;\n}"}
{"task": "python_java", "problem_id": 30, "prediction_id": 0, "pro_prediction": "public static long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    long[] preSum = new long[n + 1];\n    for (int i = 0; i < n; i++) {\n        preSum[i + 1] = preSum[i] + (nums.get(i) % modulo == k ? 1 : 0);\n    }\n    Map<Long, Long> countMap = new HashMap<>();\n    for (int i = 0; i <= n; i++) {\n        long key = (preSum[i] % modulo - k + modulo) % modulo;\n        if (countMap.containsKey(key)) {\n            ans += countMap.get(key);\n        }\n        countMap.put(preSum[i] % modulo, countMap.getOrDefault(preSum[i] % modulo, 0) + 1);\n    }\n    return ans;\n}", "main_fun_name": "countInterestingSubarrays", "raw_prediction": "\"```java\\npublic long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\\n    int n = nums.size();\\n    long ans = 0;\\n    long[] preSum = new long[n + 1];\\n    for (int i = 0; i < n; i++) {\\n        preSum[i + 1] = preSum[i] + (nums.get(i) % modulo == k ? 1 : 0);\\n    }\\n    Map<Long, Long> countMap = new HashMap<>();\\n    for (int i = 0; i <= n; i++) {\\n        long key = (preSum[i] % modulo - k + modulo) % modulo;\\n        if (countMap.containsKey(key)) {\\n            ans += countMap.get(key);\\n        }\\n        countMap.put(preSum[i] % modulo, countMap.getOrDefault(preSum[i] % modulo, 0) + 1);\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def countInterestingSubarrays(nums, modulo, k):\n    n = len(nums)\n    ans = 0\n    preSum = [0] * (n + 1)\n    for i in range(n):\n        preSum[i+1] = preSum[i] + (1 if nums[i] % modulo == k else 0)\n    count_map = {}\n    for i in range(n + 1):\n        key = (preSum[i] % modulo - k + modulo) % modulo\n        if key in count_map:\n            ans += count_map[key]\n        count_map[preSum[i] % modulo] = count_map.get(preSum[i] % modulo, 0) + 1\n    return ans", "tl_gold_code": "public static long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    int[] preSum = new int[n+1];\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + (nums.get(i) % modulo == k?1:0);\n    Map<Integer,Integer> map = new HashMap<>();\n    for(int i=0;i<=n;i++){\n        if(map.containsKey((preSum[i]%modulo - k + modulo)%modulo))\n            ans += map.get((preSum[i]%modulo - k + modulo)%modulo);\n        map.put(preSum[i]%modulo,map.getOrDefault(preSum[i]%modulo,0)+1);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 31, "prediction_id": 0, "pro_prediction": "public static int minimumOperations(String num) {\n        int len_num = num.length();\n        int zero = len_num - 1;\n        if (num.contains(\"0\")) {\n            zero = len_num;\n        }\n        return Math.min(count(\"00\", num), count(\"25\", num), count(\"50\", num), count(\"75\", num), zero);\n    }\n\npublic static int count(String target, String num) {\n        int i = num.lastIndexOf(target.charAt(1));\n        if (i < 0) {\n            return num.length();\n        }\n        i = num.substring(0, i).lastIndexOf(target.charAt(0));\n        if (i < 0) {\n            return num.length();\n        }\n        return num.length() - i - 2;\n    }", "main_fun_name": "minimumOperations", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\npublic class Main {\\n    public static void main(String[] args) {\\n        System.out.println(minimumOperations(\\\"123456\\\")); // Example call\\n    }\\n\\n    public static int minimumOperations(String num) {\\n        int len_num = num.length();\\n        int zero = len_num - 1;\\n        if (num.contains(\\\"0\\\")) {\\n            zero = len_num;\\n        }\\n        return Math.min(count(\\\"00\\\", num), count(\\\"25\\\", num), count(\\\"50\\\", num), count(\\\"75\\\", num), zero);\\n    }\\n\\n    private static int count(String target, String num) {\\n        int i = num.lastIndexOf(target.charAt(1));\\n        if (i < 0) {\\n            return num.length();\\n        }\\n        i = num.substring(0, i).lastIndexOf(target.charAt(0));\\n        if (i < 0) {\\n            return num.length();\\n        }\\n        return num.length() - i - 2;\\n    }\\n}\\n```\"", "sl_gold_code": "def minimumOperations(num):\n    len_num = len(num)\n    zero = len_num - 1 if \"0\" in num else len_num\n    return min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero)\ndef f(target, num):\n    try:\n        i = num.rfind(target[1])\n        if i < 0:\n            return len(num)\n        i = num[:i].rfind(target[0])\n        if i < 0:\n            return len(num)\n        return len(num) - i - 2\n    except IndexError:\n        return len(num)", "tl_gold_code": "public static  int minimumOperations(String num) {\n    int len = num.length();\n    int zero = num.contains(\"0\")? len - 1: len;\n    return Math.min(f(\"00\", num),\n    Math.min( f(\"25\", num), Math.min(f(\"50\", num), Math.min(f(\"75\", num), zero))));\n}\npublic static  int f(String target, String num) {\n    int i = num.lastIndexOf(target.substring(1));\n    if (i < 0) return num.length();\n    i = num.substring(0, i).lastIndexOf(target.substring(0,1));\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}"}
{"task": "python_java", "problem_id": 32, "prediction_id": 0, "pro_prediction": "public static int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        String s = Integer.toString(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += Integer.parseInt(s.charAt(j));\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= Integer.parseInt(s.charAt(j));\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}", "main_fun_name": "countSymmetricIntegers", "raw_prediction": "\"```java\\npublic int countSymmetricIntegers(int low, int high) {\\n    int ans = 0;\\n    for (int i = low; i <= high; i++) {\\n        String s = Integer.toString(i);\\n        int n = s.length();\\n        if (n % 2 > 0) {\\n            continue;\\n        }\\n        int sum = 0;\\n        for (int j = 0; j < n / 2; j++) {\\n            sum += Integer.parseInt(s.charAt(j));\\n        }\\n        for (int j = n / 2; j < n; j++) {\\n            sum -= Integer.parseInt(s.charAt(j));\\n        }\\n        if (sum == 0) {\\n            ans++;\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def countSymmetricIntegers(low, high):\n    ans = 0\n    for i in range(low, high + 1):\n        s = str(i)\n        n = len(s)\n        if n % 2 > 0:\n            continue\n        sum = 0\n        for j in range(n // 2):\n            sum += int(s[j])\n        for j in range(n // 2, n):\n            sum -= int(s[j])\n        if sum == 0:\n            ans += 1\n    return ans", "tl_gold_code": "public static int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        char[] s = Integer.toString(i).toCharArray();\n        int n = s.length;\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s[j];\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s[j];\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 33, "prediction_id": 0, "pro_prediction": "public static long maxSum(List<Integer> nums, int m, int k) {\n    long ans = 0;\n    long s = 0;\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int i = 0; i < k - 1; i++) {\n        s += nums.get(i);\n        cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), 0) + 1);\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        int out = nums.get(i);\n        int in = nums.get(i + k - 1);\n        s += in;\n        cnt.put(in, cnt.getOrDefault(in, 0) + 1);\n        if (cnt.size() >= m) {\n            ans = Math.max(ans, s);\n        }\n        s -= out;\n        cnt.put(out, cnt.getOrDefault(out, 0) - 1);\n        if (cnt.get(out) == 0) {\n            cnt.remove(out);\n        }\n    }\n    return ans;\n}", "main_fun_name": "maxSum", "raw_prediction": "\"```java\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic long maxSum(List<Integer> nums, int m, int k) {\\n    long ans = 0;\\n    long s = 0;\\n    Map<Integer, Integer> cnt = new HashMap<>();\\n    for (int i = 0; i < k - 1; i++) {\\n        s += nums.get(i);\\n        cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), 0) + 1);\\n    }\\n    for (int i = 0; i < nums.size(); i++) {\\n        int out = nums.get(i);\\n        int in = nums.get(i + k - 1);\\n        s += in;\\n        cnt.put(in, cnt.getOrDefault(in, 0) + 1);\\n        if (cnt.size() >= m) {\\n            ans = Math.max(ans, s);\\n        }\\n        s -= out;\\n        cnt.put(out, cnt.getOrDefault(out, 0) - 1);\\n        if (cnt.get(out) == 0) {\\n            cnt.remove(out);\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    s = sum(nums[:k - 1])  \n    cnt = Counter(nums[:k - 1])\n    for out, in_ in zip(nums, nums[k - 1:]):\n        s += in_  \n        cnt[in_] += 1\n        if len(cnt) >= m:\n            ans = max(ans, s)\n        s -= out  \n        cnt[out] -= 1\n        if cnt[out] == 0:\n            del cnt[out]\n    return ans", "tl_gold_code": "public static long maxSum(List<Integer> nums, int m, int k) {\n    var a = nums.stream().mapToInt(i -> i).toArray();\n    long ans = 0, sum = 0;\n    var cnt = new HashMap<Integer, Integer>();\n    for (int i = 0; i < k - 1; i++) { \n        sum += a[i];\n        cnt.merge(a[i], 1, Integer::sum);\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += a[i]; \n        cnt.merge(a[i], 1, Integer::sum);\n        if (cnt.size() >= m)\n            ans = Math.max(ans, sum);\n        int out = a[i - k + 1];\n        sum -= out; \n        if (cnt.merge(out, -1, Integer::sum) == 0)\n            cnt.remove(out);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 34, "prediction_id": 0, "pro_prediction": "public static boolean checkStrings(String s1, String s2) {\n    int[][] cnt1 = new int[2][26];\n    int[][] cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][Character.getNumericValue(s1.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\n        cnt2[i % 2][Character.getNumericValue(s2.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\n    }\n    return java.util.Arrays.deepEquals(cnt1, cnt2);\n}", "main_fun_name": "checkStrings", "raw_prediction": "\"```java\\nboolean checkStrings(String s1, String s2) {\\n    int[][] cnt1 = new int[2][26];\\n    int[][] cnt2 = new int[2][26];\\n    for (int i = 0; i < s1.length(); i++) {\\n        cnt1[i % 2][Character.getNumericValue(s1.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\\n        cnt2[i % 2][Character.getNumericValue(s2.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\\n    }\\n    return java.util.Arrays.deepEquals(cnt1, cnt2);\\n}\\n```\"", "sl_gold_code": "def checkStrings(s1, s2):\n    cnt1 = [[0] * 26, [0] * 26]\n    cnt2 = [[0] * 26, [0] * 26]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2", "tl_gold_code": "public static boolean checkStrings(String s1, String s2) {\n    var cnt1 = new int[2][26];\n    var cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}"}
{"task": "python_java", "problem_id": 35, "prediction_id": 0, "pro_prediction": "public static boolean canBeEqual(String s1, String s2) {\n    int[][] cnt1 = new int[2][26];\n    int[][] cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][Character.getNumericValue(s1.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\n        cnt2[i % 2][Character.getNumericValue(s2.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\n    }\n    return java.util.Arrays.deepEquals(cnt1, cnt2);\n}", "main_fun_name": "canBeEqual", "raw_prediction": "\"```java\\nboolean canBeEqual(String s1, String s2) {\\n    int[][] cnt1 = new int[2][26];\\n    int[][] cnt2 = new int[2][26];\\n    for (int i = 0; i < s1.length(); i++) {\\n        cnt1[i % 2][Character.getNumericValue(s1.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\\n        cnt2[i % 2][Character.getNumericValue(s2.charAt(i)) - Character.getNumericValue('a') + 1] += 1;\\n    }\\n    return java.util.Arrays.deepEquals(cnt1, cnt2);\\n}\\n```\"", "sl_gold_code": "def canBeEqual(s1, s2):\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2", "tl_gold_code": "public static boolean canBeEqual(String s1, String s2) {\n    var cnt1 = new int[2][26];\n    var cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}"}
{"task": "python_java", "problem_id": 36, "prediction_id": 0, "pro_prediction": "public static int furthestDistanceFromOrigin(String moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        char move = moves.charAt(i);\n        if (move == 'L') {\n            ans -= 1;\n        } else if (move == 'R') {\n            ans += 1;\n        } else {\n            cn += 1;\n        }\n    }\n    return Math.abs(ans) + cn;\n}", "main_fun_name": "furthestDistanceFromOrigin", "raw_prediction": "\"```java\\npublic int furthestDistanceFromOrigin(String moves) {\\n    int cn = 0;\\n    int ans = 0;\\n    for (int i = 0; i < moves.length(); i++) {\\n        char move = moves.charAt(i);\\n        if (move == 'L') {\\n            ans -= 1;\\n        } else if (move == 'R') {\\n            ans += 1;\\n        } else {\\n            cn += 1;\\n        }\\n    }\\n    return Math.abs(ans) + cn;\\n}\\n```\"", "sl_gold_code": "def furthestDistanceFromOrigin(moves):\n    cn = 0\n    ans = 0\n    for i in range(len(moves)):\n        if moves[i] == 'L':\n            ans -= 1\n        elif moves[i] == 'R':\n            ans += 1\n        else:\n            cn += 1\n    return abs(ans) + cn", "tl_gold_code": "public static int furthestDistanceFromOrigin(String moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves.charAt(i) == 'L') {\n            ans--;\n        } else if (moves.charAt(i) == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return Math.abs(ans) + cn;\n}"}
{"task": "python_java", "problem_id": 37, "prediction_id": 0, "pro_prediction": "public static int longestEqualSubarray(int[] nums, int k) {\n        Map<Integer, List<Integer>> pos = new HashMap<>();\n        for (int i = 0; i <= nums.length; i++) {\n            pos.putIfAbsent(i, new ArrayList<>());\n        }\n        for (int i = 0; i < nums.length; i++) {\n            pos.get(nums[i]).add(i - pos.get(nums[i]).size());\n        }\n        int ans = 0;\n        for (List<Integer> ps : pos.values()) {\n            if (ps.size() <= ans) {\n                continue;\n            }\n            int left = 0;\n            for (int right = 0; right < ps.size(); right++) {\n                while (ps.get(right) - ps.get(left) > k) {\n                    left++;\n                }\n                ans = Math.max(ans, right - left + 1);\n            }\n        }\n        return ans;\n    }", "main_fun_name": "longestEqualSubarray", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public int longestEqualSubarray(int[] nums, int k) {\\n        Map<Integer, List<Integer>> pos = new HashMap<>();\\n        for (int i = 0; i <= nums.length; i++) {\\n            pos.putIfAbsent(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            pos.get(nums[i]).add(i - pos.get(nums[i]).size());\\n        }\\n        int ans = 0;\\n        for (List<Integer> ps : pos.values()) {\\n            if (ps.size() <= ans) {\\n                continue;\\n            }\\n            int left = 0;\\n            for (int right = 0; right < ps.size(); right++) {\\n                while (ps.get(right) - ps.get(left) > k) {\\n                    left++;\\n                }\\n                ans = Math.max(ans, right - left + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    pos = [[] for _ in range(len(nums) + 1)]\n    for i, x in enumerate(nums):\n        pos[x].append(i - len(pos[x]))\n    ans = 0\n    for ps in pos:\n        if len(ps) <= ans: continue\n        left = 0\n        for right, p in enumerate(ps):\n            while p - ps[left] > k:  \n                left += 1\n            ans = max(ans, right - left + 1)\n    return ans", "tl_gold_code": "public static int longestEqualSubarray(List<Integer> nums, int k) {\n    int n = nums.size(), ans = 0;\n    List<Integer>[] pos = new ArrayList[n + 1];\n    Arrays.setAll(pos, e -> new ArrayList<>());\n    for (int i = 0; i < n; i++) {\n        int x = nums.get(i);\n        pos[x].add(i - pos[x].size());\n    }\n    for (var ps : pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps.get(right) - ps.get(left) > k) \n                left++;\n            ans = Math.max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 38, "prediction_id": 0, "pro_prediction": "public static boolean isAcronym(List<String> words, String s) {\n    if (words.size() != s.length()) {\n        return false;\n    }\n    for (int i = 0; i < words.size(); i++) {\n        if (!words.get(i).startsWith(s.charAt(i) + \"\")) {\n            return false;\n        }\n    }\n    return true;\n}", "main_fun_name": "isAcronym", "raw_prediction": "\"```java\\nboolean isAcronym(List<String> words, String s) {\\n    if (words.size() != s.length()) {\\n        return false;\\n    }\\n    for (int i = 0; i < words.size(); i++) {\\n        if (!words.get(i).startsWith(s.charAt(i) + \\\"\\\")) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\"", "sl_gold_code": "def isAcronym(words, s):\n    if len(words) != len(s):\n        return False\n    for i in range(len(words)):\n        if words[i][0] != s[i]:\n            return False\n    return True", "tl_gold_code": "public static boolean isAcronym(List<String> words, String s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words.get(i).charAt(0) != s.charAt(i))\n            return false;\n    return true;\n}"}
{"task": "python_java", "problem_id": 39, "prediction_id": 0, "pro_prediction": "public static int minimumSum(int n, int k) {\n    int m = Math.min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}", "main_fun_name": "minimumSum", "raw_prediction": "\"```java\\npublic int minimumSum(int n, int k) {\\n    int m = Math.min(k / 2, n);\\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\\n}\\n```\"", "sl_gold_code": "def minimumSum(n: int, k: int) -> int:\n        m = min(k // 2, n)\n        return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2", "tl_gold_code": "public static int minimumSum(int n, int k) {\n    int m = Math.min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}"}
{"task": "python_java", "problem_id": 40, "prediction_id": 0, "pro_prediction": "public static int minimumOperations(List<Integer> nums) {\n        List<Integer> g = new ArrayList<>();\n        for (int x : nums) {\n            int j = upperBound(g, x);\n            if (j == g.size()) {\n                g.add(x);\n            } else {\n                g.set(j, x);\n            }\n        }\n        return nums.size() - g.size();\n    }\n\npublic static int upperBound(List<Integer> g, int target) {\n        int left = -1, right = g.size();\n        while (left + 1 < right) {\n            int mid = left + (right - left) / 2;\n            if (g.get(mid) <= target) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return right;\n    }", "main_fun_name": "minimumOperations", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int minimumOperations(List<Integer> nums) {\\n        List<Integer> g = new ArrayList<>();\\n        for (int x : nums) {\\n            int j = upperBound(g, x);\\n            if (j == g.size()) {\\n                g.add(x);\\n            } else {\\n                g.set(j, x);\\n            }\\n        }\\n        return nums.size() - g.size();\\n    }\\n\\n    private int upperBound(List<Integer> g, int target) {\\n        int left = -1, right = g.size();\\n        while (left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            if (g.get(mid) <= target) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```\"", "sl_gold_code": "def minimumOperations(nums):\n    g = []\n    for x in nums:\n        j = upper_bound(g, x)\n        if j == len(g):\n            g.append(x)\n        else:\n            g[j] = x\n    return len(nums) - len(g)\ndef upper_bound(g, target):\n    left, right = -1, len(g)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if g[mid] <= target:\n            left = mid\n        else:\n            right = mid\n    return right", "tl_gold_code": "public static int minimumOperations(List<Integer> nums) {\n    List<Integer> g = new ArrayList<>();\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.add(x);\n        else g.set(j, x);\n    }\n    return nums.size() - g.size();\n}\npublic static int upperBound(List<Integer> g, int target) {\n    int left = -1, right = g.size();\n    while (left + 1 < right) {\n        int mid = (left + right) >>> 1;\n        if (g.get(mid) <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}"}
{"task": "python_java", "problem_id": 41, "prediction_id": 0, "pro_prediction": "public static int countPairs(List<Integer> nums, int target) {\n        Arrays.sort(nums);\n        int ans = 0, left = 0, right = nums.size() - 1;\n        while (left < right) {\n            if (nums.get(left) + nums.get(right) < target) {\n                ans += right - left;\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return ans;\n    }", "main_fun_name": "countPairs", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int countPairs(List<Integer> nums, int target) {\\n        Arrays.sort(nums);\\n        int ans = 0, left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            if (nums.get(left) + nums.get(right) < target) {\\n                ans += right - left;\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def countPairs(nums: List[int], target: int) -> int:\n    nums.sort()\n    ans = left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            ans += right - left\n            left += 1\n        else:\n            right -= 1\n    return ans", "tl_gold_code": "public static int countPairs(List<Integer> nums, int target) {\n    Collections.sort(nums);\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums.get(left) + nums.get(right) < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 42, "prediction_id": 0, "pro_prediction": "public static int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE;\n        Integer[] pre = {Integer.MAX_VALUE};\n        for (int i = 0; i < nums.size() - x; i++) {\n            int index = Collections.binarySearch(pre, nums.get(i));\n            if (index < 0) {\n                index = ~index;\n            }\n            if (index == pre.length) {\n                pre[index] = nums.get(i);\n            } else {\n                pre[index] = nums.get(i);\n                while (index < pre.length - 1 && pre[index + 1] < pre[index]) {\n                    Integer temp = pre[index];\n                    pre[index] = pre[index + 1];\n                    pre[index + 1] = temp;\n                    index++;\n                }\n            }\n            int tmp = Math.min(Math.abs(pre[index] - nums.get(i + x)), Math.abs(pre[index - 1] - nums.get(i + x)));\n            ans = Math.min(ans, tmp);\n        }\n        return ans;\n    }", "main_fun_name": "minAbsoluteDifference", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\\n        int ans = Integer.MAX_VALUE;\\n        Integer[] pre = {Integer.MAX_VALUE};\\n        for (int i = 0; i < nums.size() - x; i++) {\\n            int index = Collections.binarySearch(pre, nums.get(i));\\n            if (index < 0) {\\n                index = ~index;\\n            }\\n            if (index == pre.length) {\\n                pre[index] = nums.get(i);\\n            } else {\\n                pre[index] = nums.get(i);\\n                while (index < pre.length - 1 && pre[index + 1] < pre[index]) {\\n                    Integer temp = pre[index];\\n                    pre[index] = pre[index + 1];\\n                    pre[index + 1] = temp;\\n                    index++;\\n                }\\n            }\\n            int tmp = Math.min(Math.abs(pre[index] - nums.get(i + x)), Math.abs(pre[index - 1] - nums.get(i + x)));\\n            ans = Math.min(ans, tmp);\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    ans = float('inf') \n    pre = [float('inf')] \n    for i in range(len(nums)-x):\n        insort_left(pre, nums[i]) \n        index = bisect_left(pre, nums[i+x])\n        tmp = min(abs(pre[index]-nums[i+x]) for index in (index, index-1))\n        ans = min(ans, tmp)\n    return ans", "tl_gold_code": "public static int minAbsoluteDifference(List<Integer> nums, int x) {\n    var a = nums.stream().mapToInt(i -> i).toArray();\n    int ans = Integer.MAX_VALUE, n = a.length;\n    var s = new TreeSet<Integer>();\n    s.add(Integer.MAX_VALUE); \n    s.add(Integer.MIN_VALUE / 2);\n    for (int i = x; i < n; i++) {\n        s.add(a[i - x]);\n        int y = a[i];\n        ans = Math.min(ans, Math.min(s.ceiling(y) - y, y - s.floor(y)));\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 43, "prediction_id": 0, "pro_prediction": "public static ListNode doubleIt(ListNode head) {\n        if (head.val > 4) {\n            head = new ListNode(0, head);\n        }\n        ListNode cur = head;\n        while (cur != null) {\n            cur.val = cur.val * 2 % 10;\n            if (cur.next != null && cur.next.val > 4) {\n                cur.val += 1;\n            }\n            cur = cur.next;\n        }\n        return head;\n    }", "main_fun_name": "doubleIt", "raw_prediction": "\"```java\\npublic class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class Solution {\\n    public ListNode doubleIt(ListNode head) {\\n        if (head.val > 4) {\\n            head = new ListNode(0, head);\\n        }\\n        ListNode cur = head;\\n        while (cur != null) {\\n            cur.val = cur.val * 2 % 10;\\n            if (cur.next != null && cur.next.val > 4) {\\n                cur.val += 1;\\n            }\\n            cur = cur.next;\\n        }\\n        return head;\\n    }\\n}\\n```\"", "sl_gold_code": "def doubleIt(head: Optional[ListNode]) -> Optional[ListNode]:\n    if head.val > 4:\n        head = ListNode(0, head)\n    cur = head\n    while cur:\n        cur.val = cur.val * 2 % 10\n        if cur.next and cur.next.val > 4:\n            cur.val += 1\n        cur = cur.next\n    return head", "tl_gold_code": "public static ListNode doubleIt(ListNode head) {\n    if (head.val > 4)\n        head = new ListNode(0, head);\n    for (var cur = head; cur != null; cur = cur.next) {\n        cur.val = cur.val * 2 % 10;\n        if (cur.next != null && cur.next.val > 4)\n            cur.val++;\n    }\n    return head;\n}"}
{"task": "python_java", "problem_id": 44, "prediction_id": 0, "pro_prediction": "public static int maxSum(int[] nums) {\n    int ans = -1;\n    int[] max_val = new int[10];\n    for (int v : nums) {\n        int max_d = 0;\n        for (char c : String.valueOf(v).toCharArray()) {\n            max_d = Math.max(max_d, Character.getNumericValue(c));\n        }\n        ans = Math.max(ans, v + max_val[max_d]);\n        max_val[max_d] = Math.max(max_val[max_d], v);\n    }\n    return ans;\n}", "main_fun_name": "maxSum", "raw_prediction": "\"```java\\npublic int maxSum(int[] nums) {\\n    int ans = -1;\\n    int[] max_val = new int[10];\\n    for (int v : nums) {\\n        int max_d = 0;\\n        for (char c : String.valueOf(v).toCharArray()) {\\n            max_d = Math.max(max_d, Character.getNumericValue(c));\\n        }\\n        ans = Math.max(ans, v + max_val[max_d]);\\n        max_val[max_d] = Math.max(max_val[max_d], v);\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    max_val = [-inf] * 10\n    for v in nums:\n        max_d = max(map(int, str(v)))\n        ans = max(ans, v + max_val[max_d])\n        max_val[max_d] = max(max_val[max_d], v)\n    return ans", "tl_gold_code": "public static int maxSum(int[] nums) {\n    int ans = -1;\n    var maxVal = new int[10];\n    Arrays.fill(maxVal, Integer.MIN_VALUE);\n    for (int v : nums) {\n        int maxD = 0;\n        for (int x = v; x > 0; x /= 10)\n            maxD = Math.max(maxD, x % 10);\n        ans = Math.max(ans, v + maxVal[maxD]);\n        maxVal[maxD] = Math.max(maxVal[maxD], v);\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 45, "prediction_id": 0, "pro_prediction": "public static String finalString(String s) {\n        Deque<Character> q = new ArrayDeque<>();\n        boolean tail = true;\n        for (char c : s.toCharArray()) {\n            if (c == 'i') {\n                tail = !tail;\n            } else if (tail) {\n                q.add(c);\n            } else {\n                q.addFirst(c);\n            }\n        }\n        return tail ? new String(q.toArray(new Character[0])) : new String(q.toArray(new Character[0]).reverse());\n    }", "main_fun_name": "finalString", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\nimport java.util.ArrayDeque;\\nimport java.util.Deque;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        System.out.println(finalString(\\\"hello world!\\\"));\\n    }\\n\\n    public static String finalString(String s) {\\n        Deque<Character> q = new ArrayDeque<>();\\n        boolean tail = true;\\n        for (char c : s.toCharArray()) {\\n            if (c == 'i') {\\n                tail = !tail;\\n            } else if (tail) {\\n                q.add(c);\\n            } else {\\n                q.addFirst(c);\\n            }\\n        }\\n        return tail ? new String(q.toArray(new Character[0])) : new String(q.toArray(new Character[0]).reverse());\\n    }\\n}\\n```\"", "sl_gold_code": "def finalString(s: str) -> str:\n    q = deque()\n    tail = True\n    for c in s:\n        if c == 'i':\n            tail = not tail  \n        elif tail:  \n            q.append(c)\n        else:  \n            q.appendleft(c)\n    return ''.join(q if tail else reversed(q))", "tl_gold_code": "public static String finalString(String s) {\n    var q = new ArrayDeque<Character>();\n    var tail = true;\n    for (var c : s.toCharArray()) {\n        if (c == 'i') tail = !tail;\n        else if (tail) q.addLast(c);\n        else q.addFirst(c);\n    }\n    var ans = new StringBuilder();\n    for (var c : q) ans.append(c);\n    if (!tail) ans.reverse();\n    return ans.toString();\n}"}
{"task": "python_java", "problem_id": 46, "prediction_id": 0, "pro_prediction": "public static boolean canSplitArray(List<Integer> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) {\n        return true;\n    }\n    for (int i = 1; i < n; i++) {\n        if (nums.get(i - 1) + nums.get(i) >= m) {\n            return true;\n        }\n    }\n    return false;\n}", "main_fun_name": "canSplitArray", "raw_prediction": "\"```java\\nboolean canSplitArray(List<Integer> nums, int m) {\\n    int n = nums.size();\\n    if (n <= 2) {\\n        return true;\\n    }\\n    for (int i = 1; i < n; i++) {\\n        if (nums.get(i - 1) + nums.get(i) >= m) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\"", "sl_gold_code": "def canSplitArray(nums, m):\n    n = len(nums)\n    if n <= 2: \n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False", "tl_gold_code": "public static boolean canSplitArray(List<Integer> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums.get(i - 1) + nums.get(i) >= m)\n            return true;\n    return false;\n}"}
{"task": "python_java", "problem_id": 47, "prediction_id": 0, "pro_prediction": "public static int longestAlternatingSubarray(int[] a, int threshold) {\n        int ans = 0, i = 0, n = a.length;\n        while (i < n) {\n            if (a[i] % 2 != 0 || a[i] > threshold) {\n                i++;\n            } else {\n                int i0 = i;\n                i++;\n                while (i < n && a[i] <= threshold && (a[i] % 2 != a[i - 1] % 2)) {\n                    i++;\n                }\n                ans = Math.max(ans, i - i0);\n            }\n        }\n        return ans;\n    }", "main_fun_name": "longestAlternatingSubarray", "raw_prediction": "\"```java\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] a = {1, 2, 3, 4, 5};\\n        int threshold = 3;\\n        System.out.println(longestAlternatingSubarray(a, threshold)); // Output: 3\\n    }\\n\\n    public static int longestAlternatingSubarray(int[] a, int threshold) {\\n        int ans = 0, i = 0, n = a.length;\\n        while (i < n) {\\n            if (a[i] % 2 != 0 || a[i] > threshold) {\\n                i++;\\n            } else {\\n                int i0 = i;\\n                i++;\\n                while (i < n && a[i] <= threshold && (a[i] % 2 != a[i - 1] % 2)) {\\n                    i++;\\n                }\\n                ans = Math.max(ans, i - i0);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def longestAlternatingSubarray(a: List[int], threshold: int) -> int:\n    ans, i, n = 0, 0, len(a)\n    while i < n:\n        if a[i] % 2 or a[i] > threshold:\n            i += 1\n        else:\n            i0 = i\n            i += 1\n            while i < n and a[i] <= threshold and a[i] % 2 != a[i - 1] % 2:\n                i += 1 \n            ans = max(ans, i - i0)\n    return ans", "tl_gold_code": "public static int longestAlternatingSubarray(int[] a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.length;\n    while (i < n) {\n        if (a[i] % 2 != 0 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = Math.max(ans, i - i0);\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 48, "prediction_id": 0, "pro_prediction": "public static int minimumSeconds(List<Integer> nums) {\n        Map<Integer, List<Integer>> pos = new HashMap<>();\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            pos.computeIfAbsent(nums.get(i), v -> new ArrayList<>()).add(i);\n        }\n        int ans = n;\n        for (List<Integer> a : pos.values()) {\n            a.add(a.get(0) + n);\n            int mx = 0;\n            for (int i = 0; i < a.size() - 1; i++) {\n                mx = Math.max(mx, (a.get(i + 1) - a.get(i)) / 2);\n            }\n            ans = Math.min(ans, mx);\n        }\n        return ans;\n    }", "main_fun_name": "minimumSeconds", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public int minimumSeconds(List<Integer> nums) {\\n        Map<Integer, List<Integer>> pos = new HashMap<>();\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            pos.computeIfAbsent(nums.get(i), v -> new ArrayList<>()).add(i);\\n        }\\n        int ans = n;\\n        for (List<Integer> a : pos.values()) {\\n            a.add(a.get(0) + n);\\n            int mx = 0;\\n            for (int i = 0; i < a.size() - 1; i++) {\\n                mx = Math.max(mx, (a.get(i + 1) - a.get(i)) / 2);\\n            }\\n            ans = Math.min(ans, mx);\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def minimumSeconds(nums: List[int]) -> int:\n    pos = defaultdict(list)\n    for i, x in enumerate(nums):\n        pos[x].append(i)\n    ans = n = len(nums)\n    for a in pos.values():\n        a.append(a[0] + n)\n        mx = max((j - i) // 2 for i, j in pairwise(a))\n        ans = min(ans, mx)\n    return ans", "tl_gold_code": "public static int minimumSeconds(List<Integer> nums) {\n    int n = nums.size();\n    Map<Integer, List<Integer>> map = new HashMap<>(); \n    for(int i = 0; i < nums.size(); i++){\n        if(!map.containsKey(nums.get(i))) map.put(nums.get(i), new ArrayList<>());\n        map.get(nums.get(i)).add(i);\n    }\n    int ans = n / 2;\n    for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){\n        List<Integer> list = entry.getValue();\n        list.add(list.get(0) + n);\n        int mx = -1;\n        for(int j = 1; j < list.size(); j++){\n            mx = Math.max(mx, (list.get(j) - list.get(j-1)) / 2);\n        }\n        ans = Math.min(ans, mx);\n    }   \n    return ans;\n}"}
{"task": "python_java", "problem_id": 49, "prediction_id": 0, "pro_prediction": "public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        if (h >= target) {\n            ans++;\n        }\n    }\n    return ans;\n}", "main_fun_name": "numberOfEmployeesWhoMetTarget", "raw_prediction": "\"```java\\nint numberOfEmployeesWhoMetTarget(int[] hours, int target) {\\n    int ans = 0;\\n    for (int h : hours) {\\n        if (h >= target) {\\n            ans++;\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n        ans = 0\n        for h in hours:\n                if h >= target:\n                        ans += 1\n        return ans", "tl_gold_code": "public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        if (h >= target) {\n            ans++;\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 50, "prediction_id": 0, "pro_prediction": "public static List<String> splitWordsBySeparator(List<String> words, char separator) {\n        List<String> ans = new ArrayList<>();\n        for (String word : words) {\n            StringBuilder sb = new StringBuilder();\n            for (char i : word.toCharArray()) {\n                if (i == ' ') {\n                    continue;\n                }\n                if (i == separator) {\n                    if (sb.length() > 0) {\n                        ans.add(sb.toString());\n                    }\n                    sb.setLength(0);\n                } else {\n                    sb.append(i);\n                }\n            }\n            if (sb.length() > 0) {\n                ans.add(sb.toString());\n            }\n        }\n        return ans;\n    }", "main_fun_name": "splitWordsBySeparator", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class WordSplitter {\\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\\n        List<String> ans = new ArrayList<>();\\n        for (String word : words) {\\n            StringBuilder sb = new StringBuilder();\\n            for (char i : word.toCharArray()) {\\n                if (i == ' ') {\\n                    continue;\\n                }\\n                if (i == separator) {\\n                    if (sb.length() > 0) {\\n                        ans.add(sb.toString());\\n                    }\\n                    sb.setLength(0);\\n                } else {\\n                    sb.append(i);\\n                }\\n            }\\n            if (sb.length() > 0) {\\n                ans.add(sb.toString());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def splitWordsBySeparator(words, separator):\n    ans = []\n    def func(str):\n        t = \"\"\n        for i in str:\n            if i == ' ':\n                continue\n            if i == separator:\n                if t:\n                    ans.append(t)\n                t = \"\"\n            else:\n                t += i\n        if t:\n            ans.append(t)\n\n    for i in words:\n        func(i)\n    return ans", "tl_gold_code": "public static List<String> splitWordsBySeparator(List<String> words, char separator) {\n    List<String> rs = new ArrayList<>();\n    StringBuffer sb = new StringBuffer();\n    for (String word : words) {\n        for (char c : word.toCharArray()) {\n            if (c == separator) {\n                if (sb.length() > 0) {\n                    rs.add(sb.toString());\n                    sb = new StringBuffer();\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n        if (sb.length() > 0) {\n            rs.add(sb.toString());\n            sb = new StringBuffer();\n        }\n    }\n    return rs;\n}"}
{"task": "python_java", "problem_id": 51, "prediction_id": 0, "pro_prediction": "public static List<Long> miniMaxSum(List<Integer> a) {\n    long s = a.stream().mapToLong(Integer::longValue).sum();\n    long max_ = a.stream().max(Integer::compare).mapToLong(Integer::longValue);\n    long min_ = a.stream().min(Integer::compare).mapToLong(Integer::longValue);\n    return List.of(s - max_, s - min_);\n}", "main_fun_name": "miniMaxSum", "raw_prediction": "\"```java\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\npublic List<Long> miniMaxSum(List<Integer> a) {\\n    long s = a.stream().mapToLong(Integer::longValue).sum();\\n    long max_ = a.stream().max(Integer::compare).mapToLong(Integer::longValue);\\n    long min_ = a.stream().min(Integer::compare).mapToLong(Integer::longValue);\\n    return List.of(s - max_, s - min_);\\n}\\n```\"", "sl_gold_code": "def miniMaxSum(a):\n    s = sum(a)\n    max_ = max(a)\n    min_ = min(a)\n    return [s - max_, s - min_]", "tl_gold_code": "public static List<Long> miniMaxSum(List<Integer> a) {\n    long sum = a.stream().mapToLong(Integer::longValue).sum(); \n    int max = Collections.max(a);\n    int min = Collections.min(a);\n    return Arrays.asList(sum - max, sum - min);\n}"}
{"task": "python_java", "problem_id": 52, "prediction_id": 0, "pro_prediction": "public static int pickingNumbers(List<Integer> a) {\n    Map<Integer, Integer> d = new HashMap<>();\n    for (int num : a) {\n        d.put(num, d.getOrDefault(num, 0) + 1);\n    }\n    int best = 0;\n    for (int i = 0; i < 99; i++) {\n        int key = i;\n        int value = d.getOrDefault(key, 0) + d.getOrDefault(key + 1, 0);\n        best = Math.max(value, best);\n    }\n    return best;\n}", "main_fun_name": "pickingNumbers", "raw_prediction": "\"```java\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic int pickingNumbers(List<Integer> a) {\\n    Map<Integer, Integer> d = new HashMap<>();\\n    for (int num : a) {\\n        d.put(num, d.getOrDefault(num, 0) + 1);\\n    }\\n    int best = 0;\\n    for (int i = 0; i < 99; i++) {\\n        int key = i;\\n        int value = d.getOrDefault(key, 0) + d.getOrDefault(key + 1, 0);\\n        best = Math.max(value, best);\\n    }\\n    return best;\\n}\\n```\"", "sl_gold_code": "def pickingNumbers(a):\n    from collections import Counter\n    d = Counter(a)\n    best = 0\n    for i in range(99):\n        best = max(d[i] + d[i+1], best)\n    return best", "tl_gold_code": "public static  int pickingNumbers(List<Integer> a) {\n    HashMap<Integer, Integer> d = new HashMap<>();\n    for (int num : a) {\n        d.put(num, d.getOrDefault(num, 0) + 1);\n    }\n    int best = 0;\n    for (int i = 0; i < 99; ++i) {\n        best = Math.max(d.getOrDefault(i, 0) + d.getOrDefault(i + 1, 0), best);\n    }\n    return best;\n}"}
{"task": "python_java", "problem_id": 53, "prediction_id": 0, "pro_prediction": "public static int summingSeries(long n) {\n    return (int) (n * n) % 1000000007;\n}", "main_fun_name": "summingSeries", "raw_prediction": "\"```java\\npublic int summingSeries(long n) {\\n    return (int) (n * n) % 1000000007;\\n}\\n```\"", "sl_gold_code": "def summingSeries(n):\n    return (n*n) % 1000000007", "tl_gold_code": "public static  int summingSeries(long n) {\n    return (int)((n % 1000000007) * (n % 1000000007) % 1000000007);\n}"}
{"task": "python_java", "problem_id": 54, "prediction_id": 0, "pro_prediction": "public static List<Integer> matchingStrings(List<String> stringList, List<String> queries) {\n    int k = 0;\n    List<Integer> arr = new ArrayList<>();\n    for (String i : queries) {\n        for (String j : stringList) {\n            if (i.equals(j)) {\n                k++;\n            }\n        }\n        arr.add(k);\n        k = 0;\n    }\n    return arr;\n}", "main_fun_name": "matchingStrings", "raw_prediction": "\"```java\\nimport java.util.List;\\n\\npublic List<Integer> matchingStrings(List<String> stringList, List<String> queries) {\\n    int k = 0;\\n    List<Integer> arr = new ArrayList<>();\\n    for (String i : queries) {\\n        for (String j : stringList) {\\n            if (i.equals(j)) {\\n                k++;\\n            }\\n        }\\n        arr.add(k);\\n        k = 0;\\n    }\\n    return arr;\\n}\\n```\"", "sl_gold_code": "def matchingStrings(stringList, queries):\n    k = 0\n    arr = []\n    for i in queries:\n        for j in stringList:\n            if i == j:\n                k += 1\n        arr.append(k)\n        k = 0\n        \n    return [i for i in arr]", "tl_gold_code": "public static  List<Integer> matchingStrings(List<String> stringList, List<String> queries) {\n    List<Integer> arr = new ArrayList<>();\n    for (String i : queries) {\n        int k = 0;\n        for (String j : stringList) {\n            if (i.equals(j)) {\n                k++;\n            }\n        }\n        arr.add(k);\n    }\n    return arr;\n}"}
{"task": "python_java", "problem_id": 55, "prediction_id": 0, "pro_prediction": "public static List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) {\n        List<Integer> rank_nums = new ArrayList<>(Collections.OrderedSet.create(ranked));\n        Collections.sort(rank_nums);\n        List<Integer> result = new ArrayList<>();\n        for (Integer score : player) {\n            int rank = binarySearch(rank_nums, score);\n            result.add(rank);\n        }\n        return result;\n    }\n\npublic static int binarySearch(List<Integer> arr, int x) {\n        int low = 0;\n        int high = arr.size() - 1;\n        int mid = 0;\n        while (low <= high) {\n            mid = (high + low) / 2;\n            if (arr.get(mid) > x) {\n                low = mid + 1;\n            } else if (arr.get(mid) < x) {\n                high = mid - 1;\n            } else {\n                return mid + 1;\n            }\n        }\n        return low + 1;\n    }", "main_fun_name": "climbingLeaderboard", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        List<Integer> ranked = new ArrayList<>(Collections.OrderedSet.create(Arrays.asList(1, 2, 3, 4, 5)));\\n        List<Integer> player = new ArrayList<>(Arrays.asList(2, 3, 5, 1, 4));\\n        List<Integer> result = climbingLeaderboard(ranked, player);\\n        System.out.println(result);\\n    }\\n\\n    public static List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) {\\n        List<Integer> rank_nums = new ArrayList<>(Collections.OrderedSet.create(ranked));\\n        Collections.sort(rank_nums);\\n        List<Integer> result = new ArrayList<>();\\n        for (Integer score : player) {\\n            int rank = binarySearch(rank_nums, score);\\n            result.add(rank);\\n        }\\n        return result;\\n    }\\n\\n    public static int binarySearch(List<Integer> arr, int x) {\\n        int low = 0;\\n        int high = arr.size() - 1;\\n        int mid = 0;\\n        while (low <= high) {\\n            mid = (high + low) / 2;\\n            if (arr.get(mid) > x) {\\n                low = mid + 1;\\n            } else if (arr.get(mid) < x) {\\n                high = mid - 1;\\n            } else {\\n                return mid + 1;\\n            }\\n        }\\n        return low + 1;\\n    }\\n}\\n```\"", "sl_gold_code": "def bsearch(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0  # ranking\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] > x:\n            low = mid + 1\n        elif arr[mid] < x:\n            high = mid - 1\n        else:\n            return mid + 1\n    return low + 1\ndef climbingLeaderboard(ranked, player):\n    from collections import OrderedDict\n    rank_nums = list(OrderedDict.fromkeys(ranked))\n    result = []\n    for score in player:\n        rank = bsearch(rank_nums, score)\n        result.append(rank)\n    return result", "tl_gold_code": "public static  int bsearch(List<Integer> arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0;\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n        if (arr.get(mid) < x) {\n            high = mid - 1;\n        } else if (arr.get(mid) > x) {\n            low = mid + 1;\n        } else {\n            return mid + 1;\n        }\n    }\n    return low + 1;\n}\npublic static  List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) {\n    LinkedHashSet<Integer> rankSet = new LinkedHashSet<>(ranked);\n    List<Integer> rankNums = new ArrayList<>(rankSet);\n    Collections.sort(rankNums, Collections.reverseOrder());\n    List<Integer> result = new ArrayList<>();\n    for (int score : player) {\n        int rank = bsearch(rankNums, score);\n        result.add(rank);\n    }\n    return result;\n}"}
{"task": "python_java", "problem_id": 56, "prediction_id": 0, "pro_prediction": "public static long arrayManipulation(int n, List<List<Integer>> queries) {\n    int[] arr = new int[n + 2];\n    long max_val = 0;\n    long sum_val = 0;\n\n    for (List<Integer> query : queries) {\n        arr[query.get(0)] += query.get(2);\n        arr[query.get(1) + 1] -= query.get(2);\n    }\n\n    for (int val : arr) {\n        sum_val += val;\n        max_val = Math.max(max_val, sum_val);\n    }\n\n    return max_val;\n}", "main_fun_name": "arrayManipulation", "raw_prediction": "\"```java\\npublic long arrayManipulation(int n, List<List<Integer>> queries) {\\n    int[] arr = new int[n + 2];\\n    long max_val = 0;\\n    long sum_val = 0;\\n\\n    for (List<Integer> query : queries) {\\n        arr[query.get(0)] += query.get(2);\\n        arr[query.get(1) + 1] -= query.get(2);\\n    }\\n\\n    for (int val : arr) {\\n        sum_val += val;\\n        max_val = Math.max(max_val, sum_val);\\n    }\\n\\n    return max_val;\\n}\\n```\"", "sl_gold_code": "def arrayManipulation(n, queries):\n    arr = [0] * (n + 2)\n    max_val = 0\n    sum_val = 0\n    \n    for query in queries:\n        arr[query[0]] += query[2]\n        arr[query[1] + 1] -= query[2]\n    \n    for val in arr:\n        sum_val += val\n        max_val = max(max_val, sum_val)\n        \n    return max_val", "tl_gold_code": "public static  long arrayManipulation(int n, List<List<Integer>> queries) {\n    long[] arr = new long[n + 2];\n    long max = 0;\n    long sum = 0;\n    \n    for (List<Integer> query : queries) {\n        arr[query.get(0)] += query.get(2);\n        arr[query.get(1) + 1] -= query.get(2);\n    }\n    \n    for (long val : arr) {\n        sum += val;\n        if (sum > max) max = sum;\n    }\n    return max;\n}"}
{"task": "python_java", "problem_id": 57, "prediction_id": 0, "pro_prediction": "public static ListNode deleteNode(ListNode llist, int position) {\n        if (llist == null) {\n            return null;\n        }\n        if (position == 0) {\n            return llist.next;\n        }\n        ListNode current = llist, previous = null;\n        int pointer = 0;\n        while (pointer < position + 1) {\n            previous = current;\n            current = current.next;\n            pointer++;\n        }\n        previous.next = current.next;\n        return llist;\n    }", "main_fun_name": "deleteNode", "raw_prediction": "\"```java\\npublic class ListNode {\\n    int val;\\n    ListNode next;\\n    \\n    public ListNode(int val) {\\n        this.val = val;\\n        this.next = null;\\n    }\\n}\\n\\npublic class Solution {\\n    public ListNode deleteNode(ListNode llist, int position) {\\n        if (llist == null) {\\n            return null;\\n        }\\n        if (position == 0) {\\n            return llist.next;\\n        }\\n        ListNode current = llist, previous = null;\\n        int pointer = 0;\\n        while (pointer < position + 1) {\\n            previous = current;\\n            current = current.next;\\n            pointer++;\\n        }\\n        previous.next = current.next;\\n        return llist;\\n    }\\n}\\n```\"", "sl_gold_code": "def deleteNode(llist, position):\n    if not llist:\n        return \n    if position == 0:\n        return llist.next\n    current = previous = llist\n    pointer = 1\n    while pointer < position+1:\n        previous = current\n        current = current.next\n        pointer += 1\n    previous.next = current.next\n    return llist", "tl_gold_code": "public static  ListNode deleteNode(ListNode llist, int position) {\n    if (llist == null) {\n        return null;\n    }\n    if (position == 0) {\n        return llist.next;\n    }\n    ListNode current = llist;\n    for (int i = 0; current != null && i < position - 1; i++) {\n        current = current.next;\n    }\n    if (current == null || current.next == null) {\n        return llist;\n    }\n    ListNode next = current.next.next;\n    current.next = next;\n    return llist;\n}"}
{"task": "python_java", "problem_id": 58, "prediction_id": 0, "pro_prediction": "public static boolean evaluateTree(TreeNode root) {\n    if (root == null) {\n        return false;\n    }\n    if (root.left == null) {\n        return root.val != 0;\n    }\n    boolean l = evaluateTree(root.left);\n    boolean r = evaluateTree(root.right);\n    return (root.val == 2 && (l || r)) || (!root.val.equals(2) && l && r);\n}", "main_fun_name": "evaluateTree", "raw_prediction": "\"```java\\nboolean evaluateTree(TreeNode root) {\\n    if (root == null) {\\n        return false;\\n    }\\n    if (root.left == null) {\\n        return root.val != 0;\\n    }\\n    boolean l = evaluateTree(root.left);\\n    boolean r = evaluateTree(root.right);\\n    return (root.val == 2 && (l || r)) || (!root.val.equals(2) && l && r);\\n}\\n```\"", "sl_gold_code": "def evaluateTree(root: Optional[TreeNode]) -> bool:\n    if root.left is None:\n        return bool(root.val)\n    l = evaluateTree(root.left)\n    r = evaluateTree(root.right)\n    return l or r if root.val == 2 else l and r", "tl_gold_code": "public static boolean evaluateTree(TreeNode root) {\n    if (root.left == null) {\n        return root.val == 1;\n    }\n    boolean l = evaluateTree(root.left);\n    boolean r = evaluateTree(root.right);\n    return root.val == 2 ? l || r : l && r;\n}"}
{"task": "python_java", "problem_id": 59, "prediction_id": 0, "pro_prediction": "public static int andXorOr(List<Integer> a) {\n    int m = 0;\n    Stack<Integer> s = new Stack<>();\n    for (int i : a) {\n        while (!s.isEmpty() && s.peek() >= i) {\n            m = Math.max(m, i ^ s.pop());\n        }\n        if (!s.isEmpty()) {\n            m = Math.max(m, i ^ s.peek());\n        }\n        s.push(i);\n    }\n    return m;\n}", "main_fun_name": "andXorOr", "raw_prediction": "\"```java\\npublic int andXorOr(List<Integer> a) {\\n    int m = 0;\\n    Stack<Integer> s = new Stack<>();\\n    for (int i : a) {\\n        while (!s.isEmpty() && s.peek() >= i) {\\n            m = Math.max(m, i ^ s.pop());\\n        }\\n        if (!s.isEmpty()) {\\n            m = Math.max(m, i ^ s.peek());\\n        }\\n        s.push(i);\\n    }\\n    return m;\\n}\\n```\"", "sl_gold_code": "def andXorOr(a):\n    m = 0\n    s = []\n    for i in a:     \n        while s and s[-1] >= i:\n            m = max(m, i^s.pop())\n        if s:\n            m = max(m, i^s[-1])\n        s.append(i)\n    return m", "tl_gold_code": "public static  int andXorOr(List<Integer> a) {\n    int m = 0;\n    Stack<Integer> s = new Stack<>();\n    for (int i : a) {\n        while (!s.isEmpty() && s.peek() >= i) {\n            m = Math.max(m, i ^ s.pop());\n        }\n        if (!s.isEmpty()) {\n            m = Math.max(m, i ^ s.peek());\n        }\n        s.push(i);\n    }\n    return m;\n}"}
{"task": "python_java", "problem_id": 60, "prediction_id": 0, "pro_prediction": "public static List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) {\n    Map<Integer, Integer> mp = new HashMap<>();\n    for (int num : brr) {\n        mp.put(num, mp.getOrDefault(num, 0) + 1);\n    }\n    for (int num : arr) {\n        mp.put(num, mp.get(num) - 1);\n    }\n    List<Integer> result = new ArrayList<>();\n    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\n        if (entry.getValue() > 0) {\n            result.add(entry.getKey());\n        }\n    }\n    Collections.sort(result);\n    return result;\n}", "main_fun_name": "missingNumbers", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) {\\n    Map<Integer, Integer> mp = new HashMap<>();\\n    for (int num : brr) {\\n        mp.put(num, mp.getOrDefault(num, 0) + 1);\\n    }\\n    for (int num : arr) {\\n        mp.put(num, mp.get(num) - 1);\\n    }\\n    List<Integer> result = new ArrayList<>();\\n    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\\n        if (entry.getValue() > 0) {\\n            result.add(entry.getKey());\\n        }\\n    }\\n    Collections.sort(result);\\n    return result;\\n}\\n```\"", "sl_gold_code": "def missingNumbers(arr, brr):\n    from collections import Counter\n    \n    mp = Counter(brr)\n    for num in arr:\n        mp[num] -= 1\n        \n    result = sorted([num for num, count in mp.items() if count > 0])\n    \n    return result", "tl_gold_code": "public static  List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) {\n\tMap<Integer, Integer> mp = new HashMap<>();\n\tfor (int num : brr) mp.put(num, mp.getOrDefault(num, 0) + 1);\n\tfor (int num : arr) mp.put(num, mp.getOrDefault(num, 0) - 1);\n\t\n\tList<Integer> result = new ArrayList<>();\n\tfor (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\n\t\tif (entry.getValue() > 0) result.add(entry.getKey());\n\t}\n\t\n\treturn result;\n}"}
{"task": "python_java", "problem_id": 61, "prediction_id": 0, "pro_prediction": "public static long maximumSum(List<Long> a, long m) {\n        long max_sum = 0;\n        long current_sum = 0;\n        List<Long> sorted_sums = new ArrayList<>(1);\n        sorted_sums.add(0L);\n\n        for (Long value : a) {\n            current_sum = (current_sum + value) % m;\n            max_sum = Math.max(max_sum, current_sum);\n\n            int idx = Collections.binarySearch(sorted_sums, current_sum);\n            if (idx < 0) {\n                idx = -(idx + 1);\n            }\n\n            if (idx < sorted_sums.size()) {\n                long possible_max = (current_sum - sorted_sums.get(idx) + m) % m;\n                max_sum = Math.max(max_sum, possible_max);\n            }\n\n            sorted_sums.add(current_sum);\n            Collections.sort(sorted_sums);\n        }\n\n        return max_sum;\n    }", "main_fun_name": "maximumSum", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        List<Long> a = Arrays.asList(1L, 2L, 3L, 4L, 5L);\\n        long m = 3;\\n        System.out.println(maximumSum(a, m)); // Output: 5\\n    }\\n\\n    public static long maximumSum(List<Long> a, long m) {\\n        long max_sum = 0;\\n        long current_sum = 0;\\n        List<Long> sorted_sums = new ArrayList<>(1);\\n        sorted_sums.add(0L);\\n\\n        for (Long value : a) {\\n            current_sum = (current_sum + value) % m;\\n            max_sum = Math.max(max_sum, current_sum);\\n\\n            int idx = Collections.binarySearch(sorted_sums, current_sum);\\n            if (idx < 0) {\\n                idx = -(idx + 1);\\n            }\\n\\n            if (idx < sorted_sums.size()) {\\n                long possible_max = (current_sum - sorted_sums.get(idx) + m) % m;\\n                max_sum = Math.max(max_sum, possible_max);\\n            }\\n\\n            sorted_sums.add(current_sum);\\n            Collections.sort(sorted_sums);\\n        }\\n\\n        return max_sum;\\n    }\\n}\\n```\"", "sl_gold_code": "def maximumSum(a, m):\n    max_sum = 0\n    current_sum = 0\n    sorted_sums = [0] \n    for value in a:\n        current_sum = (current_sum + value) % m\n        max_sum = max(max_sum, current_sum)\n        idx = bisect_right(sorted_sums, current_sum)\n        if idx < len(sorted_sums):\n            possible_max = (current_sum - sorted_sums[idx] + m) % m\n            max_sum = max(max_sum, possible_max)\n        insort(sorted_sums, current_sum)\n    return max_sum", "tl_gold_code": "public static  long maximumSum(List<Long> a, long m) {\n    long maxSum = 0;\n    long currentSum = 0;\n    TreeSet<Long> s = new TreeSet<>();\n    for (long number : a) {\n        currentSum = (currentSum + number) % m;\n        maxSum = Math.max(maxSum, currentSum);\n        Long b = s.higher(currentSum);\n        if (b != null) {\n            long possibleMax = (currentSum - b + m) % m;\n            maxSum = Math.max(maxSum, possibleMax);\n        }\n        s.add(currentSum);\n    }\n    return maxSum;\n}"}
{"task": "python_java", "problem_id": 62, "prediction_id": 0, "pro_prediction": "public static int formingMagicSquare(List<List<Integer>> s) {\n    List<List<List<Integer>>> magicSquares = Arrays.asList(\n        Arrays.asList(Arrays.asList(8, 1, 6), Arrays.asList(3, 5, 7), Arrays.asList(4, 9, 2)),\n        Arrays.asList(Arrays.asList(6, 1, 8), Arrays.asList(7, 5, 3), Arrays.asList(2, 9, 4)),\n        Arrays.asList(Arrays.asList(4, 9, 2), Arrays.asList(3, 5, 7), Arrays.asList(8, 1, 6)),\n        Arrays.asList(Arrays.asList(2, 9, 4), Arrays.asList(7, 5, 3), Arrays.asList(6, 1, 8)),\n        Arrays.asList(Arrays.asList(8, 3, 4), Arrays.asList(1, 5, 9), Arrays.asList(6, 7, 2)),\n        Arrays.asList(Arrays.asList(4, 3, 8), Arrays.asList(9, 5, 1), Arrays.asList(2, 7, 6)),\n        Arrays.asList(Arrays.asList(6, 7, 2), Arrays.asList(1, 5, 9), Arrays.asList(8, 3, 4)),\n        Arrays.asList(Arrays.asList(2, 7, 6), Arrays.asList(9, 5, 1), Arrays.asList(4, 3, 8))\n    );\n    int minCost = 8 * 3;\n    for (List<List<Integer>> magicSquare : magicSquares) {\n        int cost = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                cost += Math.abs(s.get(i).get(j) - magicSquare.get(i).get(j));\n            }\n        }\n        minCost = Math.min(cost, minCost);\n    }\n    return minCost;\n}", "main_fun_name": "formingMagicSquare", "raw_prediction": "\"```java\\npublic int formingMagicSquare(List<List<Integer>> s) {\\n    List<List<List<Integer>>> magicSquares = Arrays.asList(\\n        Arrays.asList(Arrays.asList(8, 1, 6), Arrays.asList(3, 5, 7), Arrays.asList(4, 9, 2)),\\n        Arrays.asList(Arrays.asList(6, 1, 8), Arrays.asList(7, 5, 3), Arrays.asList(2, 9, 4)),\\n        Arrays.asList(Arrays.asList(4, 9, 2), Arrays.asList(3, 5, 7), Arrays.asList(8, 1, 6)),\\n        Arrays.asList(Arrays.asList(2, 9, 4), Arrays.asList(7, 5, 3), Arrays.asList(6, 1, 8)),\\n        Arrays.asList(Arrays.asList(8, 3, 4), Arrays.asList(1, 5, 9), Arrays.asList(6, 7, 2)),\\n        Arrays.asList(Arrays.asList(4, 3, 8), Arrays.asList(9, 5, 1), Arrays.asList(2, 7, 6)),\\n        Arrays.asList(Arrays.asList(6, 7, 2), Arrays.asList(1, 5, 9), Arrays.asList(8, 3, 4)),\\n        Arrays.asList(Arrays.asList(2, 7, 6), Arrays.asList(9, 5, 1), Arrays.asList(4, 3, 8))\\n    );\\n    int minCost = 8 * 3;\\n    for (List<List<Integer>> magicSquare : magicSquares) {\\n        int cost = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                cost += Math.abs(s.get(i).get(j) - magicSquare.get(i).get(j));\\n            }\\n        }\\n        minCost = Math.min(cost, minCost);\\n    }\\n    return minCost;\\n}\\n```\"", "sl_gold_code": "def formingMagicSquare(s):\n    magicSquares = [\n        [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\n        [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\n        [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\n        [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\n        [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\n        [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\n        [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\n        [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    ]\n    minCost = 8*3\n    for magicSquare in magicSquares:\n        cost = 0\n        for i in range(3):\n            for j in range(3):\n                cost += abs(s[i][j] - magicSquare[i][j])\n        minCost = min(cost , minCost)\n    return minCost", "tl_gold_code": "public static  int formingMagicSquare(List<List<Integer>> sList) {\n\tint[][] s = sList.stream()\n\t\t\t\t\t  .map(l -> l.stream().mapToInt(Integer::intValue).toArray())\n\t\t\t\t\t  .toArray(int[][]::new);\n\tint[][][] magicSquares = {\n\t\t{{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n\t\t{{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n\t\t{{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n\t\t{{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n\t\t{{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n\t\t{{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n\t\t{{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n\t\t{{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n\t};\n\tint minCost = 8 * 3;\n\tfor (int[][] magicSquare : magicSquares) {\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tcost += Math.abs(s[i][j] - magicSquare[i][j]);\n\t\t\t}\n\t\t}\n\t\tminCost = Math.min(cost, minCost);\n\t}\n\treturn minCost;\n}"}
{"task": "python_java", "problem_id": 63, "prediction_id": 0, "pro_prediction": "public static String isFibo(long n) {\n        long start = 0;\n        long last = 1;\n        while (last <= n) {\n            long tmp = last + start;\n            start = last;\n            last = tmp;\n            if (last == n) {\n                return \"IsFibo\";\n            }\n        }\n        return \"IsNotFibo\";\n    }", "main_fun_name": "isFibo", "raw_prediction": "\"```java\\npublic class Main {\\n    public static void main(String[] args) {\\n        System.out.println(isFibo(8)); // IsFibo\\n        System.out.println(isFibo(13)); // IsFibo\\n        System.out.println(isFibo(21)); // IsFibo\\n        System.out.println(isFibo(22)); // IsNotFibo\\n    }\\n\\n    public static String isFibo(long n) {\\n        long start = 0;\\n        long last = 1;\\n        while (last <= n) {\\n            long tmp = last + start;\\n            start = last;\\n            last = tmp;\\n            if (last == n) {\\n                return \\\"IsFibo\\\";\\n            }\\n        }\\n        return \\\"IsNotFibo\\\";\\n    }\\n}\\n```\"", "sl_gold_code": "def isFibo(n):\n    start = 0\n    last = 1\n    while last <= n:\n        tmp = last + start\n        start = last\n        last = tmp\n        if last== n:\n            return \"IsFibo\"\n    return \"IsNotFibo\"", "tl_gold_code": "public static  String isFibo(long n) {\n    long start = 0;\n    long last = 1;\n    while (last <= n) {\n        long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}"}
{"task": "python_java", "problem_id": 64, "prediction_id": 0, "pro_prediction": "public static int solve(long l, long r) {\n        Set<Long> seen = new HashSet<>();\n        Deque<Long> q = new Deque<>();\n        for (int i = 0; i < 10; i++) {\n            q.offer(i);\n        }\n        while (!q.isEmpty()) {\n            long u = q.poll();\n            if (String.valueOf(u).length() >= 20) {\n                continue;\n            }\n            if (seen.contains(u)) {\n                continue;\n            }\n            seen.add(u);\n            int length = String.valueOf(u).length();\n            for (int k = length; k < length + 5; k++) {\n                if (String.valueOf(u * k).length() == k) {\n                    q.offer(u * k);\n                }\n            }\n        }\n        int count = 0;\n        for (long s : seen) {\n            if (l <= s && s <= r) {\n                count++;\n            }\n        }\n        System.out.println(String.format(\" [%d, %d]: %d\", l, r, count));\n        return count;\n    }", "main_fun_name": "solve", "raw_prediction": "\"```java\\nimport java.util.Deque;\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public int solve(long l, long r) {\\n        Set<Long> seen = new HashSet<>();\\n        Deque<Long> q = new Deque<>();\\n        for (int i = 0; i < 10; i++) {\\n            q.offer(i);\\n        }\\n        while (!q.isEmpty()) {\\n            long u = q.poll();\\n            if (String.valueOf(u).length() >= 20) {\\n                continue;\\n            }\\n            if (seen.contains(u)) {\\n                continue;\\n            }\\n            seen.add(u);\\n            int length = String.valueOf(u).length();\\n            for (int k = length; k < length + 5; k++) {\\n                if (String.valueOf(u * k).length() == k) {\\n                    q.offer(u * k);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for (long s : seen) {\\n            if (l <= s && s <= r) {\\n                count++;\\n            }\\n        }\\n        System.out.println(String.format(\\\" [%d, %d]: %d\\\", l, r, count));\\n        return count;\\n    }\\n}\\n```\"", "sl_gold_code": "def solve(l, r):\n    from collections import deque\n    seen = set()\n    q = deque()\n    q.extend(range(10))\n    while q:\n        u = q.pop()\n        if len(str(u)) >= 20:\n            continue\n        if u in seen:\n            continue\n        seen.add(u)\n        length = len(str(u))\n        for k in range(length, length + 5):\n            if len(str(u * k)) == k:\n                q.append(u * k)\n    print(f'[{l}, {r}]: {sum(l <= s <= r for s in seen)}')\n    return sum(l <= s <= r for s in seen)", "tl_gold_code": "public static  int solve(long l, long r) {\n\tSet<Long> seen = new HashSet<>();\n\tDeque<Long> q = new ArrayDeque<>();\n\tfor (int i = 0; i < 10; i++) q.addLast((long)i);\n\twhile (!q.isEmpty()) {\n\t\tlong u = q.removeLast();\n\t\tif (String.valueOf(u).length() >= 20) continue;\n\t\tif (seen.contains(u)) continue;\n\t\tseen.add(u);\n\t\tint length = String.valueOf(u).length();\n\t\tfor (int k = length; k < length + 5; k++) {\n\t\t\tif (String.valueOf(u * k).length() == k) {\n\t\t\t\tq.addLast(u * k);\n\t\t\t}\n\t\t}\n\t}\n\tint count = 0;\n\tfor (long s : seen) {\n\t\tif (l <= s && s <= r) count++;\n\t}\n\tSystem.out.println(\"[\" + l + \", \" + r + \"]: \" + count);\n\treturn count;\n}"}
{"task": "python_java", "problem_id": 65, "prediction_id": 0, "pro_prediction": "public static List<String> cavityMap(List<String> grid) {\n    for (int k = 1; k < grid.size() - 1; k++) {\n        String i = grid.get(k);\n        String d = grid.get(k + 1);\n        String u = grid.get(k - 1);\n        for (int j = 1; j < i.length() - 1; j++) {\n            if (i.charAt(j - 1) < i.charAt(j) && i.charAt(j) > i.charAt(j + 1) && d.charAt(j) < i.charAt(j) && i.charAt(j) > u.charAt(j)) {\n                char[] x = i.toCharArray();\n                x[j] = 'X';\n                grid.set(k, new String(x));\n            }\n        }\n    }\n    return grid;\n}", "main_fun_name": "cavityMap", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\npublic List<String> cavityMap(List<String> grid) {\\n    for (int k = 1; k < grid.size() - 1; k++) {\\n        String i = grid.get(k);\\n        String d = grid.get(k + 1);\\n        String u = grid.get(k - 1);\\n        for (int j = 1; j < i.length() - 1; j++) {\\n            if (i.charAt(j - 1) < i.charAt(j) && i.charAt(j) > i.charAt(j + 1) && d.charAt(j) < i.charAt(j) && i.charAt(j) > u.charAt(j)) {\\n                char[] x = i.toCharArray();\\n                x[j] = 'X';\\n                grid.set(k, new String(x));\\n            }\\n        }\\n    }\\n    return grid;\\n}\\n```\"", "sl_gold_code": "def cavityMap(grid):\n    for k in range(1,len(grid)-1):\n        i = grid[k]\n        d = grid[k+1]\n        u = grid[k-1]\n        for j in range(1, len(grid)-1):\n            if (i[j-1] < i[j] > i[j+1]) and (d[j] <i[j] > u[j]):\n                x= list(grid[k])\n                x[j] = \"X\"\n                grid[k] = \"\".join(x)\n    return grid", "tl_gold_code": "public static  List<String> cavityMap(List<String> grid) {\n\tfor (int k = 1; k < grid.size() - 1; k++) {\n\t\tchar[] row = grid.get(k).toCharArray();\n\t\tString d = grid.get(k + 1);\n\t\tString u = grid.get(k - 1);\n\t\tfor (int j = 1; j < row.length - 1; j++) {\n\t\t\tchar left = row[j - 1];\n\t\t\tchar current = row[j];\n\t\t\tchar right = row[j + 1];\n\t\t\tchar down = d.charAt(j);\n\t\t\tchar up = u.charAt(j);\n\t\t\tif (left < current && current > right && down < current && up < current) {\n\t\t\t\trow[j] = 'X';\n\t\t\t}\n\t\t}\n\t\tgrid.set(k, new String(row));\n\t}\n\treturn grid;\n}"}
{"task": "python_java", "problem_id": 66, "prediction_id": 0, "pro_prediction": "public static long solve(int a, int b) {\n    int m = a;\n    int n = b;\n    long ans = Math.min((m - 1) * n + (n - 1), (n - 1) * m + (m - 1));\n    return m * n - 1;\n}", "main_fun_name": "solve", "raw_prediction": "\"```java\\npublic long solve(int a, int b) {\\n    int m = a;\\n    int n = b;\\n    long ans = Math.min((m - 1) * n + (n - 1), (n - 1) * m + (m - 1));\\n    return m * n - 1;\\n}\\n```\"", "sl_gold_code": "def solve(a, b):\n    m = a\n    n = b\n    ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)))\n    return m*n - 1", "tl_gold_code": "public static  long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = Math.min(((m-1)*n+(n-1)),((n-1)*m+(m-1)));\n    return m*n-1;\n}"}
{"task": "python_java", "problem_id": 67, "prediction_id": 0, "pro_prediction": "public static int minimumLoss(List<Long> price) {\n        Map<Long, Integer> mapIndex = new HashMap<>();\n        for (int i = 0; i < price.size(); i++) {\n            mapIndex.put(price.get(i), i);\n        }\n        Long[] priceArray = price.stream().mapToLong(Long::longValue).toArray();\n        Arrays.sort(priceArray);\n        long minLoss = Long.MAX_VALUE;\n        for (int i = 0; i < priceArray.length - 1; i++) {\n            long currentLoss = priceArray[i + 1] - priceArray[i];\n            if (currentLoss < minLoss && mapIndex.get(priceArray[i]) > mapIndex.get(priceArray[i + 1])) {\n                minLoss = currentLoss;\n            }\n        }\n        return (int) minLoss;\n    }", "main_fun_name": "minimumLoss", "raw_prediction": "\"```java\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumLoss(List<Long> price) {\\n        Map<Long, Integer> mapIndex = new HashMap<>();\\n        for (int i = 0; i < price.size(); i++) {\\n            mapIndex.put(price.get(i), i);\\n        }\\n        Long[] priceArray = price.stream().mapToLong(Long::longValue).toArray();\\n        Arrays.sort(priceArray);\\n        long minLoss = Long.MAX_VALUE;\\n        for (int i = 0; i < priceArray.length - 1; i++) {\\n            long currentLoss = priceArray[i + 1] - priceArray[i];\\n            if (currentLoss < minLoss && mapIndex.get(priceArray[i]) > mapIndex.get(priceArray[i + 1])) {\\n                minLoss = currentLoss;\\n            }\\n        }\\n        return (int) minLoss;\\n    }\\n}\\n```\"", "sl_gold_code": "def minimumLoss(price):\n    map_index = {p: i for i, p in enumerate(price)}\n    price.sort()\n    min_loss = float('inf')\n    for i in range(len(price) - 1):\n        current_loss = price[i+1] - price[i]\n        if current_loss < min_loss and map_index[price[i]] > map_index[price[i+1]]:\n            min_loss = current_loss\n    return int(min_loss)", "tl_gold_code": "public static  int minimumLoss(List<Long> price) {\n    HashMap<Long, Integer> map = new HashMap<>();\n    for (int i = 0; i < price.size(); i++) {\n        map.put(price.get(i),i);\n    }\n    Collections.sort(price);\n    long min = Integer.MAX_VALUE;\n    for (int i = 0; i < price.size()-1; i++) {\n        long currentMin = price.get(i+1)-price.get(i);\n        if(currentMin < min && map.get(price.get(i))>map.get(price.get(i+1))) min = currentMin; \n    }\n    return (int)min;\n}"}
{"task": "python_java", "problem_id": 68, "prediction_id": 0, "pro_prediction": "public static String dayOfProgrammer(int year) {\n        if (1918 == year) {\n            return \"26.09.1918\";\n        }\n        boolean leapYear = true;\n        if (year % 4 != 0 && (year > 1918 && year % 100 != 0 || year % 400 != 0)) {\n            leapYear = false;\n        }\n        return \".\".join(new String[]{\"12\", \"13\", \"09\", String.valueOf(year)});\n    }", "main_fun_name": "dayOfProgrammer", "raw_prediction": "\"```java\\npublic class DayOfProgrammer {\\n    public static void main(String[] args) {\\n        System.out.println(dayOfProgrammer(1918)); // Output: \\\"26.09.1918\\\"\\n        System.out.println(dayOfProgrammer(2022)); // Output: \\\"13.09.2022\\\"\\n    }\\n\\n    public static String dayOfProgrammer(int year) {\\n        if (1918 == year) {\\n            return \\\"26.09.1918\\\";\\n        }\\n        boolean leapYear = true;\\n        if (year % 4 != 0 && (year > 1918 && year % 100 != 0 || year % 400 != 0)) {\\n            leapYear = false;\\n        }\\n        return \\\".\\\".join(new String[]{\\\"12\\\", \\\"13\\\", \\\"09\\\", String.valueOf(year)});\\n    }\\n}\\n```\"", "sl_gold_code": "def dayOfProgrammer(year):\n    if 1918==year:\n        return '26.09.1918'\n    leap_year = True\n    if year % 4 or year > 1918 and not year % 100 and year % 400:\n        leap_year = False\n    return '.'.join(['12' if leap_year else '13', '09', str(year)])", "tl_gold_code": "public static  String dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    boolean leapYear = true;\n    if (year % 4 != 0 || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leapYear = false;\n    }\n    return (leapYear ? \"12\" : \"13\") + \".09.\" + year;\n}"}
{"task": "python_java", "problem_id": 69, "prediction_id": 0, "pro_prediction": "public static List<Integer> acmTeam(List<String> topic) {\n        int teamLen = topic.size();\n        int topicLen = topic.get(0).length();\n        int maxKnown = 0;\n        int maxTeams = 0;\n        for (int i = 0; i < teamLen; i++) {\n            String t1 = topic.get(i);\n            for (int j = i + 1; j < teamLen; j++) {\n                int know = 0;\n                String t2 = topic.get(j);\n                for (int k = 0; k < topicLen; k++) {\n                    if (t1.charAt(k) == '1' || t2.charAt(k) == '1') {\n                        know++;\n                    }\n                }\n                if (know == maxKnown) {\n                    maxTeams++;\n                } else if (know > maxKnown) {\n                    maxKnown = know;\n                    maxTeams = 1;\n                }\n            }\n        }\n        return new ArrayList<>(List.of(maxKnown, maxTeams));\n    }", "main_fun_name": "acmTeam", "raw_prediction": "\"```java\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Main {\\n    public static List<Integer> acmTeam(List<String> topic) {\\n        int teamLen = topic.size();\\n        int topicLen = topic.get(0).length();\\n        int maxKnown = 0;\\n        int maxTeams = 0;\\n        for (int i = 0; i < teamLen; i++) {\\n            String t1 = topic.get(i);\\n            for (int j = i + 1; j < teamLen; j++) {\\n                int know = 0;\\n                String t2 = topic.get(j);\\n                for (int k = 0; k < topicLen; k++) {\\n                    if (t1.charAt(k) == '1' || t2.charAt(k) == '1') {\\n                        know++;\\n                    }\\n                }\\n                if (know == maxKnown) {\\n                    maxTeams++;\\n                } else if (know > maxKnown) {\\n                    maxKnown = know;\\n                    maxTeams = 1;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(List.of(maxKnown, maxTeams));\\n    }\\n\\n    public static void main(String[] args) {\\n        List<String> topic = List.of(\\\"100\\\", \\\"110\\\", \\\"1000\\\", \\\"1001\\\");\\n        List<Integer> result = acmTeam(topic);\\n        System.out.println(result);\\n    }\\n}\\n```\"", "sl_gold_code": "def acmTeam(topic):\n    teamLen = len(topic)\n    topicLen = len(topic[0])\n    maxKnown = 0\n    maxTeams = 0\n    for i in range(teamLen):\n        t1 = topic[i]\n        for j in range(i + 1, teamLen):\n            know = 0\n            t2 = topic[j]\n            for k in range(topicLen):\n                if t1[k] == '1' or t2[k] == '1':\n                    know += 1\n            if know == maxKnown:\n                maxTeams += 1\n            elif know > maxKnown:\n                maxKnown = know\n                maxTeams = 1\n    return [maxKnown, maxTeams]", "tl_gold_code": "public static  List<Integer> acmTeam(List<String> topic) {\n\tint teamLen = topic.size();\n\tint topicLen = topic.get(0).length();\n\tint maxKnown = 0;\n\tint maxTeams = 0;\n\tfor (int i = 0; i < teamLen; i++) {\n\t\tString t1 = topic.get(i);\n\t\tfor (int j = i + 1; j < teamLen; j++) {\n\t\t\tint know = 0;\n\t\t\tString t2 = topic.get(j);\n\t\t\tfor (int k = 0; k < topicLen; k++) {\n\t\t\t\tif (t1.charAt(k) == '1' || t2.charAt(k) == '1')\n\t\t\t\t\tknow++;\n\t\t\t}\n\t\t\tif (know == maxKnown)\n\t\t\t\tmaxTeams++;\n\t\t\telse if (know > maxKnown) {\n\t\t\t\tmaxKnown = know;\n\t\t\t\tmaxTeams = 1;\n\t\t\t}\n\t\t}\n\t}\n\tList<Integer> result = new ArrayList<>();\n\tresult.add(maxKnown);\n\tresult.add(maxTeams);\n\treturn result;\n}"}
{"task": "python_java", "problem_id": 70, "prediction_id": 0, "pro_prediction": "public static String timeInWords(int h, int m) {\n        if (m == 0) {\n            return hours[h - 1] + \" o' clock\";\n        } else if (m == 15) {\n            return \"quarter past \" + hours[h - 1];\n        } else if (m == 30) {\n            return \"half past \" + hours[h - 1];\n        } else if (m == 45) {\n            return \"quarter to \" + hours[h % 12];\n        } else if (m == 1) {\n            return minutes[m - 1] + \" minute past \" + hours[h - 1];\n        } else if (m >= 2 && m < 30) {\n            return minutes[m - 1] + \" minutes past \" + hours[h - 1];\n        } else {\n            return minutes[60 - m - 1] + \" minutes to \" + hours[h % 12];\n        }\n    }", "main_fun_name": "timeInWords", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\npublic class TimeInWords {\\n    private static final String[] hours = {\\\"one\\\", \\\"two\\\", \\\"three\\\", \\\"four\\\", \\\"five\\\", \\\"six\\\", \\\"seven\\\", \\\"eight\\\", \\\"nine\\\", \\\"ten\\\", \\\"eleven\\\", \\\"twelve\\\"};\\n    private static final String[] minutes = {\\\"one\\\", \\\"two\\\", \\\"three\\\", \\\"four\\\", \\\"five\\\", \\\"six\\\", \\\"seven\\\", \\\"eight\\\", \\\"nine\\\", \\\"ten\\\", \\\"eleven\\\", \\\"twelve\\\", \\\"thirteen\\\",\\n                                           \\\"fourteen\\\", \\\"fifteen\\\", \\\"sixteen\\\", \\\"seventeen\\\", \\\"eighteen\\\", \\\"nineteen\\\", \\\"twenty\\\", \\n                                           \\\"twenty one\\\", \\\"twenty two\\\", \\\"twenty three\\\", \\\"twenty four\\\", \\\"twenty five\\\", \\n                                           \\\"twenty six\\\", \\\"twenty seven\\\", \\\"twenty eight\\\", \\\"twenty nine\\\"};\\n\\n    public static String timeInWords(int h, int m) {\\n        if (m == 0) {\\n            return hours[h - 1] + \\\" o' clock\\\";\\n        } else if (m == 15) {\\n            return \\\"quarter past \\\" + hours[h - 1];\\n        } else if (m == 30) {\\n            return \\\"half past \\\" + hours[h - 1];\\n        } else if (m == 45) {\\n            return \\\"quarter to \\\" + hours[h % 12];\\n        } else if (m == 1) {\\n            return minutes[m - 1] + \\\" minute past \\\" + hours[h - 1];\\n        } else if (m >= 2 && m < 30) {\\n            return minutes[m - 1] + \\\" minutes past \\\" + hours[h - 1];\\n        } else {\\n            return minutes[60 - m - 1] + \\\" minutes to \\\" + hours[h % 12];\\n        }\\n    }\\n}\\n```\"", "sl_gold_code": "def timeInWords(h, m):\n    hour = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"]\n    minutes = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\",\n               \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \n               \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \n               \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"]\n    if m == 0:\n        return hour[h - 1] + \" o' clock\"\n    elif m == 15:\n        return \"quarter past \" + hour[h - 1]\n    elif m == 30:\n        return \"half past \" + hour[h - 1]\n    elif m == 45:\n        return \"quarter to \" + hour[(h % 12)]\n    elif m == 1:\n        return minutes[m - 1] + \" minute past \" + hour[h - 1]\n    elif 0 < m < 30:\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1]\n    else:\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12]", "tl_gold_code": "public static  String timeInWords(int h, int m){\n    String[] hour = {\"one\", \"two\", \"three\", \"four\",\n                     \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"};\n    String[] minutes = {\"one\", \"two\",\n                        \"three\", \"four\", \"five\",\n                        \"six\", \"seven\", \"eight\",\n                        \"nine\", \"ten\", \"eleven\",\n                        \"twelve\", \"thirteen\", \"fourteen\",\n                        \"fifteen\", \"sixteen\", \"seventeen\",\n                        \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"};\n    if (m == 0){\n        return hour[h - 1] + \" o' clock\";\n    }\n    else if (m == 15){\n        return \"quarter past \" + hour[h - 1];\n    }\n    else if (m == 30){\n        return \"half past \" + hour[h - 1];\n    }\n    else if (m == 45){\n        return \"quarter to \" + hour[h];\n    }\n    else if (m == 1){\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    }\n    else if (0 < m & m < 30){\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    }\n    else{\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h];\n    }\n}"}
{"task": "python_java", "problem_id": 71, "prediction_id": 0, "pro_prediction": "public static int collectTheCoins(int[] coins, int[][] edges) {\n        int n = coins.length;\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            g.get(edge[0]).add(edge[1]);\n            g.get(edge[1]).add(edge[0]);\n        }\n        int[] deg = new int[n];\n        for (int i = 0; i < n; i++) {\n            deg[i] = g.get(i).size();\n        }\n        int leftEdges = n - 1;\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1 && coins[i] == 0) {\n                q.add(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            leftEdges--;\n            int node = q.poll();\n            for (int neighbor : g.get(node)) {\n                deg[neighbor]--;\n                if (deg[neighbor] == 1 && coins[neighbor] == 0) {\n                    q.add(neighbor);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1 && coins[i] > 0) {\n                q.add(i);\n            }\n        }\n        leftEdges -= q.size();\n        while (!q.isEmpty()) {\n            int node = q.poll();\n            for (int neighbor : g.get(node)) {\n                deg[neighbor]--;\n                if (deg[neighbor] == 1) {\n                    leftEdges--;\n                }\n            }\n        }\n        return Math.max(leftEdges * 2, 0);\n    }", "main_fun_name": "collectTheCoins", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Queue;\\nimport java.util.LinkedList;\\n\\npublic class CoinCollector {\\n\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        List<List<Integer>> g = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            g.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            g.get(edge[0]).add(edge[1]);\\n            g.get(edge[1]).add(edge[0]);\\n        }\\n        int[] deg = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            deg[i] = g.get(i).size();\\n        }\\n        int leftEdges = n - 1;\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (deg[i] == 1 && coins[i] == 0) {\\n                q.add(i);\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            leftEdges--;\\n            int node = q.poll();\\n            for (int neighbor : g.get(node)) {\\n                deg[neighbor]--;\\n                if (deg[neighbor] == 1 && coins[neighbor] == 0) {\\n                    q.add(neighbor);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (deg[i] == 1 && coins[i] > 0) {\\n                q.add(i);\\n            }\\n        }\\n        leftEdges -= q.size();\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            for (int neighbor : g.get(node)) {\\n                deg[neighbor]--;\\n                if (deg[neighbor] == 1) {\\n                    leftEdges--;\\n                }\\n            }\\n        }\\n        return Math.max(leftEdges * 2, 0);\\n    }\\n}\\n```\"", "sl_gold_code": "def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)  \n    deg = list(map(len, g))  \n    left_edges = n - 1      \n    q = []\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c == 0:  \n            q.append(i)\n    while q:\n        left_edges -= 1  \n        for y in g[q.pop()]:\n            deg[y] -= 1\n            if deg[y] == 1 and coins[y] == 0:  \n                q.append(y)\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c:  \n            q.append(i)\n    left_edges -= len(q)  \n    for x in q:  \n        for y in g[x]:\n            deg[y] -= 1\n            if deg[y] == 1:  \n                left_edges -= 1  \n    return max(left_edges * 2, 0)", "tl_gold_code": "public static int collectTheCoins(int[] coins, int[][] edges) {\n    int n = coins.length;\n    List<Integer> g[] = new ArrayList[n];\n    Arrays.setAll(g, e -> new ArrayList<>());\n    var deg = new int[n];\n    for (var e : edges) {\n        int x = e[0], y = e[1];\n        g[x].add(y);\n        g[y].add(x); \n        deg[x]++;\n        deg[y]++; \n    }\n    int leftEdges = n - 1; \n    var q = new ArrayDeque<Integer>();\n    for (int i = 0; i < n; i++) {\n        if (deg[i] == 1 && coins[i] == 0) { \n            q.add(i);\n        }\n    }\n    while (!q.isEmpty()) {\n        leftEdges--; \n        for (int y : g[q.poll()]) {\n            if (--deg[y] == 1 && coins[y] == 0) { \n                q.add(y);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (deg[i] == 1 && coins[i] == 1) { \n            q.add(i);\n        }\n    }\n    leftEdges -= q.size(); \n    for (int x : q) { \n        for (int y : g[x]) {\n            if (--deg[y] == 1) { \n                leftEdges--; \n            }\n        }\n    }\n    return Math.max(leftEdges * 2, 0);\n}"}
{"task": "python_java", "problem_id": 72, "prediction_id": 0, "pro_prediction": "public static List<List<Integer>> matrixRotation(List<List<Integer>> matrix, int r) {\n        int l = 0, br = matrix.size(), bc = matrix.get(0).size();\n        while (l < Math.min(br, bc) / 2) {\n            int rr = r % (2 * (br + bc - l * 4 - 2));\n            while (rr != 0) {\n                rr--;\n                int buf = matrix.get(l).get(l);\n                for (int j = l; j < bc - l - 1; j++) {\n                    matrix.get(l).set(j, matrix.get(l).get(j + 1));\n                }\n                for (int i = l; i < br - l - 1; i++) {\n                    matrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1));\n                }\n                for (int j = bc - l - 1; j > l; j--) {\n                    matrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1));\n                }\n                for (int i = br - l - 1; i > l; i--) {\n                    matrix.get(i).set(l, matrix.get(i - 1).get(l));\n                }\n                matrix.get(l + 1).set(l, buf);\n            }\n            l++;\n        }\n        return matrix;\n    }", "main_fun_name": "matrixRotation", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\nimport java.util.List;\\n\\npublic class MatrixRotation {\\n\\n    public static List<List<Integer>> matrixRotation(List<List<Integer>> matrix, int r) {\\n        int l = 0, br = matrix.size(), bc = matrix.get(0).size();\\n        while (l < Math.min(br, bc) / 2) {\\n            int rr = r % (2 * (br + bc - l * 4 - 2));\\n            while (rr != 0) {\\n                rr--;\\n                int buf = matrix.get(l).get(l);\\n                for (int j = l; j < bc - l - 1; j++) {\\n                    matrix.get(l).set(j, matrix.get(l).get(j + 1));\\n                }\\n                for (int i = l; i < br - l - 1; i++) {\\n                    matrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1));\\n                }\\n                for (int j = bc - l - 1; j > l; j--) {\\n                    matrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1));\\n                }\\n                for (int i = br - l - 1; i > l; i--) {\\n                    matrix.get(i).set(l, matrix.get(i - 1).get(l));\\n                }\\n                matrix.get(l + 1).set(l, buf);\\n            }\\n            l++;\\n        }\\n        return matrix;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Example usage:\\n        List<List<Integer>> matrix = List.of(\\n            List.of(1, 2, 3),\\n            List.of(4, 5, 6),\\n            List.of(7, 8, 9)\\n        );\\n        int r = 90;\\n        matrix = matrixRotation(matrix, r);\\n        // Print the rotated matrix\\n        for (List<Integer> row : matrix) {\\n            System.out.println(row);\\n        }\\n    }\\n}\\n```\\n\"", "sl_gold_code": "def matrixRotation(matrix, r):\n    l, br, bc = 0, len(matrix), len(matrix[0])\n    while l < min(br, bc) / 2:\n        rr = r % (2 * (br + bc - l * 4 - 2))\n        while (rr) != 0:\n            rr -= 1\n            buf = matrix[l][l]\n            for j in range(l, bc - l - 1):\n                matrix[l][j] = matrix[l][j + 1]\n            for i in range(l, br - l - 1):\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]\n            for j in range(bc - l - 1, l, -1):\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]\n            for i in range(br - l - 1, l + 1, -1):\n                matrix[i][l] = matrix[i - 1][l]\n            matrix[l + 1][l] = buf\n        l += 1\n    return matrix", "tl_gold_code": "public static List<List<Integer>> matrixRotation(List<List<Integer>> matrix, int r) {\n\tint l = 0;\n\tint br = matrix.size();\n\tint bc = matrix.get(0).size();\n\twhile (l < Math.min(br, bc) / 2) {\n\t\tint rr = r % (2 * (br + bc - 4 * l - 2));\n\t\twhile (rr-- > 0) {\n\t\t\tint buf = matrix.get(l).get(l);\n\t\t\tfor (int j = l; j < bc - l - 1; ++j) {\n\t\t\t\tmatrix.get(l).set(j, matrix.get(l).get(j + 1));\n\t\t\t}\n\t\t\tfor (int i = l; i < br - l - 1; ++i) {\n\t\t\t\tmatrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1));\n\t\t\t}\n\t\t\tfor (int j = bc - l - 1; j > l; --j) {\n\t\t\t\tmatrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1));\n\t\t\t}\n\t\t\tfor (int i = br - l - 1; i > l + 1; --i) {\n\t\t\t\tmatrix.get(i).set(l, matrix.get(i - 1).get(l));\n\t\t\t}\n\t\t\tmatrix.get(l + 1).set(l, buf);\n\t\t}\n\t\t++l;\n\t}\n\treturn matrix;\n}"}
{"task": "python_java", "problem_id": 73, "prediction_id": 0, "pro_prediction": "public static int divisorSubstrings(int num, int k) {\n    String s = Integer.toString(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; i++) {\n        int tmp = Integer.parseInt(s.substring(i, i + k));\n        if (tmp != 0 && num % tmp == 0) {\n            res++;\n        }\n    }\n    return res;\n}", "main_fun_name": "divisorSubstrings", "raw_prediction": "\"```java\\npublic int divisorSubstrings(int num, int k) {\\n    String s = Integer.toString(num);\\n    int n = s.length();\\n    int res = 0;\\n    for (int i = 0; i <= n - k; i++) {\\n        int tmp = Integer.parseInt(s.substring(i, i + k));\\n        if (tmp != 0 && num % tmp == 0) {\\n            res++;\\n        }\\n    }\\n    return res;\\n}\\n```\"", "sl_gold_code": "def divisorSubstrings(num: int, k: int) -> int:\n    s = str(num)\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        tmp = int(s[i:i+k])\n        if tmp != 0 and num % tmp == 0:\n            res += 1\n    return res", "tl_gold_code": "public static  int divisorSubstrings(int num, int k) {\n    String s = Integer.toString(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = Integer.parseInt(s.substring(i, i + k));\n        if (tmp != 0 && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}"}
{"task": "python_java", "problem_id": 74, "prediction_id": 0, "pro_prediction": "public static List<Integer> solve(List<Integer> a) {\n    List<Integer> result = new ArrayList<>();\n    int[] cum = new int[a.size()];\n    cum[0] = a.get(0);\n    for (int i = 1; i < a.size(); i++) {\n        cum[i] = cum[i - 1] + a.get(i);\n    }\n    int total = cum[cum.length - 1];\n    for (int i = 0; i < cum.length; i++) {\n        if (total % cum[i] == 0) {\n            int j = i + 1;\n            int segmentSum = 0;\n            while (j < a.size() && segmentSum < cum[i]) {\n                segmentSum += a.get(j);\n                if (segmentSum == cum[i]) {\n                    segmentSum = 0;\n                }\n                j++;\n            }\n            if (segmentSum == 0 && (j == a.size() || cum[i] == total)) {\n                result.add(cum[i]);\n            }\n        }\n    }\n    return result;\n}", "main_fun_name": "solve", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic List<Integer> solve(List<Integer> a) {\\n    List<Integer> result = new ArrayList<>();\\n    int[] cum = new int[a.size()];\\n    cum[0] = a.get(0);\\n    for (int i = 1; i < a.size(); i++) {\\n        cum[i] = cum[i - 1] + a.get(i);\\n    }\\n    int total = cum[cum.length - 1];\\n    for (int i = 0; i < cum.length; i++) {\\n        if (total % cum[i] == 0) {\\n            int j = i + 1;\\n            int segmentSum = 0;\\n            while (j < a.size() && segmentSum < cum[i]) {\\n                segmentSum += a.get(j);\\n                if (segmentSum == cum[i]) {\\n                    segmentSum = 0;\\n                }\\n                j++;\\n            }\\n            if (segmentSum == 0 && (j == a.size() || cum[i] == total)) {\\n                result.add(cum[i]);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\"", "sl_gold_code": "def solve(a):\n    result = []\n    cum = [0] * len(a)\n    cum[0] = a[0]\n    for i in range(1, len(a)):\n        cum[i] = cum[i-1] + a[i]\n    total = cum[-1]\n    for i in range(len(cum)):\n        if total % cum[i] == 0:\n            j = i + 1\n            segment_sum = 0\n            while j < len(a) and segment_sum < cum[i]:\n                segment_sum += a[j]\n                if segment_sum == cum[i]:\n                    segment_sum = 0\n                j += 1\n            if segment_sum == 0 and (j == len(a) or cum[i] == total):\n                result.append(cum[i])\n    return result", "tl_gold_code": "public static  List<Integer> solve(List<Integer> a) {\n    List<Integer> result = new ArrayList<>();\n    int[] cum = new int[a.size()];\n    cum[0] = a.get(0);\n    for (int i = 1; i < a.size(); i++) {\n        cum[i] = cum[i-1] + a.get(i);\n    }\n    for (int i = 0; i < cum.length+1/2; i++) {\n        if(cum[cum.length-1]%cum[i] == 0) {\n            int temp = 0;\n            for (int j = i+1; j < cum.length; j++) {\n                temp += a.get(j);\n                if (temp > cum[i]) break;\n                if (temp%cum[i] == 0) temp = 0; \n            }\n            if (temp == 0) result.add(cum[i]);\n        }\n    }\n    return result;\n}"}
{"task": "python_java", "problem_id": 75, "prediction_id": 0, "pro_prediction": "public static int maximumToys(int[] prices, int k) {\n    Arrays.sort(prices);\n    int toys = 0;\n    for (int i : prices) {\n        if (i <= k) {\n            k -= i;\n            toys++;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}", "main_fun_name": "maximumToys", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\n\\npublic int maximumToys(int[] prices, int k) {\\n    Arrays.sort(prices);\\n    int toys = 0;\\n    for (int i : prices) {\\n        if (i <= k) {\\n            k -= i;\\n            toys++;\\n        } else {\\n            break;\\n        }\\n    }\\n    return toys;\\n}\\n```\"", "sl_gold_code": "def maximumToys(prices, k):\n    prices = sorted(prices)\n    toys = 0\n    for i in prices:\n        if i <= k:\n            k = k - i\n            toys = toys + 1\n        else:\n            break\n    return toys", "tl_gold_code": "public static  int maximumToys(List<Integer> prices, int k) {\n    Collections.sort(prices);\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            toys++;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}"}
{"task": "python_java", "problem_id": 76, "prediction_id": 0, "pro_prediction": "public static int sumOfSquares(int[] nums) {\n    int ans = 0;\n    int n = nums.length;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}", "main_fun_name": "sumOfSquares", "raw_prediction": "\"```java\\npublic int sumOfSquares(int[] nums) {\\n    int ans = 0;\\n    int n = nums.length;\\n    for (int i = 1; i <= n; i++) {\\n        if (n % i == 0) {\\n            ans += nums[i - 1] * nums[i - 1];\\n        }\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def sumOfSquares(nums):\n    ans = 0\n    n = len(nums)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            ans += nums[i - 1] ** 2\n    return ans", "tl_gold_code": "public static int sumOfSquares(int[] nums) {\n    int ans = 0, n = nums.length;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 77, "prediction_id": 0, "pro_prediction": "public static boolean checkArray(int[] nums, int k) {\n    int n = nums.length;\n    int[] d = new int[n + 1];\n    int sum_d = 0;\n    for (int i = 0; i < n; i++) {\n        int x = nums[i];\n        sum_d += d[i];\n        x += sum_d;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sum_d -= x;\n        d[i + k] += x;\n    }\n    return true;\n}", "main_fun_name": "checkArray", "raw_prediction": "\"```java\\nboolean checkArray(int[] nums, int k) {\\n    int n = nums.length;\\n    int[] d = new int[n + 1];\\n    int sum_d = 0;\\n    for (int i = 0; i < n; i++) {\\n        int x = nums[i];\\n        sum_d += d[i];\\n        x += sum_d;\\n        if (x == 0) continue;\\n        if (x < 0 || i + k > n) return false;\\n        sum_d -= x;\\n        d[i + k] += x;\\n    }\\n    return true;\\n}\\n```\"", "sl_gold_code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    d = [0] * (n + 1)\n    sum_d = 0\n    for i, x in enumerate(nums):\n        sum_d += d[i]\n        x += sum_d\n        if x == 0: continue  \n        if x < 0 or i + k > n: return False  \n        sum_d -= x  \n        d[i + k] += x\n    return True", "tl_gold_code": "public static boolean checkArray(int[] nums, int k) {\n    int n = nums.length, sumD = 0;\n    var d = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        sumD += d[i];\n        int x = nums[i];\n        x += sumD;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sumD -= x;\n        d[i + k] += x;\n    }\n    return true;\n}"}
{"task": "python_java", "problem_id": 78, "prediction_id": 0, "pro_prediction": "public static int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    if (n == 1) {\n        return 1;\n    }\n    int[][] dp = new int[n][2];\n    for (int[] row : dp) {\n        Arrays.fill(row, 1);\n    }\n    int ans = 0;\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] >= nums1[i - 1]) {\n            dp[i][0] = Math.max(dp[i][0], dp[i - 1][0] + 1);\n        }\n        if (nums1[i] >= nums2[i - 1]) {\n            dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] + 1);\n        }\n        if (nums2[i] >= nums1[i - 1]) {\n            dp[i][1] = Math.max(dp[i][1], dp[i - 1][0] + 1);\n        }\n        if (nums2[i] >= nums2[i - 1]) {\n            dp[i][1] = Math.max(dp[i][1], dp[i - 1][1] + 1);\n        }\n        ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}", "main_fun_name": "maxNonDecreasingLength", "raw_prediction": "\"```java\\npublic int maxNonDecreasingLength(int[] nums1, int[] nums2) {\\n    int n = nums1.length;\\n    if (n == 1) {\\n        return 1;\\n    }\\n    int[][] dp = new int[n][2];\\n    for (int[] row : dp) {\\n        Arrays.fill(row, 1);\\n    }\\n    int ans = 0;\\n    for (int i = 1; i < n; i++) {\\n        if (nums1[i] >= nums1[i - 1]) {\\n            dp[i][0] = Math.max(dp[i][0], dp[i - 1][0] + 1);\\n        }\\n        if (nums1[i] >= nums2[i - 1]) {\\n            dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] + 1);\\n        }\\n        if (nums2[i] >= nums1[i - 1]) {\\n            dp[i][1] = Math.max(dp[i][1], dp[i - 1][0] + 1);\\n        }\\n        if (nums2[i] >= nums2[i - 1]) {\\n            dp[i][1] = Math.max(dp[i][1], dp[i - 1][1] + 1);\\n        }\\n        ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));\\n    }\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def maxNonDecreasingLength(nums1, nums2):\n    n = len(nums1)\n    if n == 1:\n        return 1\n    dp = [[1] * 2 for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        dp[i][0] = dp[i][1] = 1\n        if nums1[i] >= nums1[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][0] + 1)\n        if nums1[i] >= nums2[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\n        if nums2[i] >= nums1[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][0] + 1)\n        if nums2[i] >= nums2[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\n        ans = max(ans, max(dp[i][0], dp[i][1]))\n    return ans", "tl_gold_code": "public static int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    if (n == 1) return 1;\n    int[][] dp = new int[n][2];\n    dp[0][0] = dp[0][1] = 1;\n    int ans = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][1]+1);\n        ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 79, "prediction_id": 0, "pro_prediction": "public static int maximumJumps(int[] nums, int target) {\n    int n = nums.length;\n    int[] f = new int[n];\n    for (int i = 0; i < n; i++) {\n        f[i] = Integer.MIN_VALUE;\n    }\n    f[0] = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (Math.abs(nums[i] - nums[j]) <= target) {\n                f[i] = Math.max(f[i], f[j] + 1);\n            }\n        }\n    }\n    return f[n - 1] < 0 ? -1 : f[n - 1];\n}", "main_fun_name": "maximumJumps", "raw_prediction": "\"```java\\npublic int maximumJumps(int[] nums, int target) {\\n    int n = nums.length;\\n    int[] f = new int[n];\\n    for (int i = 0; i < n; i++) {\\n        f[i] = Integer.MIN_VALUE;\\n    }\\n    f[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (Math.abs(nums[i] - nums[j]) <= target) {\\n                f[i] = Math.max(f[i], f[j] + 1);\\n            }\\n        }\\n    }\\n    return f[n - 1] < 0 ? -1 : f[n - 1];\\n}\\n```\"", "sl_gold_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-inf] * n\n    f[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= target:\n                f[i] = max(f[i], f[j] + 1)\n    return -1 if f[-1] < 0 else f[-1]", "tl_gold_code": "public static int maximumJumps(int[] nums, int target) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, -1);\n    dp[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (Math.abs(nums[i] - nums[j]) <= target && dp[j] != -1) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return dp[n - 1];\n}"}
{"task": "python_java", "problem_id": 80, "prediction_id": 0, "pro_prediction": "public static int theMaximumAchievableX(int num, int t) {\n    return num + t * 2;\n}", "main_fun_name": "theMaximumAchievableX", "raw_prediction": "\"```java\\npublic int theMaximumAchievableX(int num, int t) {\\n    return num + t * 2;\\n}\\n```\"", "sl_gold_code": "def theMaximumAchievableX(num: int, t: int) -> int:\n        return num + t * 2", "tl_gold_code": "public static int theMaximumAchievableX(int num, int t) {\n    return num + (t << 1);\n}"}
{"task": "python_java", "problem_id": 81, "prediction_id": 0, "pro_prediction": "public static long[] countBlackBlocks(int m, int n, int[][] coordinates) {\n    long[] ans = new long[5];\n    long sum_blocks = (m - 1) * (n - 1);\n    Set<Integer> st = new HashSet<>();\n    for (int[] coord : coordinates) {\n        st.add(coord[0] * n + coord[1]);\n    }\n    int[][] arr = {\n        {0, -1}, {0, 1},\n        {-1, -1}, {-1, 0},\n        {-1, 1}, {0, -1},\n        {1, 0}, {1, -1},\n        {1, 1}, {0, 1}\n    };\n    for (int[] coord : coordinates) {\n        for (int[] a : arr) {\n            int cnt = 1;\n            for (int[] dir : a) {\n                int nx = coord[0] + dir[0];\n                int ny = coord[1] + dir[1];\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if (st.contains(nx * n + ny)) {\n                    cnt++;\n                }\n            }\n            ans[cnt]++;\n        }\n    }\n    for (int i = 2; i < 5; i++) {\n        ans[i] /= i;\n    }\n    ans[0] = sum_blocks - sum(ans, 1, 4);\n    return ans;\n}", "main_fun_name": "countBlackBlocks", "raw_prediction": "\"```java\\npublic long[] countBlackBlocks(int m, int n, int[][] coordinates) {\\n    long[] ans = new long[5];\\n    long sum_blocks = (m - 1) * (n - 1);\\n    Set<Integer> st = new HashSet<>();\\n    for (int[] coord : coordinates) {\\n        st.add(coord[0] * n + coord[1]);\\n    }\\n    int[][] arr = {\\n        {0, -1}, {0, 1},\\n        {-1, -1}, {-1, 0},\\n        {-1, 1}, {0, -1},\\n        {1, 0}, {1, -1},\\n        {1, 1}, {0, 1}\\n    };\\n    for (int[] coord : coordinates) {\\n        for (int[] a : arr) {\\n            int cnt = 1;\\n            for (int[] dir : a) {\\n                int nx = coord[0] + dir[0];\\n                int ny = coord[1] + dir[1];\\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n) {\\n                    cnt = 0;\\n                    break;\\n                }\\n                if (st.contains(nx * n + ny)) {\\n                    cnt++;\\n                }\\n            }\\n            ans[cnt]++;\\n        }\\n    }\\n    for (int i = 2; i < 5; i++) {\\n        ans[i] /= i;\\n    }\\n    ans[0] = sum_blocks - sum(ans, 1, 4);\\n    return ans;\\n}\\n```\"", "sl_gold_code": "def countBlackBlocks(m, n, coordinates):\n    ans = [0] * 5\n    sum_blocks = (m - 1) * (n - 1)\n    st = set((x * n + y) for x, y in coordinates)\n    arr = [\n        [(0, -1), (-1, -1), (-1, 0)],\n        [(0, 1), (-1, 0), (-1, 1)],\n        [(0, -1), (1, 0), (1, -1)],\n        [(0, 1), (1, 0), (1, 1)]\n    ]\n    for x, y in coordinates:\n        for a in arr:\n            cnt = 1\n            for dx, dy in a:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or ny < 0 or nx >= m or ny >= n:\n                    cnt = 0\n                    break\n                if (nx * n + ny) in st:\n                    cnt += 1\n            ans[cnt] += 1\n    for i in range(2, 5):\n        ans[i] //= i\n    ans[0] = sum_blocks - sum(ans[1:])\n    return ans", "tl_gold_code": "public static long[] countBlackBlocks(int m, int n, int[][] coordinates) {\n    List<Long> ansList = new ArrayList<>(Collections.nCopies(5, 0L));\n    long sum = (long) (m - 1) * (n - 1);\n    Set<Long> st = new HashSet<>();\n    int num = coordinates.length;\n    for (int i = 0; i < num; i++)\n        st.add((long) coordinates[i][0] * n + coordinates[i][1]);\n    int[][][] arr = {\n        {{0, -1}, {-1, -1}, {-1, 0}},\n        {{0, 1}, {-1, 0}, {-1, 1}},\n        {{0, -1}, {1, 0}, {1, -1}},\n        {{0, 1}, {1, 0}, {1, 1}}\n    };\n    for (int i = 0; i < num; i++) {\n        long x = coordinates[i][0], y = coordinates[i][1];\n        for (int[][] a : arr) {\n            int cnt = 1;\n            for (int[] direction : a) {\n                long nx = x + direction[0], ny = y + direction[1];\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if (st.contains(nx * n + ny)) cnt++;\n            }\n            ansList.set(cnt, ansList.get(cnt) + 1);\n        }\n    }\n    for (int i = 2; i <= 4; i++) ansList.set(i, ansList.get(i) / i);\n    ansList.set(0, sum - ansList.get(1) - ansList.get(2) - ansList.get(3) - ansList.get(4));\n    long[] ans = ansList.stream().mapToLong(Long::longValue).toArray();\n    return ans;\n}"}
{"task": "python_java", "problem_id": 82, "prediction_id": 0, "pro_prediction": "public static int minimumBeautifulSubstrings(String s) {\n        if (s.charAt(0) == '0') {\n            return -1;\n        }\n        int n = s.length();\n        double[] f = new double[n + 10];\n        Arrays.fill(f, Double.POSITIVE_INFINITY);\n        f[0] = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                String currentSubstring = s.substring(i, j + 1);\n                if (beautifulStrings.contains(currentSubstring)) {\n                    f[j + 1] = Math.min(f[j + 1], f[i] + 1);\n                }\n            }\n        }\n        return f[n] == Double.POSITIVE_INFINITY ? -1 : (int) f[n];\n    }", "main_fun_name": "minimumBeautifulSubstrings", "raw_prediction": "\"```java\\npublic class Solution {\\n    private static final Set<String> beautifulStrings = new HashSet<>(Arrays.asList(\\\"1\\\", \\\"101\\\", \\\"11001\\\", \\\"1111101\\\", \\\"1001110001\\\", \\\"110000110101\\\", \\\"11110100001001\\\"));\\n\\n    public int minimumBeautifulSubstrings(String s) {\\n        if (s.charAt(0) == '0') {\\n            return -1;\\n        }\\n        int n = s.length();\\n        double[] f = new double[n + 10];\\n        Arrays.fill(f, Double.POSITIVE_INFINITY);\\n        f[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                String currentSubstring = s.substring(i, j + 1);\\n                if (beautifulStrings.contains(currentSubstring)) {\\n                    f[j + 1] = Math.min(f[j + 1], f[i] + 1);\\n                }\\n            }\\n        }\\n        return f[n] == Double.POSITIVE_INFINITY ? -1 : (int) f[n];\\n    }\\n}\\n```\"", "sl_gold_code": "def minimumBeautifulSubstrings(s):\n    if s[0] == '0':\n        return -1\n    beautiful_strings = {\"1\", \"101\", \"11001\", \"1111101\", \"1001110001\", \"110000110101\", \"11110100001001\"}\n    n = len(s)\n    f = [float('inf')] * (n + 10)\n    f[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            current_substring = s[i:j+1]\n            if current_substring in beautiful_strings:\n                f[j+1] = min(f[j+1], f[i] + 1)\n    if f[n] == float('inf'):\n        return -1\n    return f[n]", "tl_gold_code": "public static  int minimumBeautifulSubstrings(String s) {\n    final String[] fivePowersBinary = {\n        \"1\", \"101\", \"11001\", \"1111101\",\n        \"1001110001\", \"110000110101\", \"11110100001001\"\n    };\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[n] = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i] = 16;\n        if (s.charAt(i) == '0') continue;\n        for (String bin : fivePowersBinary) {\n            if (i + bin.length() > n) break;\n            if (s.substring(i, i + bin.length()).equals(bin)) {\n                dp[i] = Math.min(dp[i], dp[i + bin.length()] + 1);\n            }\n        }\n    }\n    return dp[0] > n ? -1 : dp[0];\n}"}
{"task": "python_java", "problem_id": 83, "prediction_id": 0, "pro_prediction": "public static int gcdAndLcm(int x, int y) {\n        int n = x * y;\n        int ans = 0;\n        for (int i = x; i <= y; i++) {\n            if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n\npublic static int gcd(int x, int y) {\n        if (x < y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        int r = x % y;\n        while (r != 0) {\n            int temp = x;\n            x = y;\n            y = r;\n            r = temp % y;\n        }\n        return y;\n    }\n\npublic static int lcm(int x, int y) {\n        if (x < y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        int m = x;\n        while (x % y != 0) {\n            x += m;\n        }\n        return x;\n    }", "main_fun_name": "gcdAndLcm", "raw_prediction": "\"Here is the translated Java code for the provided Python functions:\\n\\n```java\\npublic class Main {\\n    public static void main(String[] args) {\\n        int x = 12;\\n        int y = 18;\\n        System.out.println(gcdAndLcm(x, y)); // Example usage\\n    }\\n\\n    public static int gcdAndLcm(int x, int y) {\\n        int n = x * y;\\n        int ans = 0;\\n        for (int i = x; i <= y; i++) {\\n            if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static int gcd(int x, int y) {\\n        if (x < y) {\\n            int temp = x;\\n            x = y;\\n            y = temp;\\n        }\\n        int r = x % y;\\n        while (r != 0) {\\n            int temp = x;\\n            x = y;\\n            y = r;\\n            r = temp % y;\\n        }\\n        return y;\\n    }\\n\\n    public static int lcm(int x, int y) {\\n        if (x < y) {\\n            int temp = x;\\n            x = y;\\n            y = temp;\\n        }\\n        int m = x;\\n        while (x % y != 0) {\\n            x += m;\\n        }\\n        return x;\\n    }\\n}\\n```\"", "sl_gold_code": "def gcdAndLcm(x: int, y: int) -> int:\n    n = x * y\n    ans = 0\n    for i in range(x,y+1):\n        if n % i == 0 and gcd(i, n // i) == x and lcm(i, n // i) == y:\n            ans += 1\n    return ans\ndef gcd(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    r = x % y  \n    while r != 0:\n        x = y\n        y = r\n        r = x % y\n    return y\ndef lcm(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    m = x\n    while x % y != 0:\n        x = x+m\n    return x", "tl_gold_code": "public static int gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; i++) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans++;\n        }\n    }\n    return ans;\n}\npublic static int gcd(int x, int y) {\n    if (x < y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n    int r = x % y;\n    while (r != 0) {\n        x = y;\n        y = r;\n        r = x % y;\n    }\n    return y;\n}\npublic static int lcm(int x, int y) {\n    if (x < y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n    int m = x;\n    while (x % y != 0) {\n        x += m;\n    }\n    return x;\n}"}
{"task": "python_java", "problem_id": 84, "prediction_id": 0, "pro_prediction": "public static int findFirstPairExceedingSum(List<List<Integer>> pairs) {\n    int max_sum = 0;\n    int day_index = 0;\n    for (int i = 1; i < pairs.size(); i++) {\n        int a = pairs.get(i).get(0);\n        int b = pairs.get(i).get(1);\n        int sum = a + b;\n        if (sum > 8 && sum > max_sum) {\n            max_sum = sum;\n            day_index = i;\n        }\n    }\n    return day_index;\n}", "main_fun_name": "findFirstPairExceedingSum", "raw_prediction": "\"```java\\npublic int findFirstPairExceedingSum(List<List<Integer>> pairs) {\\n    int max_sum = 0;\\n    int day_index = 0;\\n    for (int i = 1; i < pairs.size(); i++) {\\n        int a = pairs.get(i).get(0);\\n        int b = pairs.get(i).get(1);\\n        int sum = a + b;\\n        if (sum > 8 && sum > max_sum) {\\n            max_sum = sum;\\n            day_index = i;\\n        }\\n    }\\n    return day_index;\\n}\\n```\"", "sl_gold_code": "def findFirstPairExceedingSum(pairs: List[List[int]]) -> int:\n    max_sum = 0\n    day_index = 0\n    for i, pair in enumerate(pairs, start=1):\n        a = pair[0]\n        b = pair[1]\n        sum = a + b\n        if sum > 8 and sum > max_sum:\n            max_sum = sum\n            day_index = i\n    return day_index", "tl_gold_code": "public static int findFirstPairExceedingSum(List<List<Integer>> pairs) {\n\tint maxSum = 0;\n\tint dayIndex = 0;\n\tfor (int i = 0; i < pairs.size(); i++) {\n\t\tList<Integer> pair = pairs.get(i);\n\t\tint a = pair.get(0);\n\t\tint b = pair.get(1);\n\t\tint sum = a + b;\n\t\tif (sum > 8 && sum > maxSum) {\n\t\t\tmaxSum = sum;\n\t\t\tdayIndex = i + 1;\n\t\t}\n\t}\n\treturn dayIndex;\n}"}
{"task": "python_java", "problem_id": 85, "prediction_id": 0, "pro_prediction": "public static int maximumValue(String[] strs) {\n    int res = 0;\n    for (String s : strs) {\n        boolean isDigits = s.matches(\"\\\\\\\\d+\");\n        res = Math.max(res, isDigits ? Integer.parseInt(s) : s.length());\n    }\n    return res;\n}", "main_fun_name": "maximumValue", "raw_prediction": "\"```java\\npublic int maximumValue(String[] strs) {\\n    int res = 0;\\n    for (String s : strs) {\\n        boolean isDigits = s.matches(\\\"\\\\\\\\d+\\\");\\n        res = Math.max(res, isDigits ? Integer.parseInt(s) : s.length());\\n    }\\n    return res;\\n}\\n```\"", "sl_gold_code": "def maximumValue(strs: List[str]) -> int:\n    res = 0\n    for s in strs:\n        is_digits = all(c.isdigit() for c in s)\n        res = max(res, int(s) if is_digits else len(s))\n    return res", "tl_gold_code": "public static int maximumValue(String[] strs) {\n    int res = 0;\n    for (String s : strs) {\n        boolean isDigits = true;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            isDigits &= Character.isDigit(s.charAt(i));\n        }\n        res = Math.max(res, isDigits ? Integer.parseInt(s) : n);\n    }\n    return res;\n}"}
{"task": "python_java", "problem_id": 86, "prediction_id": 0, "pro_prediction": "public static int countBeautifulPairs(int[] nums) {\n        int ans = 0;\n        int[] cnt = new int[10];\n        for (int x : nums) {\n            for (int y = 1; y < 10; y++) {\n                if (cnt[y] > 0 && gcd(x % 10, y) == 1) {\n                    ans += cnt[y];\n                }\n            }\n            while (x >= 10) {\n                x /= 10;\n            }\n            cnt[x]++;\n        }\n        return ans;\n    }\n\npublic static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }", "main_fun_name": "countBeautifulPairs", "raw_prediction": "\"```java\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int countBeautifulPairs(int[] nums) {\\n        int ans = 0;\\n        int[] cnt = new int[10];\\n        for (int x : nums) {\\n            for (int y = 1; y < 10; y++) {\\n                if (cnt[y] > 0 && gcd(x % 10, y) == 1) {\\n                    ans += cnt[y];\\n                }\\n            }\\n            while (x >= 10) {\\n                x /= 10;\\n            }\\n            cnt[x]++;\\n        }\\n        return ans;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n}\\n```\"", "sl_gold_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    ans, cnt = 0, [0] * 10\n    for x in nums:\n        for y in range(1, 10):\n            if cnt[y] and gcd(x % 10, y) == 1:\n                ans += cnt[y]\n        while x >= 10: x //= 10\n        cnt[x] += 1\n    return ans", "tl_gold_code": "public static int countBeautifulPairs(int[] nums) {\n    int ans = 0;\n    var cnt = new int[10];\n    for (int x : nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] > 0 && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}\nprivate static int gcd(int a, int b) {\n    while (a != 0) {\n        int tmp = a;\n        a = b % a;\n        b = tmp;\n    }\n    return b;\n}"}
{"task": "python_java", "problem_id": 87, "prediction_id": 0, "pro_prediction": "public static int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        Arrays.sort(logs, Comparator.comparingInt(a -> a[1]));\n        int[] ans = new int[queries.length];\n        int[] cnt = new int[n + 1];\n        int outOfRange = n;\n        int left = 0, right = 0;\n        \n        for (int i = 0; i < queries.length; i++) {\n            int qi = i;\n            int q = queries[i];\n            \n            while (right < logs.length && logs[right][1] <= q) {\n                int i = logs[right][0];\n                if (cnt[i] == 0) {\n                    outOfRange--;\n                }\n                cnt[i]++;\n                right++;\n            }\n            \n            while (left < logs.length && logs[left][1] < q - x) {\n                int i = logs[left][0];\n                cnt[i]--;\n                if (cnt[i] == 0) {\n                    outOfRange++;\n                }\n                left++;\n            }\n            \n            ans[qi] = outOfRange;\n        }\n        \n        return ans;\n    }", "main_fun_name": "countServers", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\\n        Arrays.sort(logs, Comparator.comparingInt(a -> a[1]));\\n        int[] ans = new int[queries.length];\\n        int[] cnt = new int[n + 1];\\n        int outOfRange = n;\\n        int left = 0, right = 0;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            int qi = i;\\n            int q = queries[i];\\n            \\n            while (right < logs.length && logs[right][1] <= q) {\\n                int i = logs[right][0];\\n                if (cnt[i] == 0) {\\n                    outOfRange--;\\n                }\\n                cnt[i]++;\\n                right++;\\n            }\\n            \\n            while (left < logs.length && logs[left][1] < q - x) {\\n                int i = logs[left][0];\\n                cnt[i]--;\\n                if (cnt[i] == 0) {\\n                    outOfRange++;\\n                }\\n                left++;\\n            }\\n            \\n            ans[qi] = outOfRange;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def countServers(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    logs.sort(key=lambda p: p[1])  \n    ans = [0] * len(queries)\n    cnt = [0] * (n + 1)\n    out_of_range = n\n    left = right = 0\n    for qi, q in sorted(enumerate(queries), key=lambda p: p[1]):\n        while right < len(logs) and logs[right][1] <= q:  \n            i = logs[right][0]\n            if cnt[i] == 0: out_of_range -= 1\n            cnt[i] += 1\n            right += 1\n        while left < len(logs) and logs[left][1] < q - x:  \n            i = logs[left][0]\n            cnt[i] -= 1\n            if cnt[i] == 0: out_of_range += 1\n            left += 1\n        ans[qi] = out_of_range\n    return ans", "tl_gold_code": "public static int[] countServers(int n, int[][] logs, int x, int[] queries) {\n    int nq = queries.length;\n    var id = new Integer[nq];\n    for (int i = 0; i < nq; i++) id[i] = i;\n    Arrays.sort(id, (i, j) -> queries[i] - queries[j]);\n    Arrays.sort(logs, (a, b) -> a[1] - b[1]);\n    int[] ans = new int[nq], cnt = new int[n + 1];\n    int outOfRange = n, left = 0, right = 0;\n    for (int i : id) {\n        while (right < logs.length && logs[right][1] <= queries[i])\n            if (cnt[logs[right++][0]]++ == 0)\n                outOfRange--;\n        while (left < logs.length && logs[left][1] < queries[i] - x)\n            if (--cnt[logs[left++][0]] == 0)\n                outOfRange++;\n        ans[i] = outOfRange;\n    }\n    return ans;\n}"}
{"task": "python_java", "problem_id": 88, "prediction_id": 0, "pro_prediction": "public static boolean isPossible(int n, List<List<Integer>> edges) {\n        Map<Integer, Set<Integer>> g = new HashMap<>();\n        for (List<Integer> edge : edges) {\n            int x = edge.get(0);\n            int y = edge.get(1);\n            g.computeIfAbsent(x, k -> new HashSet<>()).add(y);\n            g.computeIfAbsent(y, k -> new HashSet<>()).add(x);\n        }\n        List<Integer> odd = new ArrayList<>();\n        for (Map.Entry<Integer, Set<Integer>> entry : g.entrySet()) {\n            if (entry.getValue().size() % 2 != 0) {\n                odd.add(entry.getKey());\n            }\n        }\n        int m = odd.size();\n        if (m == 0) {\n            return true;\n        }\n        if (m == 2) {\n            int x = odd.get(0);\n            int y = odd.get(1);\n            return !g.get(y).contains(x) || any(i != x && i != y && !g.get(i).contains(x) && !g.get(i).contains(y), 1, n + 1);\n        }\n        if (m == 4) {\n            int a = odd.get(0);\n            int b = odd.get(1);\n            int c = odd.get(2);\n            int d = odd.get(3);\n            return (!g.get(b).contains(a) && !g.get(d).contains(c)) || (!g.get(c).contains(a) && !g.get(d).contains(b)) || (!g.get(d).contains(a) && !g.get(c).contains(b));\n        }\n        return false;\n    }", "main_fun_name": "isPossible", "raw_prediction": "\"```java\\nimport java.util.*;\\n\\npublic class GraphCheck {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (List<Integer> edge : edges) {\\n            int x = edge.get(0);\\n            int y = edge.get(1);\\n            g.computeIfAbsent(x, k -> new HashSet<>()).add(y);\\n            g.computeIfAbsent(y, k -> new HashSet<>()).add(x);\\n        }\\n        List<Integer> odd = new ArrayList<>();\\n        for (Map.Entry<Integer, Set<Integer>> entry : g.entrySet()) {\\n            if (entry.getValue().size() % 2 != 0) {\\n                odd.add(entry.getKey());\\n            }\\n        }\\n        int m = odd.size();\\n        if (m == 0) {\\n            return true;\\n        }\\n        if (m == 2) {\\n            int x = odd.get(0);\\n            int y = odd.get(1);\\n            return !g.get(y).contains(x) || any(i != x && i != y && !g.get(i).contains(x) && !g.get(i).contains(y), 1, n + 1);\\n        }\\n        if (m == 4) {\\n            int a = odd.get(0);\\n            int b = odd.get(1);\\n            int c = odd.get(2);\\n            int d = odd.get(3);\\n            return (!g.get(b).contains(a) && !g.get(d).contains(c)) || (!g.get(c).contains(a) && !g.get(d).contains(b)) || (!g.get(d).contains(a) && !g.get(c).contains(b));\\n        }\\n        return false;\\n    }\\n}\\n```\"", "sl_gold_code": "def isPossible(n: int, edges: List[List[int]]) -> bool:\n    g = defaultdict(set)\n    for x, y in edges:\n        g[x].add(y)\n        g[y].add(x)\n    odd = [i for i, nb in g.items() if len(nb) % 2]\n    m = len(odd)\n    if m == 0: return True\n    if m == 2:\n        x, y = odd\n        return x not in g[y] or any(\n            i != x and i != y and x not in g[i] and y not in g[i]\n            for i in range(1, n + 1))\n    if m == 4:\n        a, b, c, d = odd\n        return b not in g[a] and d not in g[c] or \\\n                c not in g[a] and d not in g[b] or \\\n                d not in g[a] and c not in g[b]\n    return False", "tl_gold_code": "public static boolean isPossible(int n, List<List<Integer>> edges) {\n    var g = new Set[n + 1];\n    Arrays.setAll(g, e -> new HashSet<Integer>());\n    for (var e : edges) {\n        int x = e.get(0), y = e.get(1);\n        g[x].add(y);\n        g[y].add(x);\n    }\n    var odd = new ArrayList<Integer>();\n    for (var i = 1; i <= n; ++i)\n        if (g[i].size() % 2 > 0) odd.add(i);\n    var m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd.get(0), y = odd.get(1);\n        if (!g[x].contains(y)) return true;\n        for (var i = 1; i <= n; ++i)\n            if (i != x && i != y && !g[i].contains(x) && !g[i].contains(y))\n                return true;\n        return false;\n    }\n    if (m == 4) {\n        int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3);\n        return !g[a].contains(b) && !g[c].contains(d) ||\n                !g[a].contains(c) && !g[b].contains(d) ||\n                !g[a].contains(d) && !g[b].contains(c);\n    }\n    return false;\n}"}
{"task": "python_java", "problem_id": 89, "prediction_id": 0, "pro_prediction": "public static int minExtraChar(String s, String[] dictionary) {\n        Set<String> d = new HashSet<>();\n        for (String word : dictionary) {\n            d.add(word);\n        }\n        int n = s.length();\n        int[] f = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            f[i + 1] = f[i] + 1;\n            for (int j = 0; j <= i; j++) {\n                if (s.substring(j, i + 1).equals(d)) {\n                    f[i + 1] = Math.min(f[i + 1], f[j]);\n                }\n            }\n        }\n        return f[n];\n    }", "main_fun_name": "minExtraChar", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Set;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        String s = \\\"leetcode\\\";\\n        String[] dictionary = {\\\"leet\\\", \\\"code\\\"};\\n        System.out.println(minExtraChar(s, dictionary)); // Output: 2\\n    }\\n\\n    public static int minExtraChar(String s, String[] dictionary) {\\n        Set<String> d = new HashSet<>();\\n        for (String word : dictionary) {\\n            d.add(word);\\n        }\\n        int n = s.length();\\n        int[] f = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            f[i + 1] = f[i] + 1;\\n            for (int j = 0; j <= i; j++) {\\n                if (s.substring(j, i + 1).equals(d)) {\\n                    f[i + 1] = Math.min(f[i + 1], f[j]);\\n                }\\n            }\\n        }\\n        return f[n];\\n    }\\n}\\n```\"", "sl_gold_code": "def minExtraChar(s: str, dictionary: List[str]) -> int:\n    d = set(dictionary)\n    n = len(s)\n    f = [0] * (n + 1)\n    for i in range(n):\n        f[i + 1] = f[i] + 1  \n        for j in range(i + 1):  \n            if s[j:i + 1] in d:\n                f[i + 1] = min(f[i + 1], f[j])\n    return f[n]", "tl_gold_code": "public static int minExtraChar(String s, String[] dictionary) {\n    var set = new HashSet<String>(dictionary.length);\n    for (var str : dictionary) set.add(str);\n    int n = s.length();\n    var f = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j < i+1; j++) {\n            if (set.contains(s.substring(j, i + 1))) {\n                f[i + 1] = Math.min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}"}
{"task": "python_java", "problem_id": 90, "prediction_id": 0, "pro_prediction": "public static int maximumPoints(int[][] edges, int[] coins, int k) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int coin : coins) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        return dfs(0, -1, g, coins, k)[0];\n    }\n\npublic static int[] dfs(int x, int fa, List<List<Integer>> g, int[] coins, int k) {\n        int[] res1 = new int[14];\n        int[] res2 = new int[14];\n        for (int y : g.get(x)) {\n            if (y == fa) {\n                continue;\n            }\n            int[] r = dfs(y, x, g, coins, k);\n            for (int j = 0; j < 14; j++) {\n                res1[j] += r[j];\n                if (j < 13) {\n                    res2[j] += r[j + 1];\n                }\n            }\n        }\n        for (int j = 0; j < 14; j++) {\n            res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n        }\n        return res1;\n    }", "main_fun_name": "maximumPoints", "raw_prediction": "\"Here is the translated Java code for the provided Python function:\\n\\n```java\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Solution {\\n    public int maximumPoints(int[][] edges, int[] coins, int k) {\\n        List<List<Integer>> g = new ArrayList<>();\\n        for (int coin : coins) {\\n            g.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            g.get(x).add(y);\\n            g.get(y).add(x);\\n        }\\n        return dfs(0, -1, g, coins, k)[0];\\n    }\\n\\n    private int[] dfs(int x, int fa, List<List<Integer>> g, int[] coins, int k) {\\n        int[] res1 = new int[14];\\n        int[] res2 = new int[14];\\n        for (int y : g.get(x)) {\\n            if (y == fa) {\\n                continue;\\n            }\\n            int[] r = dfs(y, x, g, coins, k);\\n            for (int j = 0; j < 14; j++) {\\n                res1[j] += r[j];\\n                if (j < 13) {\\n                    res2[j] += r[j + 1];\\n                }\\n            }\\n        }\\n        for (int j = 0; j < 14; j++) {\\n            res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\\n        }\\n        return res1;\\n    }\\n}\\n```\\n\\nPlease note that in Java, we use `int[]` to represent arrays, and `List<Integer>` to represent lists of integers. The `dfs` function returns an array of integers, which is the same as the Python list. The code assumes that the `coins` array and the `edges` 2D array are properly initialized and passed as arguments to the `maximumPoints` function.\"", "sl_gold_code": "def maximumPoints(edges: List[List[int]], coins: List[int], k: int) -> int:\n    g = [[] for _ in coins]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    return dfs(0, -1, g, coins, k)[0]\ndef dfs(x: int, fa: int, g, coins, k) -> List[int]:\n    res1 = [0] * 14\n    res2 = [0] * 14\n    for y in g[x]:\n        if y == fa: continue\n        r = dfs(y, x, g, coins, k)\n        for j, v in enumerate(r):\n            res1[j] += v\n            if j < 13:\n                res2[j] += r[j + 1]\n    for j, (r1, r2) in enumerate(zip(res1, res2)):\n        res1[j] = max(r1 + (coins[x] >> j) - k, r2 + (coins[x] >> (j + 1)))\n    return res1", "tl_gold_code": "public static int maximumPoints(int[][] edges, int[] coins, int k) {\n    List<Integer>[] g = new ArrayList[coins.length];\n    Arrays.setAll(g, e -> new ArrayList<>());\n    for (int[] e : edges) {\n        int x = e[0], y = e[1];\n        g[x].add(y);\n        g[y].add(x);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\nprivate static int[] dfs(int x, int fa, List<Integer>[] g, int[] coins, int k) {\n    int[] res1 = new int[14];\n    int[] res2 = new int[14];\n    for (int y : g[x]) {\n        if (y == fa) continue;\n        int[] r = dfs(y, x, g, coins, k);\n        for (int j = 0; j < r.length; j++) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (int j = 0; j < res1.length; j++) {\n        res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}"}
{"task": "python_java", "problem_id": 91, "prediction_id": 0, "pro_prediction": "public static int countCompleteComponents(int n, int[][] edges) {\n        this.graph = new ArrayList<>();\n        this.visited = new ArrayList<>(Arrays.asList(false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false));\n        this.counts = new ArrayList<>(Arrays.asList(0, 0));\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (!visited.get(i)) {\n                dfs(i, graph, visited, counts);\n                int v = counts.get(0);\n                int e = counts.get(1);\n                ans += e == v * (v - 1) ? 1 : 0;\n            }\n        }\n        \n        return ans;\n    }\n\npublic static void dfs(int x, List<List<Integer>> graph, List<Boolean> visited, List<Integer> counts) {\n        visited.set(x, true);\n        counts.set(0, counts.get(0) + 1);\n        counts.set(1, counts.get(1) + graph.get(x).size());\n        for (int y : graph.get(x)) {\n            if (!visited.get(y)) {\n                dfs(y, graph, visited, counts);\n            }\n        }\n    }", "main_fun_name": "countCompleteComponents", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class Solution {\\n    private List<List<Integer>> graph;\\n    private List<Boolean> visited;\\n    private List<Integer> counts;\\n    \\n    public void dfs(int x, List<List<Integer>> graph, List<Boolean> visited, List<Integer> counts) {\\n        visited.set(x, true);\\n        counts.set(0, counts.get(0) + 1);\\n        counts.set(1, counts.get(1) + graph.get(x).size());\\n        for (int y : graph.get(x)) {\\n            if (!visited.get(y)) {\\n                dfs(y, graph, visited, counts);\\n            }\\n        }\\n    }\\n    \\n    public int countCompleteComponents(int n, int[][] edges) {\\n        this.graph = new ArrayList<>();\\n        this.visited = new ArrayList<>(Arrays.asList(false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false));\\n        this.counts = new ArrayList<>(Arrays.asList(0, 0));\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited.get(i)) {\\n                dfs(i, graph, visited, counts);\\n                int v = counts.get(0);\\n                int e = counts.get(1);\\n                ans += e == v * (v - 1) ? 1 : 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\"", "sl_gold_code": "def dfs(x: int, g: List[List[int]], vis: List[bool], counts: List[int]) -> None:\n    vis[x] = True\n    counts[0] += 1\n    counts[1] += len(g[x])\n    for y in g[x]:\n        if not vis[y]:\n            dfs(y, g, vis, counts)\ndef countCompleteComponents(n: int, edges: List[List[int]]) -> int:\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    vis = [False] * n\n    ans = 0\n    for i in range(n):\n        if not vis[i]:\n            counts = [0, 0]\n            dfs(i, g, vis, counts)\n            v, e = counts\n            ans += e == v * (v - 1)\n    return ans", "tl_gold_code": "public static int countCompleteComponents(int n, int[][] edges) {\n    List<Integer>[] list = new ArrayList[n];\n    for (int i = 0; i < list.length; i++) {\n        list[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < edges.length; i++) {\n        list[edges[i][0]].add(edges[i][1]);\n        list[edges[i][1]].add(edges[i][0]);\n    }\n    int ans = 0;\n    boolean[] visited = new boolean[n];\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            int[] v = new int[1];\n            int[] e = new int[1];\n            dfs(list, visited, v, e, i);\n            if (v[0] * (v[0] - 1) == e[0]) {\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\npublic static void dfs(List<Integer>[] list, boolean[] visited, int[] v, int[] e, int current) {\n    if (!visited[current]) {\n        visited[current] = true;\n        v[0]++;\n        e[0] += list[current].size();\n        for (int n: list[current]) {\n            dfs(list, visited, v, e, n);\n        }\n    }\n}"}
{"task": "python_java", "problem_id": 92, "prediction_id": 0, "pro_prediction": "public static boolean isPossibleToCutPath(int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1;\n    grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}\n\npublic static boolean reach(int x, int y, int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        boolean ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}", "main_fun_name": "isPossibleToCutPath", "raw_prediction": "\"```java\\nboolean reach(int x, int y, int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    if (x == n - 1 && y == m - 1) {\\n        return true;\\n    }\\n    grid[x][y] = 0;\\n    int x1 = x, y1 = y + 1;\\n    if (y1 < m && grid[x1][y1] == 1) {\\n        boolean ret = reach(x1, y1, grid);\\n        if (ret) {\\n            return ret;\\n        }\\n    }\\n    int x2 = x + 1, y2 = y;\\n    if (x2 < n && grid[x2][y2] == 1) {\\n        return reach(x2, y2, grid);\\n    }\\n    return false;\\n}\\n\\nboolean isPossibleToCutPath(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    if (!reach(0, 0, grid)) {\\n        return true;\\n    }\\n    grid[0][0] = 1;\\n    grid[n - 1][m - 1] = 1;\\n    if (!reach(0, 0, grid)) {\\n        return true;\\n    }\\n    return false;\\n}\\n```\"", "sl_gold_code": "def reach(x: int, y: int, grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if x == n - 1 and y == m - 1:\n        return True\n    grid[x][y] = 0\n    x1, y1 = x, y + 1\n    if y1 < m and grid[x1][y1] == 1:\n        ret = reach(x1, y1, grid)\n        if ret:\n            return ret\n    x2, y2 = x + 1, y\n    if x2 < n and grid[x2][y2] == 1:\n        return reach(x2, y2, grid)\n    return False\ndef isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if not reach(0, 0, grid):\n        return True\n    grid[0][0], grid[n - 1][m - 1] = 1, 1\n    if not reach(0, 0, grid):\n        return True\n    return False", "tl_gold_code": "public static boolean reach(int x,int y,int[][] grid){\n    int n=grid.length;\n    int m=grid[0].length;\n    if (x==n-1&&y==m-1){\n        return true;\n    }\n    grid[x][y]=0;\n    int x1=x;int y1=y+1;\n    if (y1<m&&grid[x1][y1]==1){\n        boolean ret=reach(x1,y1,grid);\n        if (ret){\n            return ret;\n        }\n    }\n    int x2=x+1;int y2=y;\n    if (x2<n&&grid[x2][y2]==1){\n        return reach(x2,y2,grid);\n    }\n    return false;\n}\npublic static boolean isPossibleToCutPath(int[][] grid) {\n    int n=grid.length;\n    int m=grid[0].length;\n    List<Integer> queue=new ArrayList<>();\n    boolean[][] rea=new boolean[n][m];\n    if (!reach(0,0,grid)){\n        return true;\n    }\n    grid[0][0]=1;grid[n-1][m-1]=1;\n    if (!reach(0,0,grid)){\n        return true;\n    }\n    return false;\n}"}
{"task": "python_java", "problem_id": 93, "prediction_id": 0, "pro_prediction": "public static boolean validPath(int n, int[][] edges, int source, int destination) {\n        Map<Integer, List<Integer>> adj = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            adj.put(i, new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            adj.get(edge[0]).add(edge[1]);\n            adj.get(edge[1]).add(edge[0]);\n        }\n        boolean[] visited = new boolean[n];\n        return dfs(source, destination, adj, visited);\n    }\n\npublic static boolean dfs(int source, int destination, Map<Integer, List<Integer>> adj, boolean[] visited) {\n        if (source == destination) {\n            return true;\n        }\n        visited[source] = true;\n        for (int next : adj.get(source)) {\n            if (!visited[next] && dfs(next, destination, adj, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }", "main_fun_name": "validPath", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.put(i, new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        return dfs(source, destination, adj, visited);\\n    }\\n\\n    private boolean dfs(int source, int destination, Map<Integer, List<Integer>> adj, boolean[] visited) {\\n        if (source == destination) {\\n            return true;\\n        }\\n        visited[source] = true;\\n        for (int next : adj.get(source)) {\\n            if (!visited[next] && dfs(next, destination, adj, visited)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\"", "sl_gold_code": "def validPath(n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    adj = {i: [] for i in range(n)}\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    return dfs(source, destination, adj, visited)\ndef dfs(source: int, destination: int, adj: dict, visited: List[bool]) -> bool:\n    if source == destination:\n        return True\n    visited[source] = True\n    for next in adj[source]:\n        if not visited[next] and dfs(next, destination, adj, visited):\n            return True\n    return False", "tl_gold_code": "public static boolean validPath(int n, int[][] edges, int source, int destination) {\n    List<Integer>[] adj = new List[n];\n    for (int i = 0; i < n; i++) {\n        adj[i] = new ArrayList<Integer>();\n    }\n    for (int[] edge : edges) {\n        int x = edge[0], y = edge[1];\n        adj[x].add(y);\n        adj[y].add(x);\n    }\n    boolean[] visited = new boolean[n];\n    return dfs(source, destination, adj, visited);\n}\npublic static boolean dfs(int source, int destination, List<Integer>[] adj, boolean[] visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (int next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}"}
{"task": "python_java", "problem_id": 94, "prediction_id": 0, "pro_prediction": "public static boolean isSubPath(ListNode head, TreeNode root) {\n    if (root == null) {\n        return false;\n    }\n    return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\n}\n\npublic static boolean dfs(ListNode head, TreeNode rt) {\n    if (head == null) {\n        return true;\n    }\n    if (rt == null) {\n        return false;\n    }\n    if (rt.val != head.val) {\n        return false;\n    }\n    return dfs(head.next, rt.left) || dfs(head.next, rt.right);\n}", "main_fun_name": "isSubPath", "raw_prediction": "\"```java\\nboolean dfs(ListNode head, TreeNode rt) {\\n    if (head == null) {\\n        return true;\\n    }\\n    if (rt == null) {\\n        return false;\\n    }\\n    if (rt.val != head.val) {\\n        return false;\\n    }\\n    return dfs(head.next, rt.left) || dfs(head.next, rt.right);\\n}\\n\\nboolean isSubPath(ListNode head, TreeNode root) {\\n    if (root == null) {\\n        return false;\\n    }\\n    return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n}\\n```\"", "sl_gold_code": "def dfs(head: ListNode, rt: TreeNode) -> bool:\n    if not head:\n        return True\n    if not rt:\n        return False\n    if rt.val != head.val:\n        return False\n    return dfs(head.next, rt.left) or dfs(head.next, rt.right)\ndef isSubPath(head: ListNode, root: TreeNode) -> bool:\n    if not root:\n        return False\n    return dfs(head, root) or isSubPath(head, root.left) or isSubPath(head, root.right)", "tl_gold_code": "public static boolean isSubPath(ListNode head, TreeNode root) {\n    if(root==null) return false;\n    return dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right);\n}\npublic static boolean dfs(ListNode head,TreeNode root){\n    if(head==null) return true;\n    if(root==null) return false;\n    if(head.val!=root.val) return false;\n    return dfs(head.next,root.left)||dfs(head.next,root.right);\n}"}
{"task": "python_java", "problem_id": 95, "prediction_id": 0, "pro_prediction": "public static List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    List<Integer> nums1 = new ArrayList<>();\n    List<Integer> nums2 = new ArrayList<>();\n    nums1 = inorder(root1, nums1);\n    nums2 = inorder(root2, nums2);\n    List<Integer> merged = new ArrayList<>();\n    int p1 = 0, p2 = 0;\n    while (true) {\n        if (p1 == nums1.size()) {\n            merged.addAll(nums2.subList(p2, nums2.size()));\n            break;\n        }\n        if (p2 == nums2.size()) {\n            merged.addAll(nums1.subList(p1, nums1.size()));\n            break;\n        }\n        if (nums1.get(p1) < nums2.get(p2)) {\n            merged.add(nums1.get(p1));\n            p1++;\n        } else {\n            merged.add(nums2.get(p2));\n            p2++;\n        }\n    }\n    return merged;\n}\n\npublic static List<Integer> inorder(TreeNode node, List<Integer> res) {\n    if (node != null) {\n        inorder(node.left, res);\n        res.add(node.val);\n        inorder(node.right, res);\n    }\n    return res;\n}", "main_fun_name": "getAllElements", "raw_prediction": "\"```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int x) {\\n        val = x;\\n    }\\n}\\n\\npublic List<Integer> inorder(TreeNode node, List<Integer> res) {\\n    if (node != null) {\\n        inorder(node.left, res);\\n        res.add(node.val);\\n        inorder(node.right, res);\\n    }\\n    return res;\\n}\\n\\npublic List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\\n    List<Integer> nums1 = new ArrayList<>();\\n    List<Integer> nums2 = new ArrayList<>();\\n    nums1 = inorder(root1, nums1);\\n    nums2 = inorder(root2, nums2);\\n    List<Integer> merged = new ArrayList<>();\\n    int p1 = 0, p2 = 0;\\n    while (true) {\\n        if (p1 == nums1.size()) {\\n            merged.addAll(nums2.subList(p2, nums2.size()));\\n            break;\\n        }\\n        if (p2 == nums2.size()) {\\n            merged.addAll(nums1.subList(p1, nums1.size()));\\n            break;\\n        }\\n        if (nums1.get(p1) < nums2.get(p2)) {\\n            merged.add(nums1.get(p1));\\n            p1++;\\n        } else {\\n            merged.add(nums2.get(p2));\\n            p2++;\\n        }\\n    }\\n    return merged;\\n}\\n```\"", "sl_gold_code": "def inorder(node, res):\n    if node:\n        inorder(node.left, res)\n        res.append(node.val)\n        inorder(node.right, res)\ndef getAllElements(root1, root2):\n    nums1, nums2 = [], []\n    inorder(root1, nums1)\n    inorder(root2, nums2)\n    merged = []\n    p1, p2 = 0, 0\n    while True:\n        if p1 == len(nums1):\n            merged.extend(nums2[p2:])\n            break\n        if p2 == len(nums2):\n            merged.extend(nums1[p1:])\n            break\n        if nums1[p1] < nums2[p2]:\n            merged.append(nums1[p1])\n            p1 += 1\n        else:\n            merged.append(nums2[p2])\n            p2 += 1\n    return merged", "tl_gold_code": "public static void inorder(TreeNode node, List<Integer> res) {\n    if (node != null) {\n        inorder(node.left, res);\n        res.add(node.val);\n        inorder(node.right, res);\n    }\n}\npublic static List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    List<Integer> nums1 = new ArrayList<>(), nums2 = new ArrayList<>();\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    List<Integer> merged = new ArrayList<>();\n    int p1 = 0, p2 = 0;\n    while (true) {\n        if (p1 == nums1.size()) {\n            merged.addAll(nums2.subList(p2, nums2.size()));\n            break;\n        }\n        if (p2 == nums2.size()) {\n            merged.addAll(nums1.subList(p1, nums1.size()));\n            break;\n        }\n        if (nums1.get(p1) < nums2.get(p2)) {\n            merged.add(nums1.get(p1++));\n        } else {\n            merged.add(nums2.get(p2++));\n        }\n    }\n    return merged;\n}"}
{"task": "python_java", "problem_id": 96, "prediction_id": 0, "pro_prediction": "public static int maxLevelSum(TreeNode root) {\n        List<Integer> sums = new ArrayList<>();\n        dfs(root, 0, sums);\n        return sums.indexOf(Math.max(sums.get(0), sums.get(1))) + 1;\n    }\n\npublic static void dfs(TreeNode node, int level, List<Integer> sums) {\n        if (level == sums.size()) {\n            sums.add(node.val);\n        } else {\n            sums.set(level, sums.get(level) + node.val);\n        }\n        if (node.left != null) {\n            dfs(node.left, level + 1, sums);\n        }\n        if (node.right != null) {\n            dfs(node.right, level + 1, sums);\n        }\n    }", "main_fun_name": "maxLevelSum", "raw_prediction": "\"Here is the translated Java code for the provided Python function:\\n\\n```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int x) {\\n        val = x;\\n    }\\n}\\n\\npublic class Solution {\\n    public int maxLevelSum(TreeNode root) {\\n        List<Integer> sums = new ArrayList<>();\\n        dfs(root, 0, sums);\\n        return sums.indexOf(Math.max(sums.get(0), sums.get(1))) + 1;\\n    }\\n\\n    private void dfs(TreeNode node, int level, List<Integer> sums) {\\n        if (level == sums.size()) {\\n            sums.add(node.val);\\n        } else {\\n            sums.set(level, sums.get(level) + node.val);\\n        }\\n        if (node.left != null) {\\n            dfs(node.left, level + 1, sums);\\n        }\\n        if (node.right != null) {\\n            dfs(node.right, level + 1, sums);\\n        }\\n    }\\n}\\n```\"", "sl_gold_code": "def maxLevelSum(root: Optional[TreeNode]) -> int:\n    sums = []\n    dfs(root, 0, sums)\n    return sums.index(max(sums)) + 1  \ndef dfs(node: TreeNode, level: int, sums) -> None:\n    if level == len(sums):\n        sums.append(node.val)\n    else:\n        sums[level] += node.val\n    if node.left:\n        dfs(node.left, level + 1, sums)\n    if node.right:\n        dfs(node.right, level + 1, sums)", "tl_gold_code": "public static int maxLevelSum(TreeNode root) {\n    List<Integer> sums = new ArrayList<>();\n    dfs(root, 0, sums);\n    return sums.indexOf(Collections.max(sums)) + 1;\n}\nprivate static void dfs(TreeNode node, int level, List<Integer> sums) {\n    if (node == null) return;\n    if (level == sums.size()) {\n        sums.add(node.val);\n    } else {\n        sums.set(level, sums.get(level) + node.val);\n    }\n    dfs(node.left, level + 1, sums);\n    dfs(node.right, level + 1, sums);\n}"}
{"task": "python_java", "problem_id": 97, "prediction_id": 0, "pro_prediction": "public static int sumRootToLeaf(TreeNode root) {\n        return dfs(root, 0);\n    }\n\npublic static int dfs(TreeNode node, int val) {\n        if (node == null) {\n            return 0;\n        }\n        val = (val << 1) | node.val;\n        if (node.left == null && node.right == null) {\n            return val;\n        }\n        return dfs(node.left, val) + dfs(node.right, val);\n    }", "main_fun_name": "sumRootToLeaf", "raw_prediction": "\"Here is the translated Java code for the provided Python function:\\n\\n```java\\nimport java.util.Optional;\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int x) {\\n        val = x;\\n    }\\n}\\n\\npublic class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    private int dfs(TreeNode node, int val) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        val = (val << 1) | node.val;\\n        if (node.left == null && node.right == null) {\\n            return val;\\n        }\\n        return dfs(node.left, val) + dfs(node.right, val);\\n    }\\n}\\n```\"", "sl_gold_code": "def sumRootToLeaf(root: Optional[TreeNode]) -> int:\n    return dfs(root, 0)\ndef dfs(node: Optional[TreeNode], val: int) -> int:\n    if node is None:\n        return 0\n    val = (val << 1) | node.val\n    if node.left is None and node.right is None:\n        return val\n    return dfs(node.left, val) + dfs(node.right, val)", "tl_gold_code": "public static int sumRootToLeaf(TreeNode root) {\n    return dfs(root, 0);\n}\npublic static int dfs(TreeNode root, int val) {\n    if (root == null) {\n        return 0;\n    }\n    val = (val << 1) | root.val;\n    if (root.left == null && root.right == null) {\n        return val;\n    }\n    return dfs(root.left, val) + dfs(root.right, val);\n}"}
{"task": "python_java", "problem_id": 98, "prediction_id": 0, "pro_prediction": "public static boolean isCousins(TreeNode root, int x, int y) {\n        int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\n            if (root == null) {\n                return new int[]{-1, -1};\n            }\n            if (root.val == t) {\n                return new int[]{fa != null ? fa.val : -1, depth};\n            }\n            int[] l = dfs(root.left, root, depth + 1, t);\n            if (l[0] != -1) {\n                return l;\n            }\n            return dfs(root.right, root, depth + 1, t);\n        }\n\n        int[] xi = dfs(root, null, 0, x);\n        int[] yi = dfs(root, null, 0, y);\n        return xi[1] == yi[1] && xi[0] != yi[0];\n    }\n\npublic static int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\n            if (root == null) {\n                return new int[]{-1, -1};\n            }\n            if (root.val == t) {\n                return new int[]{fa != null ? fa.val : -1, depth};\n            }\n            int[] l = dfs(root.left, root, depth + 1, t);\n            if (l[0] != -1) {\n                return l;\n            }\n            return dfs(root.right, root, depth + 1, t);\n        }", "main_fun_name": "isCousins", "raw_prediction": "\"```java\\npublic class TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode(int x) { val = x; }\\n}\\n\\npublic class Solution {\\n    public boolean isCousins(TreeNode root, int x, int y) {\\n        int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\\n            if (root == null) {\\n                return new int[]{-1, -1};\\n            }\\n            if (root.val == t) {\\n                return new int[]{fa != null ? fa.val : -1, depth};\\n            }\\n            int[] l = dfs(root.left, root, depth + 1, t);\\n            if (l[0] != -1) {\\n                return l;\\n            }\\n            return dfs(root.right, root, depth + 1, t);\\n        }\\n\\n        int[] xi = dfs(root, null, 0, x);\\n        int[] yi = dfs(root, null, 0, y);\\n        return xi[1] == yi[1] && xi[0] != yi[0];\\n    }\\n}\\n```\"", "sl_gold_code": "def dfs(root, fa, depth, t):\n    if root is None:\n        return [-1, -1]\n    if root.val == t:\n        return [fa.val if fa else -1, depth]\n    l = dfs(root.left, root, depth + 1, t)\n    if l[0] != -1:\n        return l\n    return dfs(root.right, root, depth + 1, t)\ndef isCousins(root, x, y):\n    xi = dfs(root, None, 0, x)\n    yi = dfs(root, None, 0, y)\n    return xi[1] == yi[1] and xi[0] != yi[0]", "tl_gold_code": "public static boolean isCousins(TreeNode root, int x, int y) {\n    int[] xi = dfs(root, null, 0, x);\n    int[] yi = dfs(root, null, 0, y);\n    return xi[1] == yi[1] && xi[0] != yi[0];\n}\npublic static int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\n    if (root == null) return new int[]{-1, -1};\n    if (root.val == t) {\n        return new int[]{fa != null ? fa.val : 1, depth};\n    }\n    int[] l = dfs(root.left, root, depth + 1, t);\n    if (l[0] != -1) return l;\n    return dfs(root.right, root, depth + 1, t);\n}"}
{"task": "python_java", "problem_id": 99, "prediction_id": 0, "pro_prediction": "public static int longestSquareStreak(int[] nums) {\n    int ans = 0;\n    Set<Integer> s = new HashSet<>();\n    for (int num : nums) {\n        s.add(num);\n    }\n    for (int x : s) {\n        int cnt = 0;\n        while (s.contains(x)) {\n            cnt++;\n            x *= x;\n        }\n        ans = Math.max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}", "main_fun_name": "longestSquareStreak", "raw_prediction": "\"```java\\npublic int longestSquareStreak(int[] nums) {\\n    int ans = 0;\\n    Set<Integer> s = new HashSet<>();\\n    for (int num : nums) {\\n        s.add(num);\\n    }\\n    for (int x : s) {\\n        int cnt = 0;\\n        while (s.contains(x)) {\\n            cnt++;\\n            x *= x;\\n        }\\n        ans = Math.max(ans, cnt);\\n    }\\n    return ans > 1 ? ans : -1;\\n}\\n```\"", "sl_gold_code": "def longestSquareStreak(nums: List[int]) -> int:\n    ans, s = 0, set(nums)\n    for x in s:\n        cnt = 0\n        while x in s:\n            cnt += 1\n            x *= x\n        ans = max(ans, cnt)\n    return ans if ans > 1 else -1", "tl_gold_code": "public static int longestSquareStreak(int[] nums) {\n    int ans = 0;\n    Set<Integer> s = new HashSet<>();\n    for (int num : nums) {\n        s.add(num);\n    }\n    for (int x : s) {\n        int cnt = 0;\n        while (s.contains(x)) {\n            cnt += 1;\n            if (x > Math.sqrt(Integer.MAX_VALUE)) break;\n            x *= x;\n        }\n        ans = Math.max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}"}
{"task": "python_java", "problem_id": 100, "prediction_id": 0, "pro_prediction": "public static int appendCharacters(String s, String t) {\n    int j = 0, m = t.length();\n    for (char c : s.toCharArray()) {\n        if (c == t.charAt(j)) {\n            j++;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}", "main_fun_name": "appendCharacters", "raw_prediction": "\"Here is the translated Java function:\\n\\n```java\\npublic int appendCharacters(String s, String t) {\\n    int j = 0, m = t.length();\\n    for (char c : s.toCharArray()) {\\n        if (c == t.charAt(j)) {\\n            j++;\\n            if (j == m) return 0;\\n        }\\n    }\\n    return m - j;\\n}\\n```\"", "sl_gold_code": "def appendCharacters(s: str, t: str) -> int:\n    j, m = 0, len(t)\n    for c in s:\n        if c == t[j]:\n            j += 1\n            if j == m: return 0\n    return m - j", "tl_gold_code": "public static int appendCharacters(String s, String t) {\n    int j = 0, m = t.length();\n    for (char c : s.toCharArray()) {\n        if (c == t.charAt(j)) {\n            j++;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}"}