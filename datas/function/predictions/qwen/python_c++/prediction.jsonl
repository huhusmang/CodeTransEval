{"task": "python_c++", "problem_id": 1, "prediction_id": 0, "pro_prediction": "int findKOr(std::vector<int> nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; ++i) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= (1 << i);\n        }\n    }\n    return ans;\n}", "main_fun_name": "findKOr", "raw_prediction": "```cpp\n#include <vector>\n\nint findKOr(std::vector<int> nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; ++i) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= (1 << i);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def findKOr(nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt1 = 0\n        for x in nums:\n            cnt1 += x >> i & 1\n        if cnt1 >= k:\n            ans |= 1 << i\n    return ans", "tl_gold_code": "int findKOr(vector<int>& nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 2, "prediction_id": 0, "pro_prediction": "long long minSum(std::vector<int> nums1, std::vector<int> nums2) {\n    int s1 = 0;\n    bool zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1 += 1;\n        } else {\n            s1 += x;\n        }\n    }\n    int s2 = 0;\n    bool zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2 += 1;\n        } else {\n            s2 += x;\n        }\n    }\n    if ((not zero1 and s1 < s2) or (not zero2 and s2 < s1)) {\n        return -1;\n    }\n    return std::max(s1, s2);\n}", "main_fun_name": "minSum", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nlong long minSum(std::vector<int> nums1, std::vector<int> nums2) {\n    int s1 = 0;\n    bool zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1 += 1;\n        } else {\n            s1 += x;\n        }\n    }\n    int s2 = 0;\n    bool zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2 += 1;\n        } else {\n            s2 += x;\n        }\n    }\n    if ((not zero1 and s1 < s2) or (not zero2 and s2 < s1)) {\n        return -1;\n    }\n    return std::max(s1, s2);\n}\n```", "sl_gold_code": "def minSum(nums1, nums2):\n    s1 = 0\n    zero1 = False\n    for x in nums1:\n        if x == 0:\n            zero1 = True\n            s1 += 1\n        else:\n            s1 += x\n    s2 = 0\n    zero2 = False\n    for x in nums2:\n        if x == 0:\n            zero2 = True\n            s2 += 1\n        else:\n            s2 += x\n    if (not zero1 and s1 < s2) or (not zero2 and s2 < s1):\n        return -1\n    return max(s1, s2)", "tl_gold_code": "long long minSum(vector<int>& nums1, vector<int>& nums2) {\n    long long s1 = 0;\n    bool zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long long s2 = 0;\n    bool zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if (!zero1 && s1 < s2 || !zero2 && s2 < s1) {\n        return -1;\n    }\n    return max(s1, s2);\n}"}
{"task": "python_c++", "problem_id": 3, "prediction_id": 0, "pro_prediction": "int lengthOfLongestSubsequence(std::vector<int>& nums, int target) {\n    std::vector<int> f(target + 1, -std::numeric_limits<int>::infinity());\n    int s = 0;\n    for (int x : nums) {\n        s = std::min(s + x, target);\n        for (int j = s; j >= x - 1; j--) {\n            if (f[j] < f[j - x] + 1) {\n                f[j] = f[j - x] + 1;\n            }\n        }\n    }\n    return f.back() > 0 ? f.back() : -1;\n}", "main_fun_name": "lengthOfLongestSubsequence", "raw_prediction": "```cpp\n#include <vector>\n#include <limits>\n\nint lengthOfLongestSubsequence(std::vector<int>& nums, int target) {\n    std::vector<int> f(target + 1, -std::numeric_limits<int>::infinity());\n    int s = 0;\n    for (int x : nums) {\n        s = std::min(s + x, target);\n        for (int j = s; j >= x - 1; j--) {\n            if (f[j] < f[j - x] + 1) {\n                f[j] = f[j - x] + 1;\n            }\n        }\n    }\n    return f.back() > 0 ? f.back() : -1;\n}\n```\nNote: The code assumes that the `#include` statements and necessary namespace imports are already present in the file.", "sl_gold_code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    f = [0] + [-inf] * target\n    s = 0\n    for x in nums:\n        s = min(s + x, target)\n        for j in range(s, x - 1, -1):\n            if f[j] < f[j - x] + 1:\n                f[j] = f[j - x] + 1\n    return f[-1] if f[-1] > 0 else -1", "tl_gold_code": "int lengthOfLongestSubsequence(vector<int> &nums, int target) {\n    vector<int> f(target + 1, INT_MIN);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}"}
{"task": "python_c++", "problem_id": 4, "prediction_id": 0, "pro_prediction": "int minChanges(string s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += int(s[i] != s[i + 1]);\n    }\n    return ans;\n}", "main_fun_name": "minChanges", "raw_prediction": "```cpp\n#include <string>\nusing namespace std;\n\nint minChanges(string s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += int(s[i] != s[i + 1]);\n    }\n    return ans;\n}\n```", "sl_gold_code": "def minChanges(s):\n    ans = 0\n    for i in range(0, len(s), 2):\n        ans += int(s[i] != s[i + 1])\n    return ans", "tl_gold_code": "int minChanges(string s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += s[i] != s[i + 1];\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 5, "prediction_id": 0, "pro_prediction": "int minGroupsForValidAssignment(std::vector<int> nums) {\n    std::unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int k = nums.size();\n    for (const auto& c : cnt) {\n        k = std::min(k, c.second);\n    }\n    while (true) {\n        int ans = 0;\n        for (const auto& c : cnt) {\n            if (c.second / k < c.second % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c.second + k) / (k + 1);\n        }\n        if (ans > 0) {\n            return ans;\n        }\n        k--;\n    }\n}", "main_fun_name": "minGroupsForValidAssignment", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n\nint minGroupsForValidAssignment(std::vector<int> nums) {\n    std::unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int k = nums.size();\n    for (const auto& c : cnt) {\n        k = std::min(k, c.second);\n    }\n    while (true) {\n        int ans = 0;\n        for (const auto& c : cnt) {\n            if (c.second / k < c.second % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c.second + k) / (k + 1);\n        }\n        if (ans > 0) {\n            return ans;\n        }\n        k--;\n    }\n}\n```\n\nNote: The code assumes that the input vector `nums` does not contain any duplicate elements. If there are duplicates, the code may produce incorrect results.", "sl_gold_code": "def minGroupsForValidAssignment(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    k = len(nums)\n    for c in cnt.values():\n        k = min(k, c)\n    while True:\n        ans = 0\n        for c in cnt.values():\n            if c // k < c % k:\n                ans = 0\n                break\n            ans += (c + k) // (k + 1)\n        if ans > 0:\n            return ans\n        k -= 1", "tl_gold_code": "int minGroupsForValidAssignment(vector<int>& nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int k = min_element(cnt.begin(), cnt.end(), [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    })->second;\n    for (; ; k--) {\n        int ans = 0;\n        for (auto &[_, c] : cnt) {\n            if (c / k < c % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c + k) / (k + 1);\n        }\n        if (ans) {\n            return ans;\n        }\n    }\n}"}
{"task": "python_c++", "problem_id": 6, "prediction_id": 0, "pro_prediction": "int minimumSum(std::vector<int> nums) {\n    int n = nums.size();\n    std::vector<int> suf(n, 0);\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i >= 1; i--) {\n        suf[i] = std::min(suf[i + 1], nums[i]);\n    }\n    int ans = INT_MAX;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = std::min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = std::min(pre, nums[j]);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}", "main_fun_name": "minimumSum", "raw_prediction": "```cpp\n#include <vector>\n#include <climits>\n\nint minimumSum(std::vector<int> nums) {\n    int n = nums.size();\n    std::vector<int> suf(n, 0);\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i >= 1; i--) {\n        suf[i] = std::min(suf[i + 1], nums[i]);\n    }\n    int ans = INT_MAX;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = std::min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = std::min(pre, nums[j]);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}\n```\nNote: The code assumes that `INT_MAX` is defined in the global namespace. If it is not, you may need to include the `<climits>` header and use `std::numeric_limits<int>::max()` instead of `INT_MAX`.", "sl_gold_code": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    suf = [0] * n\n    suf[-1] = nums[-1]\n    for i in range(n - 2, 1, -1):\n        suf[i] = min(suf[i + 1], nums[i])\n    ans = inf\n    pre = nums[0]\n    for j in range(1, n - 1):\n        if pre < nums[j] > suf[j + 1]:\n            ans = min(ans, pre + nums[j] + suf[j + 1])\n        pre = min(pre, nums[j])\n    return ans if ans < inf else -1", "tl_gold_code": "int minimumSum(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> suf(n);\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = min(suf[i + 1], nums[i]);\n    }\n    int ans = INT_MAX;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = min(pre, nums[j]);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}"}
{"task": "python_c++", "problem_id": 7, "prediction_id": 0, "pro_prediction": "vector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {\n    int MOD = 12345;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> p(n, vector<int>(m, 0));\n    int suf = 1;  \n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = suf;  \n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    int pre = 1;  \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = p[i][j] * pre % MOD;  \n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}", "main_fun_name": "constructProductMatrix", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {\n    int MOD = 12345;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> p(n, vector<int>(m, 0));\n    int suf = 1;  \n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = suf;  \n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    int pre = 1;  \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = p[i][j] * pre % MOD;  \n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}\n```", "sl_gold_code": "def constructProductMatrix(grid: List[List[int]]) -> List[List[int]]:\n    MOD = 12345\n    n, m = len(grid), len(grid[0])\n    p = [[0] * m for _ in range(n)]\n    suf = 1  \n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            p[i][j] = suf  \n            suf = suf * grid[i][j] % MOD\n    pre = 1  \n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            p[i][j] = p[i][j] * pre % MOD  \n            pre = pre * x % MOD\n    return p", "tl_gold_code": "vector<vector<int>> constructProductMatrix(vector<vector<int>> &grid) {\n    const int MOD = 12345;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> p(n, vector<int>(m));\n    long long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = p[i][j] * pre % MOD;\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}"}
{"task": "python_c++", "problem_id": 8, "prediction_id": 0, "pro_prediction": "std::string maximumOddBinaryNumber(std::string s) {\n    int cnt1 = 0;\n    for (char c : s) {\n        if (c == '1') {\n            cnt1++;\n        }\n    }\n    return std::string(cnt1 - 1, '1') + std::string(len(s) - cnt1, '0') + \"1\";\n}", "main_fun_name": "maximumOddBinaryNumber", "raw_prediction": "```cpp\n#include <string>\n\nstd::string maximumOddBinaryNumber(std::string s) {\n    int cnt1 = 0;\n    for (char c : s) {\n        if (c == '1') {\n            cnt1++;\n        }\n    }\n    return std::string(cnt1 - 1, '1') + std::string(len(s) - cnt1, '0') + \"1\";\n}\n```", "sl_gold_code": "def maximumOddBinaryNumber(s: str) -> str:\n    cnt1 = s.count('1')\n    return '1' * (cnt1 - 1) + '0' * (len(s) - cnt1) + '1'", "tl_gold_code": "string maximumOddBinaryNumber(string s) {\n    int cnt1 = count(s.begin(), s.end(), '1');\n    return string(cnt1 - 1, '1') + string(s.length() - cnt1, '0') + '1';\n}"}
{"task": "python_c++", "problem_id": 9, "prediction_id": 0, "pro_prediction": "std::string shortestBeautifulSubstring(std::string s, int k) {\n    if (std::count(s.begin(), s.end(), '1') < k) {\n        return \"\";\n    }\n    std::string ans = s;\n    int cnt1 = 0;\n    int left = 0;\n    for (int right = 0; right < s.size(); ++right) {\n        cnt1 += (s[right] - '0');\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= (s[left] - '0');\n            left++;\n        }\n        if (cnt1 == k) {\n            std::string t = s.substr(left, right - left + 1);\n            if (t.size() < ans.size() || (t.size() == ans.size() && t < ans)) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}", "main_fun_name": "shortestBeautifulSubstring", "raw_prediction": "```cpp\n#include <string>\n#include <vector>\n\nstd::string shortestBeautifulSubstring(std::string s, int k) {\n    if (std::count(s.begin(), s.end(), '1') < k) {\n        return \"\";\n    }\n    std::string ans = s;\n    int cnt1 = 0;\n    int left = 0;\n    for (int right = 0; right < s.size(); ++right) {\n        cnt1 += (s[right] - '0');\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= (s[left] - '0');\n            left++;\n        }\n        if (cnt1 == k) {\n            std::string t = s.substr(left, right - left + 1);\n            if (t.size() < ans.size() || (t.size() == ans.size() && t < ans)) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    if s.count('1') < k:\n        return ''\n    ans = s\n    cnt1 = left = 0\n    for right, c in enumerate(s):\n        cnt1 += int(c)\n        while cnt1 > k or s[left] == '0':\n            cnt1 -= int(s[left])\n            left += 1\n        if cnt1 == k:\n            t = s[left: right + 1]\n            if len(t) < len(ans) or len(t) == len(ans) and t < ans:\n                ans = t\n    return ans", "tl_gold_code": "string shortestBeautifulSubstring(string s, int k) {\n    if (count(s.begin(), s.end(), '1') < k) {\n        return \"\";\n    }\n    string ans = s;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length(); right++) {\n        cnt1 += s[right] - '0';\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= s[left++] - '0';\n        }\n        if (cnt1 == k) {\n            string t = s.substr(left, right - left + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t < ans) {\n                ans = move(t);\n            }\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 10, "prediction_id": 0, "pro_prediction": "int addMinimum(const std::string& s) {\n    int t = 1;\n    for (size_t i = 1; i < s.length(); ++i) {\n        t += s[i - 1] >= s[i];\n    }\n    return t * 3 - s.length();\n}", "main_fun_name": "addMinimum", "raw_prediction": "```cpp\n#include <string>\n\nint addMinimum(const std::string& s) {\n    int t = 1;\n    for (size_t i = 1; i < s.length(); ++i) {\n        t += s[i - 1] >= s[i];\n    }\n    return t * 3 - s.length();\n}\n```", "sl_gold_code": "def addMinimum(s):\n    t = 1\n    for i in range(1, len(s)):\n        t += s[i - 1] >= s[i]\n    return t * 3 - len(s)", "tl_gold_code": "int addMinimum(string s) {\n    int t = 1;\n    for (int i = 1; i < s.length(); ++i)\n        t += s[i - 1] >= s[i];\n    return t * 3 - s.length();\n}"}
{"task": "python_c++", "problem_id": 11, "prediction_id": 0, "pro_prediction": "int maxIncreasingGroups(vector<int> usageLimits) {\n    vector<int> ul = usageLimits;\n    sort(ul.begin(), ul.end());\n    int remain = 0;\n    int require = 1;\n    for (int num : ul) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require += 1;\n        }\n    }\n    return require - 1;\n}", "main_fun_name": "maxIncreasingGroups", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint maxIncreasingGroups(vector<int> usageLimits) {\n    vector<int> ul = usageLimits;\n    sort(ul.begin(), ul.end());\n    int remain = 0;\n    int require = 1;\n    for (int num : ul) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require += 1;\n        }\n    }\n    return require - 1;\n}\n```", "sl_gold_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    ul = sorted(usageLimits)\n    remain = 0\n    require = 1\n    for num in ul:\n        remain += num\n        if remain >= require:\n            remain -= require \n            require += 1 \n    return require - 1", "tl_gold_code": "int maxIncreasingGroups(vector<int>& usageLimits) {\n    sort(usageLimits.begin(), usageLimits.end());\n    long long remain = 0;\n    int require = 1;\n    for (int num : usageLimits) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require++;\n        }\n    }\n    return require - 1;\n}"}
{"task": "python_c++", "problem_id": 12, "prediction_id": 0, "pro_prediction": "std::vector<int> lastVisitedIntegers(std::vector<std::string> words) {\n    std::vector<int> ans;\n    std::vector<int> nums;\n    int k = 0;\n    for (std::string s : words) {\n        if (s[0] != 'p') {\n            nums.push_back(std::stoi(s));\n            k = 0;\n        } else {\n            k += 1;\n            ans.push_back(k > nums.size() ? -1 : nums[nums.size() - k]);\n        }\n    }\n    return ans;\n}", "main_fun_name": "lastVisitedIntegers", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> lastVisitedIntegers(std::vector<std::string> words) {\n    std::vector<int> ans;\n    std::vector<int> nums;\n    int k = 0;\n    for (std::string s : words) {\n        if (s[0] != 'p') {\n            nums.push_back(std::stoi(s));\n            k = 0;\n        } else {\n            k += 1;\n            ans.push_back(k > nums.size() ? -1 : nums[nums.size() - k]);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    k = 0\n    for s in words:\n        if s[0] != 'p':  \n            nums.append(int(s))\n            k = 0\n        else:\n            k += 1\n            ans.append(-1 if k > len(nums) else nums[-k])  \n    return ans", "tl_gold_code": "vector<int> lastVisitedIntegers(vector<string> &words) {\n    vector<int> ans, a;\n    int k = 0;\n    for (auto &s: words) {\n        if (s[0] != 'p') { \n            a.push_back(stoi(s));\n            k = 0;\n        } else {\n            ans.push_back(++k > a.size() ? -1 : a[a.size() - k]); \n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 13, "prediction_id": 0, "pro_prediction": "int minOperations(std::string s1, std::string s2, int x) {\n    if (s1 == s2) {\n        return 0;\n    }\n    std::vector<int> p;\n    for (int i = 0; i < s1.length(); ++i) {\n        if (s1[i] != s2[i]) {\n            p.push_back(i);\n        }\n    }\n    if (p.size() % 2) {\n        return -1;\n    }\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); ++i) {\n        int new_f = std::min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}", "main_fun_name": "minOperations", "raw_prediction": "```cpp\n#include <string>\n#include <vector>\n\nint minOperations(std::string s1, std::string s2, int x) {\n    if (s1 == s2) {\n        return 0;\n    }\n    std::vector<int> p;\n    for (int i = 0; i < s1.length(); ++i) {\n        if (s1[i] != s2[i]) {\n            p.push_back(i);\n        }\n    }\n    if (p.size() % 2) {\n        return -1;\n    }\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); ++i) {\n        int new_f = std::min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}\n```", "sl_gold_code": "def minOperations(s1, s2, x):\n    if s1 == s2:\n        return 0\n    p = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    if len(p) % 2:\n        return -1\n    f0, f1 = 0, x\n    for i in range(1, len(p)):\n        new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)\n        f0, f1 = f1, new_f\n    return f1 // 2", "tl_gold_code": "int minOperations(string s1, string s2, int x) {\n    if (s1 == s2) return 0;\n    vector<int> p;\n    for (int i = 0; i < s1.size(); i++)\n        if (s1[i] != s2[i])\n            p.push_back(i);\n    if (p.size() % 2) return -1;\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}"}
{"task": "python_c++", "problem_id": 14, "prediction_id": 0, "pro_prediction": "int minProcessingTime(std::vector<int> processorTime, std::vector<int> tasks) {\n    std::sort(processorTime.begin(), processorTime.end());\n    std::sort(tasks.rbegin(), tasks.rend());\n    return *std::max_element(std::zip(processorTime, tasks[::4]), {}, [](auto& a, auto& b) { return a.first + a.second < b.first + b.second; });\n}", "main_fun_name": "minProcessingTime", "raw_prediction": "```cpp\n#include <algorithm>\n#include <vector>\n\nint minProcessingTime(std::vector<int> processorTime, std::vector<int> tasks) {\n    std::sort(processorTime.begin(), processorTime.end());\n    std::sort(tasks.rbegin(), tasks.rend());\n    return *std::max_element(std::zip(processorTime, tasks[::4]), {}, [](auto& a, auto& b) { return a.first + a.second < b.first + b.second; });\n}\n```", "sl_gold_code": "def minProcessingTime(processorTime: List[int], tasks: List[int]) -> int:\n        processorTime.sort()\n        tasks.sort(reverse=True)\n        return max(p + t for p, t in zip(processorTime, tasks[::4]))", "tl_gold_code": "int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {\n    sort(processorTime.begin(), processorTime.end());\n    sort(tasks.begin(), tasks.end(), greater<int>());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = max(ans, processorTime[i] + tasks[i * 4]);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 15, "prediction_id": 0, "pro_prediction": "int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - (n / m) * ((n / m) + 1) * m;\n}", "main_fun_name": "differenceOfSums", "raw_prediction": "```cpp\n#include <iostream>\n\nint differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - (n / m) * ((n / m) + 1) * m;\n}\n```", "sl_gold_code": "def differenceOfSums(n: int, m: int) -> int:\n        return n * (n + 1) // 2 - n // m * (n // m + 1) * m", "tl_gold_code": "int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}"}
{"task": "python_c++", "problem_id": 16, "prediction_id": 0, "pro_prediction": "int minSizeSubarray(std::vector<int> nums, int target) {\n    int total = std::accumulate(nums.begin(), nums.end(), 0);\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = s = 0;\n    for (int right = 0; right < n * 2; ++right) {\n        s += nums[right % n];\n        while (s > target % total) {\n            s -= nums[left % n];\n            left++;\n        }\n        if (s == target % total) {\n            ans = std::min(ans, right - left + 1);\n        }\n    }\n    return ans + target / total * n if (ans != INT_MAX) else -1;\n}", "main_fun_name": "minSizeSubarray", "raw_prediction": "```cpp\n#include <vector>\n#include <climits>\n\nint minSizeSubarray(std::vector<int> nums, int target) {\n    int total = std::accumulate(nums.begin(), nums.end(), 0);\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = s = 0;\n    for (int right = 0; right < n * 2; ++right) {\n        s += nums[right % n];\n        while (s > target % total) {\n            s -= nums[left % n];\n            left++;\n        }\n        if (s == target % total) {\n            ans = std::min(ans, right - left + 1);\n        }\n    }\n    return ans + target / total * n if (ans != INT_MAX) else -1;\n}\n```", "sl_gold_code": "def minSizeSubarray(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    n = len(nums)\n    ans = inf\n    left = s = 0\n    for right in range(n * 2):\n        s += nums[right % n]\n        while s > target % total:\n            s -= nums[left % n]\n            left += 1\n        if s == target % total:\n            ans = min(ans, right - left + 1)\n    return ans + target // total * n if ans < inf else -1", "tl_gold_code": "int minSizeSubarray(vector<int> &nums, int target) {\n    long long total = accumulate(nums.begin(), nums.end(), 0LL);\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    long long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = min(ans, right - left + 1);\n        }\n    }\n    return ans == INT_MAX ? -1 : ans + target / total * n;\n}"}
{"task": "python_c++", "problem_id": 17, "prediction_id": 0, "pro_prediction": "long long maximumTripletValue(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i >= 1; --i) {\n        suf_max[i] = std::max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = pre_max = 0;\n    for (size_t j = 0; j < nums.size(); ++j) {\n        ans = std::max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = std::max(pre_max, nums[j]);\n    }\n    return ans;\n}", "main_fun_name": "maximumTripletValue", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nlong long maximumTripletValue(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i >= 1; --i) {\n        suf_max[i] = std::max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = pre_max = 0;\n    for (size_t j = 0; j < nums.size(); ++j) {\n        ans = std::max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = std::max(pre_max, nums[j]);\n    }\n    return ans;\n}\n```", "sl_gold_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans", "tl_gold_code": "long long maximumTripletValue(vector<int> &nums) {\n    int n = nums.size();\n    vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = max(pre_max, nums[j]);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 18, "prediction_id": 0, "pro_prediction": "long long maximumTripletValue(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i >= 1; --i) {\n        suf_max[i] = std::max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = pre_max = 0;\n    for (size_t j = 0; j < nums.size(); ++j) {\n        ans = std::max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = std::max(pre_max, nums[j]);\n    }\n    return ans;\n}", "main_fun_name": "maximumTripletValue", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nlong long maximumTripletValue(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i >= 1; --i) {\n        suf_max[i] = std::max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = pre_max = 0;\n    for (size_t j = 0; j < nums.size(); ++j) {\n        ans = std::max(ans, (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = std::max(pre_max, nums[j]);\n    }\n    return ans;\n}\n```\n\nNote: The input parameter type `List[int]` in Python is translated to `std::vector<int>` in C++.", "sl_gold_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans", "tl_gold_code": "long long maximumTripletValue(vector<int> &nums) {\n    int n = nums.size();\n    vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = max(pre_max, nums[j]);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 19, "prediction_id": 0, "pro_prediction": "int maxSubarrays(vector<int> nums) {\n    int ans = 0;\n    int a = -1;\n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans += 1;\n            a = -1;\n        }\n    }\n    return max(ans, 1);\n}", "main_fun_name": "maxSubarrays", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint maxSubarrays(vector<int> nums) {\n    int ans = 0;\n    int a = -1;\n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans += 1;\n            a = -1;\n        }\n    }\n    return max(ans, 1);\n}\n```", "sl_gold_code": "def maxSubarrays(nums: List[int]) -> int:\n    ans = 0\n    a = -1\n    for x in nums:\n        a &= x\n        if a == 0:\n            ans += 1 \n            a = -1\n    return max(ans, 1)", "tl_gold_code": "int maxSubarrays(vector<int> &nums) {\n    int ans = 0;\n    int a = -1; \n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++; \n            a = -1;\n        }\n    }\n    return max(ans, 1); \n}"}
{"task": "python_c++", "problem_id": 20, "prediction_id": 0, "pro_prediction": "int minOperations(vector<int> nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int ans = 0;\n    for (auto c : cnt) {\n        if (c.second == 1) {\n            return -1;\n        }\n        ans += (c.second + 2) / 3;\n    }\n    return ans;\n}", "main_fun_name": "minOperations", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int ans = 0;\n    for (auto c : cnt) {\n        if (c.second == 1) {\n            return -1;\n        }\n        ans += (c.second + 2) / 3;\n    }\n    return ans;\n}\n```", "sl_gold_code": "def minOperations(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    ans = 0\n    for c in cnt.values():\n        if c == 1:\n            return -1\n        ans += (c + 2) // 3\n    return ans", "tl_gold_code": "int minOperations(vector<int> &nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int ans = 0;\n    for (auto &[_, c] : cnt) {\n        if (c == 1) {\n            return -1;\n        }\n        ans += (c + 2) / 3;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 21, "prediction_id": 0, "pro_prediction": "int minOperations(vector<int>& nums, int k) {\n    int u = (1 << k) - 1;\n    int s = 0, n = nums.size();\n    for (int i = n - 1; i >= 0; i--) {\n        s |= (1 << nums[i]);\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n    return -1;\n}", "main_fun_name": "minOperations", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int>& nums, int k) {\n    int u = (1 << k) - 1;\n    int s = 0, n = nums.size();\n    for (int i = n - 1; i >= 0; i--) {\n        s |= (1 << nums[i]);\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n    return -1;\n}\n```", "sl_gold_code": "def minOperations(nums: List[int], k: int) -> int:\n    u = (2 << k) - 2  \n    s, n = 0, len(nums)\n    for i in range(n - 1, -1, -1):\n        s |= 1 << nums[i]\n        if (s & u) == u:\n            return n - i", "tl_gold_code": "int minOperations(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    long long u = (2LL << k) - 2;\n    long long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1LL << nums[i];\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}"}
{"task": "python_c++", "problem_id": 22, "prediction_id": 0, "pro_prediction": "int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>> composition, vector<int> stock, vector<int> cost) {\n    int ans = 0;\n    int mx = *min_element(stock.begin(), stock.end()) + budget;\n    for (auto &com : composition) {\n        auto check = [&](int num) -> bool {\n            int money = 0;\n            for (size_t i = 0; i < n; ++i) {\n                if (stock[i] < com[i] * num) {\n                    money += (com[i] * num - stock[i]) * cost[i];\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            if (check(mid)) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        ans = max(ans, left);\n    }\n    return ans;\n}", "main_fun_name": "maxNumberOfAlloys", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>> composition, vector<int> stock, vector<int> cost) {\n    int ans = 0;\n    int mx = *min_element(stock.begin(), stock.end()) + budget;\n    for (auto &com : composition) {\n        auto check = [&](int num) -> bool {\n            int money = 0;\n            for (size_t i = 0; i < n; ++i) {\n                if (stock[i] < com[i] * num) {\n                    money += (com[i] * num - stock[i]) * cost[i];\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            if (check(mid)) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        ans = max(ans, left);\n    }\n    return ans;\n}\n```", "sl_gold_code": "def maxNumberOfAlloys(n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    ans = 0\n    mx = min(stock) + budget\n    for com in composition:\n        def check(num: int) -> int:\n            money = 0\n            for s, base, c in zip(stock, com, cost):\n                if s < base * num:\n                    money += (base * num - s) * c\n                    if money > budget:\n                        return False\n            return True\n        left, right = 0, mx + 1\n        while left + 1 < right:  \n            mid = (left + right) // 2\n            if check(mid):\n                left = mid\n            else:\n                right = mid\n        ans = max(ans, left)\n    return ans", "tl_gold_code": "int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>> &composition, vector<int> &stock, vector<int> &cost) {\n    int ans = 0;\n    int mx = *min_element(stock.begin(), stock.end()) + budget;\n    for (auto &com: composition) {\n        auto check = [&](long long num) -> bool {\n            long long money = 0;\n            for (int i = 0; i < n; i++) {\n                if (stock[i] < com[i] * num) {\n                    money += (com[i] * num - stock[i]) * cost[i];\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) { \n            int mid = (left + right) / 2;\n            (check(mid) ? left : right) = mid;\n        }\n        ans = max(ans, left);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 23, "prediction_id": 0, "pro_prediction": "int countWays(std::vector<int> nums) {\n    std::sort(nums.begin(), nums.end());\n    int n = nums.size();\n    bool ans = nums[0] > 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (nums[i] < i + 2 && nums[i + 1] > i + 1) {\n            ans = true;\n        }\n    }\n    return ans + 1;\n}", "main_fun_name": "countWays", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint countWays(std::vector<int> nums) {\n    std::sort(nums.begin(), nums.end());\n    int n = nums.size();\n    bool ans = nums[0] > 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (nums[i] < i + 2 && nums[i + 1] > i + 1) {\n            ans = true;\n        }\n    }\n    return ans + 1;\n}\n```", "sl_gold_code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = nums[0] > 0  \n    for i, (x, y) in enumerate(pairwise(nums)):\n        if x < i + 1 < y:\n            ans += 1\n    return ans + 1", "tl_gold_code": "int countWays(vector<int> &nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    int ans = nums[0] > 0; \n    for (int i = 0; i < n - 1; i++) {\n        if (nums[i] < i + 1 && i + 1 < nums[i + 1]) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}"}
{"task": "python_c++", "problem_id": 24, "prediction_id": 0, "pro_prediction": "int sumIndicesWithKSetBits(std::vector<int>& nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (std::bitset<32>(i).count() == k) {\n            ans += nums[i];\n        }\n    }\n    return ans;\n}", "main_fun_name": "sumIndicesWithKSetBits", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nint sumIndicesWithKSetBits(std::vector<int>& nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (std::bitset<32>(i).count() == k) {\n            ans += nums[i];\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def sumIndicesWithKSetBits(nums, k):\n    ans = 0\n    for i in range(len(nums)):\n        if bin(i).count('1') == k:\n            ans += nums[i]\n    return ans", "tl_gold_code": "int sumIndicesWithKSetBits(vector<int> &nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (__builtin_popcount(i) == k) {\n            ans += nums[i];\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 25, "prediction_id": 0, "pro_prediction": "int countPairs(vector<vector<int>>& coordinates, int k) {\n    int ans = 0;\n    unordered_map<pair<int, int>, int> cnt;\n    for (auto& [x, y] : coordinates) {\n        for (int i = 0; i <= k; ++i) {\n            ans += cnt[{x ^ i, y ^ (k - i)}];\n        }\n        cnt[{x, y}]++;\n    }\n    return ans;\n}", "main_fun_name": "countPairs", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint countPairs(vector<vector<int>>& coordinates, int k) {\n    int ans = 0;\n    unordered_map<pair<int, int>, int> cnt;\n    for (auto& [x, y] : coordinates) {\n        for (int i = 0; i <= k; ++i) {\n            ans += cnt[{x ^ i, y ^ (k - i)}];\n        }\n        cnt[{x, y}]++;\n    }\n    return ans;\n}\n```", "sl_gold_code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    ans = 0\n    cnt = Counter()\n    for x, y in coordinates:\n        for i in range(k + 1):\n            ans += cnt[x ^ i, y ^ (k - i)]  \n        cnt[x, y] += 1  \n    return ans", "tl_gold_code": "int countPairs(vector<vector<int>> &coordinates, int k) {\n    int ans = 0;\n    unordered_map<long long, int> cnt;\n    for (auto &p: coordinates) {\n        for (int i = 0; i <= k; i++) {\n            auto it = cnt.find((p[0] ^ i) * 2000000LL + (p[1] ^ (k - i)));\n            if (it != cnt.end()) {\n                ans += it->second;\n            }\n        }\n        cnt[p[0] * 2000000LL + p[1]]++;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 26, "prediction_id": 0, "pro_prediction": "int minimumRightShifts(vector<int> nums) {\n    int i = 1, n = nums.size();\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums[0] < nums.back()) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}", "main_fun_name": "minimumRightShifts", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint minimumRightShifts(vector<int> nums) {\n    int i = 1, n = nums.size();\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums[0] < nums.back()) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}\n```", "sl_gold_code": "def minimumRightShifts(nums: List[int]) -> int:\n    i, n = 1, len(nums)\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i == n:\n        return 0\n    if nums[0] < nums[-1]:\n        return -1\n    mid = i\n    i += 1\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i < n:\n        return -1\n    return n - mid", "tl_gold_code": "int minimumRightShifts(vector<int>& nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums[0] < nums[n - 1]) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}"}
{"task": "python_c++", "problem_id": 27, "prediction_id": 0, "pro_prediction": "int minLengthAfterRemovals(std::vector<int>& nums) {\n    int maxCnt = cnt = 1;\n    int pre = nums[0];\n    int n = nums.size();\n    for (int i = 1; i < n; ++i) {\n        if (pre == nums[i]) {\n            cnt += 1;\n        } else {\n            maxCnt = std::max(maxCnt, cnt);\n            pre = nums[i];\n            cnt = 1;\n        }\n    }\n    maxCnt = std::max(maxCnt, cnt);\n    if (maxCnt * 2 > n) {\n        return maxCnt - (n - maxCnt);\n    } else {\n        return n % 2 == 0 ? 0 : 1;\n    }\n}", "main_fun_name": "minLengthAfterRemovals", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint minLengthAfterRemovals(std::vector<int>& nums) {\n    int maxCnt = cnt = 1;\n    int pre = nums[0];\n    int n = nums.size();\n    for (int i = 1; i < n; ++i) {\n        if (pre == nums[i]) {\n            cnt += 1;\n        } else {\n            maxCnt = std::max(maxCnt, cnt);\n            pre = nums[i];\n            cnt = 1;\n        }\n    }\n    maxCnt = std::max(maxCnt, cnt);\n    if (maxCnt * 2 > n) {\n        return maxCnt - (n - maxCnt);\n    } else {\n        return n % 2 == 0 ? 0 : 1;\n    }\n}\n```", "sl_gold_code": "def minLengthAfterRemovals(nums):\n    maxCnt = cnt = 1\n    pre = nums[0]\n    n = len(nums)\n    for i in range(1, n):\n        if pre == nums[i]:\n            cnt += 1\n        else:\n            maxCnt = max(maxCnt, cnt)\n            pre = nums[i]\n            cnt = 1\n    maxCnt = max(maxCnt, cnt)\n    if maxCnt * 2 > n:\n        return maxCnt - (n - maxCnt)\n    else:\n        return 0 if n % 2 == 0 else 1", "tl_gold_code": "int minLengthAfterRemovals(vector<int> &nums) {\n    int maxCnt = 0, cnt = 1, pre = nums[0];\n    int n = nums.size();\n    for(int i = 1; i < n; ++i) {\n        if(pre == nums[i]) cnt++;\n        else {\n            maxCnt = max(maxCnt, cnt);\n            pre = nums[i];\n            cnt = 1;\n        }\n    }\n    maxCnt = max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}"}
{"task": "python_c++", "problem_id": 28, "prediction_id": 0, "pro_prediction": "int numberOfPoints(std::vector<std::vector<int>> nums) {\n    std::vector<int> diff(102, 0);\n    for (auto p : nums) {\n        diff[p[0]] += 1;\n        diff[p[1] + 1] -= 1;\n    }\n    int ans = 0, s = 0;\n    for (auto d : diff) {\n        s += d;\n        ans += (s > 0);\n    }\n    return ans;\n}", "main_fun_name": "numberOfPoints", "raw_prediction": "```cpp\n#include <vector>\n\nint numberOfPoints(std::vector<std::vector<int>> nums) {\n    std::vector<int> diff(102, 0);\n    for (auto p : nums) {\n        diff[p[0]] += 1;\n        diff[p[1] + 1] -= 1;\n    }\n    int ans = 0, s = 0;\n    for (auto d : diff) {\n        s += d;\n        ans += (s > 0);\n    }\n    return ans;\n}\n```", "sl_gold_code": "def numberOfPoints(nums):\n    diff = [0] * 102\n    for p in nums:\n        diff[p[0]] += 1\n        diff[p[1] + 1] -= 1\n    ans = s = 0\n    for d in diff:\n        s += d\n        ans += s > 0\n    return ans", "tl_gold_code": "int numberOfPoints(vector<vector<int>> &nums) {\n    int diff[102]{};\n    for (auto &p: nums) {\n        diff[p[0]]++;\n        diff[p[1] + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d: diff) {\n        s += d;\n        ans += s > 0;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 29, "prediction_id": 0, "pro_prediction": "bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy) {\n        return t != 1;\n    }\n    return std::max(std::abs(sx - fx), std::abs(sy - fy)) <= t;\n}", "main_fun_name": "isReachableAtTime", "raw_prediction": "```cpp\nbool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy) {\n        return t != 1;\n    }\n    return std::max(std::abs(sx - fx), std::abs(sy - fy)) <= t;\n}\n```", "sl_gold_code": "def isReachableAtTime(sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n    if sx == fx and sy == fy:\n        return t != 1\n    return max(abs(sx - fx), abs(sy - fy)) <= t", "tl_gold_code": "bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy)\n        return t != 1;\n    return max(abs(sx - fx), abs(sy - fy)) <= t;\n}"}
{"task": "python_c++", "problem_id": 30, "prediction_id": 0, "pro_prediction": "long long countInterestingSubarrays(std::vector<int>& nums, int modulo, int k) {\n    int n = nums.size();\n    long long ans = 0;\n    std::vector<int> preSum(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        preSum[i+1] = preSum[i] + (nums[i] % modulo == k ? 1 : 0);\n    }\n    std::unordered_map<int, int> count_map;\n    for (int i = 0; i <= n; ++i) {\n        int key = (preSum[i] % modulo - k + modulo) % modulo;\n        if (count_map.count(key)) {\n            ans += count_map[key];\n        }\n        count_map[preSum[i] % modulo]++;\n    }\n    return ans;\n}", "main_fun_name": "countInterestingSubarrays", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n\nlong long countInterestingSubarrays(std::vector<int>& nums, int modulo, int k) {\n    int n = nums.size();\n    long long ans = 0;\n    std::vector<int> preSum(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        preSum[i+1] = preSum[i] + (nums[i] % modulo == k ? 1 : 0);\n    }\n    std::unordered_map<int, int> count_map;\n    for (int i = 0; i <= n; ++i) {\n        int key = (preSum[i] % modulo - k + modulo) % modulo;\n        if (count_map.count(key)) {\n            ans += count_map[key];\n        }\n        count_map[preSum[i] % modulo]++;\n    }\n    return ans;\n}\n```", "sl_gold_code": "def countInterestingSubarrays(nums, modulo, k):\n    n = len(nums)\n    ans = 0\n    preSum = [0] * (n + 1)\n    for i in range(n):\n        preSum[i+1] = preSum[i] + (1 if nums[i] % modulo == k else 0)\n    count_map = {}\n    for i in range(n + 1):\n        key = (preSum[i] % modulo - k + modulo) % modulo\n        if key in count_map:\n            ans += count_map[key]\n        count_map[preSum[i] % modulo] = count_map.get(preSum[i] % modulo, 0) + 1\n    return ans", "tl_gold_code": "long countInterestingSubarrays(vector<int> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    vector<int> preSum(n+1);\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + (nums[i] % modulo == k?1:0);\n    unordered_map<int,int> map;\n    for(int i=0;i<=n;i++){\n        if(map.count((preSum[i]%modulo - k + modulo)%modulo))\n            ans += map[(preSum[i]%modulo - k + modulo)%modulo];\n        map[preSum[i]%modulo]++;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 31, "prediction_id": 0, "pro_prediction": "int minimumOperations(std::string num) {\n    int len_num = num.length();\n    int zero = len_num - 1;\n    if (num.find(\"0\") == std::string::npos) {\n        zero = len_num;\n    }\n    return std::min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero);\n}\n\nint f(std::string target, std::string num) {\n    try {\n        size_t i = num.rfind(target[1]);\n        if (i == std::string::npos) {\n            return num.length();\n        }\n        i = num.substr(0, i).rfind(target[0]);\n        if (i == std::string::npos) {\n            return num.length();\n        }\n        return num.length() - i - 2;\n    } catch (std::out_of_range& e) {\n        return num.length();\n    }\n}", "main_fun_name": "minimumOperations", "raw_prediction": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nint minimumOperations(std::string num) {\n    int len_num = num.length();\n    int zero = len_num - 1;\n    if (num.find(\"0\") == std::string::npos) {\n        zero = len_num;\n    }\n    return std::min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero);\n}\n\nint f(std::string target, std::string num) {\n    try {\n        size_t i = num.rfind(target[1]);\n        if (i == std::string::npos) {\n            return num.length();\n        }\n        i = num.substr(0, i).rfind(target[0]);\n        if (i == std::string::npos) {\n            return num.length();\n        }\n        return num.length() - i - 2;\n    } catch (std::out_of_range& e) {\n        return num.length();\n    }\n}\n```\n\nNote: The code assumes that the input string `num` is a valid string and does not contain any leading zeros.", "sl_gold_code": "def minimumOperations(num):\n    len_num = len(num)\n    zero = len_num - 1 if \"0\" in num else len_num\n    return min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero)\ndef f(target, num):\n    try:\n        i = num.rfind(target[1])\n        if i < 0:\n            return len(num)\n        i = num[:i].rfind(target[0])\n        if i < 0:\n            return len(num)\n        return len(num) - i - 2\n    except IndexError:\n        return len(num)", "tl_gold_code": "int minimumOperations(std::string num) {\n    int len = num.length();\n    int zero = num.find(\"0\") != std::string::npos ? len - 1 : len;\n    return std::min({f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero});\n}\nint f(std::string target, std::string num) {\n    int i = num.rfind(target[1]);\n    if (i < 0) return num.length();\n    i = num.substr(0, i).rfind(target[0]);\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}"}
{"task": "python_c++", "problem_id": 32, "prediction_id": 0, "pro_prediction": "int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; ++i) {\n        std::string s = std::to_string(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; ++j) {\n            sum += s[j] - '0';\n        }\n        for (int j = n / 2; j < n; ++j) {\n            sum -= s[j] - '0';\n        }\n        if (sum == 0) {\n            ans += 1;\n        }\n    }\n    return ans;\n}", "main_fun_name": "countSymmetricIntegers", "raw_prediction": "```cpp\n#include <string>\n\nint countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; ++i) {\n        std::string s = std::to_string(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; ++j) {\n            sum += s[j] - '0';\n        }\n        for (int j = n / 2; j < n; ++j) {\n            sum -= s[j] - '0';\n        }\n        if (sum == 0) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def countSymmetricIntegers(low, high):\n    ans = 0\n    for i in range(low, high + 1):\n        s = str(i)\n        n = len(s)\n        if n % 2 > 0:\n            continue\n        sum = 0\n        for j in range(n // 2):\n            sum += int(s[j])\n        for j in range(n // 2, n):\n            sum -= int(s[j])\n        if sum == 0:\n            ans += 1\n    return ans", "tl_gold_code": "int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        string s = to_string(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s[j];\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s[j];\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 33, "prediction_id": 0, "pro_prediction": "long long maxSum(vector<int> nums, int m, int k) {\n    long long ans = 0;\n    long long s = accumulate(nums.begin(), nums.begin() + k - 1, 0LL);  \n    unordered_map<int, int> cnt;\n    for (int i = 0; i < k - 1; i++) {\n        cnt[nums[i]]++;\n    }\n    for (int out : nums) {\n        int in_ = nums[(k - 1 + nums.size()) % nums.size()];\n        s += in_;  \n        cnt[in_]++;\n\n        if (cnt.size() >= m) {\n            ans = max(ans, s);\n        }\n\n        s -= out;  \n        cnt[out]--;\n        if (cnt[out] == 0) {\n            cnt.erase(out);\n        }\n    }\n    return ans;\n}", "main_fun_name": "maxSum", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nlong long maxSum(vector<int> nums, int m, int k) {\n    long long ans = 0;\n    long long s = accumulate(nums.begin(), nums.begin() + k - 1, 0LL);  \n    unordered_map<int, int> cnt;\n    for (int i = 0; i < k - 1; i++) {\n        cnt[nums[i]]++;\n    }\n    for (int out : nums) {\n        int in_ = nums[(k - 1 + nums.size()) % nums.size()];\n        s += in_;  \n        cnt[in_]++;\n\n        if (cnt.size() >= m) {\n            ans = max(ans, s);\n        }\n\n        s -= out;  \n        cnt[out]--;\n        if (cnt[out] == 0) {\n            cnt.erase(out);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    s = sum(nums[:k - 1])  \n    cnt = Counter(nums[:k - 1])\n    for out, in_ in zip(nums, nums[k - 1:]):\n        s += in_  \n        cnt[in_] += 1\n        if len(cnt) >= m:\n            ans = max(ans, s)\n        s -= out  \n        cnt[out] -= 1\n        if cnt[out] == 0:\n            del cnt[out]\n    return ans", "tl_gold_code": "long long maxSum(vector<int> &nums, int m, int k) {\n    long long ans = 0, sum = 0;\n    unordered_map<int, int> cnt;\n    for (int i = 0; i < k - 1; i++) { \n        sum += nums[i];\n        cnt[nums[i]]++;\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += nums[i]; \n        cnt[nums[i]]++;\n        if (cnt.size() >= m)\n            ans = max(ans, sum);\n        int out = nums[i - k + 1];\n        sum -= out; \n        if (--cnt[out] == 0)\n            cnt.erase(out);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 34, "prediction_id": 0, "pro_prediction": "bool checkStrings(const std::string& s1, const std::string& s2) {\n    std::vector<std::vector<int>> cnt1 = {{0, 0}, {0, 0}};\n    std::vector<std::vector<int>> cnt2 = {{0, 0}, {0, 0}};\n    for (size_t i = 0; i < s1.length(); ++i) {\n        cnt1[i % 2][s1[i] - 'a'] += 1;\n        cnt2[i % 2][s2[i] - 'a'] += 1;\n    }\n    return cnt1 == cnt2;\n}", "main_fun_name": "checkStrings", "raw_prediction": "```cpp\n#include <string>\n#include <vector>\n\nbool checkStrings(const std::string& s1, const std::string& s2) {\n    std::vector<std::vector<int>> cnt1 = {{0, 0}, {0, 0}};\n    std::vector<std::vector<int>> cnt2 = {{0, 0}, {0, 0}};\n    for (size_t i = 0; i < s1.length(); ++i) {\n        cnt1[i % 2][s1[i] - 'a'] += 1;\n        cnt2[i % 2][s2[i] - 'a'] += 1;\n    }\n    return cnt1 == cnt2;\n}\n```", "sl_gold_code": "def checkStrings(s1, s2):\n    cnt1 = [[0] * 26, [0] * 26]\n    cnt2 = [[0] * 26, [0] * 26]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2", "tl_gold_code": "bool checkStrings(string s1, string s2) {\n    int cnt1[2][26]{}, cnt2[2][26]{};\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0;\n}"}
{"task": "python_c++", "problem_id": 35, "prediction_id": 0, "pro_prediction": "bool canBeEqual(std::string s1, std::string s2) {\n    std::vector<std::vector<int>> cnt1(2, std::vector<int>(26, 0));\n    std::vector<std::vector<int>> cnt2(2, std::vector<int>(26, 0));\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return cnt1 == cnt2;\n}", "main_fun_name": "canBeEqual", "raw_prediction": "```cpp\n#include <string>\n#include <vector>\n\nbool canBeEqual(std::string s1, std::string s2) {\n    std::vector<std::vector<int>> cnt1(2, std::vector<int>(26, 0));\n    std::vector<std::vector<int>> cnt2(2, std::vector<int>(26, 0));\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return cnt1 == cnt2;\n}\n```", "sl_gold_code": "def canBeEqual(s1, s2):\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2", "tl_gold_code": "bool canBeEqual(string s1, string s2) {\n    int cnt1[2][26]{}, cnt2[2][26]{};\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0;\n}"}
{"task": "python_c++", "problem_id": 36, "prediction_id": 0, "pro_prediction": "int furthestDistanceFromOrigin(std::string moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves[i] == 'L') {\n            ans -= 1;\n        } else if (moves[i] == 'R') {\n            ans += 1;\n        } else {\n            cn += 1;\n        }\n    }\n    return std::abs(ans) + cn;\n}", "main_fun_name": "furthestDistanceFromOrigin", "raw_prediction": "```cpp\n#include <string>\n#include <iostream>\n\nint furthestDistanceFromOrigin(std::string moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves[i] == 'L') {\n            ans -= 1;\n        } else if (moves[i] == 'R') {\n            ans += 1;\n        } else {\n            cn += 1;\n        }\n    }\n    return std::abs(ans) + cn;\n}\n```\n\nNote: The above code assumes that the input string `moves` contains only 'L', 'R', and other characters. If the input can contain other characters, you may need to add additional error checking or validation.", "sl_gold_code": "def furthestDistanceFromOrigin(moves):\n    cn = 0\n    ans = 0\n    for i in range(len(moves)):\n        if moves[i] == 'L':\n            ans -= 1\n        elif moves[i] == 'R':\n            ans += 1\n        else:\n            cn += 1\n    return abs(ans) + cn", "tl_gold_code": "int furthestDistanceFromOrigin(string moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves[i] == 'L') {\n            ans--;\n        } else if (moves[i] == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return abs(ans) + cn;\n}"}
{"task": "python_c++", "problem_id": 37, "prediction_id": 0, "pro_prediction": "int longestEqualSubarray(vector<int>& nums, int k) {\n    vector<vector<int>> pos(nums.size() + 1);\n    for (size_t i = 0; i < nums.size(); ++i) {\n        pos[nums[i]].push_back(i - pos[nums[i]].size());\n    }\n    int ans = 0;\n    for (const auto& ps : pos) {\n        if (ps.size() <= ans) continue;\n        size_t left = 0;\n        for (size_t right = 0; right < ps.size(); ++right) {\n            while (ps[right] - ps[left] > k) {\n                ++left;\n            }\n            ans = max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}", "main_fun_name": "longestEqualSubarray", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint longestEqualSubarray(vector<int>& nums, int k) {\n    vector<vector<int>> pos(nums.size() + 1);\n    for (size_t i = 0; i < nums.size(); ++i) {\n        pos[nums[i]].push_back(i - pos[nums[i]].size());\n    }\n    int ans = 0;\n    for (const auto& ps : pos) {\n        if (ps.size() <= ans) continue;\n        size_t left = 0;\n        for (size_t right = 0; right < ps.size(); ++right) {\n            while (ps[right] - ps[left] > k) {\n                ++left;\n            }\n            ans = max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    pos = [[] for _ in range(len(nums) + 1)]\n    for i, x in enumerate(nums):\n        pos[x].append(i - len(pos[x]))\n    ans = 0\n    for ps in pos:\n        if len(ps) <= ans: continue\n        left = 0\n        for right, p in enumerate(ps):\n            while p - ps[left] > k:  \n                left += 1\n            ans = max(ans, right - left + 1)\n    return ans", "tl_gold_code": "int longestEqualSubarray(vector<int> &nums, int k) {\n    int n = nums.size(), ans = 0;\n    vector<vector<int>> pos(n + 1);\n    for (int i = 0; i < n; i++)\n        pos[nums[i]].push_back(i - pos[nums[i]].size());\n    for (auto &ps: pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps[right] - ps[left] > k) \n                left++;\n            ans = max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 38, "prediction_id": 0, "pro_prediction": "bool isAcronym(std::vector<std::string> words, std::string s) {\n    if (words.size() != s.size()) {\n        return false;\n    }\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i][0] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "main_fun_name": "isAcronym", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nbool isAcronym(std::vector<std::string> words, std::string s) {\n    if (words.size() != s.size()) {\n        return false;\n    }\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i][0] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "sl_gold_code": "def isAcronym(words, s):\n    if len(words) != len(s):\n        return False\n    for i in range(len(words)):\n        if words[i][0] != s[i]:\n            return False\n    return True", "tl_gold_code": "bool isAcronym(vector<string> &words, string s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words[i][0] != s[i])\n            return false;\n    return true;\n}"}
{"task": "python_c++", "problem_id": 39, "prediction_id": 0, "pro_prediction": "int minimumSum(int n, int k) {\n    int m = std::min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}", "main_fun_name": "minimumSum", "raw_prediction": "```cpp\n#include <iostream>\n\nint minimumSum(int n, int k) {\n    int m = std::min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}\n```\n\nNote: The `std::min` function is used in C++ to find the minimum of two values.", "sl_gold_code": "def minimumSum(n: int, k: int) -> int:\n        m = min(k // 2, n)\n        return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2", "tl_gold_code": "int minimumSum(int n, int k) {\n    int m = min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}"}
{"task": "python_c++", "problem_id": 40, "prediction_id": 0, "pro_prediction": "int minimumOperations(vector<int> nums) {\n    vector<int> g;\n    for (int x : nums) {\n        int j = upper_bound(g, x);\n        if (j == g.size()) {\n            g.push_back(x);\n        } else {\n            g[j] = x;\n        }\n    }\n    return nums.size() - g.size();\n}\n\nint upper_bound(vector<int>& g, int target) {\n    int left = -1, right = g.size();\n    while (left + 1 < right) {\n        int mid = (left + right) / 2;\n        if (g[mid] <= target) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    return right;\n}", "main_fun_name": "minimumOperations", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint minimumOperations(vector<int> nums) {\n    vector<int> g;\n    for (int x : nums) {\n        int j = upper_bound(g, x);\n        if (j == g.size()) {\n            g.push_back(x);\n        } else {\n            g[j] = x;\n        }\n    }\n    return nums.size() - g.size();\n}\n\nint upper_bound(vector<int>& g, int target) {\n    int left = -1, right = g.size();\n    while (left + 1 < right) {\n        int mid = (left + right) / 2;\n        if (g[mid] <= target) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    return right;\n}\n```", "sl_gold_code": "def minimumOperations(nums):\n    g = []\n    for x in nums:\n        j = upper_bound(g, x)\n        if j == len(g):\n            g.append(x)\n        else:\n            g[j] = x\n    return len(nums) - len(g)\ndef upper_bound(g, target):\n    left, right = -1, len(g)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if g[mid] <= target:\n            left = mid\n        else:\n            right = mid\n    return right", "tl_gold_code": "int minimumOperations(vector<int>& nums) {\n    vector<int> g;\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.push_back(x);\n        else g[j] = x;\n    }\n    return nums.size() - g.size();\n}\nint upperBound(vector<int>& g, int target) {\n    int left = -1;\n    int right = g.size();\n    while (left + 1 < right) {\n        int mid = left + (right - left) / 2;\n        if (g[mid] <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}"}
{"task": "python_c++", "problem_id": 41, "prediction_id": 0, "pro_prediction": "int countPairs(vector<int> nums, int target) {\n    sort(nums.begin(), nums.end());\n    int ans = 0;\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left < right) {\n        if (nums[left] + nums[right] < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}", "main_fun_name": "countPairs", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> nums, int target) {\n    sort(nums.begin(), nums.end());\n    int ans = 0;\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left < right) {\n        if (nums[left] + nums[right] < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def countPairs(nums: List[int], target: int) -> int:\n    nums.sort()\n    ans = left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            ans += right - left\n            left += 1\n        else:\n            right -= 1\n    return ans", "tl_gold_code": "int countPairs(vector<int> &nums, int target) {\n    sort(nums.begin(), nums.end());\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums[left] + nums[right] < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 42, "prediction_id": 0, "pro_prediction": "int minAbsoluteDifference(vector<int>& nums, int x) {\n    int ans = INT_MAX;\n    vector<int> pre = {INT_MAX};\n    for (size_t i = 0; i < nums.size() - x; ++i) {\n        insort(pre.begin(), nums[i]);\n        size_t index = lower_bound(pre.begin(), pre.end(), nums[i + x]) - pre.begin();\n        int tmp = min(abs(pre[index] - nums[i + x]), abs(pre[index - 1] - nums[i + x]));\n        ans = min(ans, tmp);\n    }\n    return ans;\n}", "main_fun_name": "minAbsoluteDifference", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint minAbsoluteDifference(vector<int>& nums, int x) {\n    int ans = INT_MAX;\n    vector<int> pre = {INT_MAX};\n    for (size_t i = 0; i < nums.size() - x; ++i) {\n        insort(pre.begin(), nums[i]);\n        size_t index = lower_bound(pre.begin(), pre.end(), nums[i + x]) - pre.begin();\n        int tmp = min(abs(pre[index] - nums[i + x]), abs(pre[index - 1] - nums[i + x]));\n        ans = min(ans, tmp);\n    }\n    return ans;\n}\n```\n\nNote: This code assumes that the `<algorithm>` header has been included.", "sl_gold_code": "def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    ans = float('inf') \n    pre = [float('inf')] \n    for i in range(len(nums)-x):\n        insort_left(pre, nums[i]) \n        index = bisect_left(pre, nums[i+x])\n        tmp = min(abs(pre[index]-nums[i+x]) for index in (index, index-1))\n        ans = min(ans, tmp)\n    return ans", "tl_gold_code": "int minAbsoluteDifference(vector<int> &nums, int x) {\n    int ans = INT_MAX, n = nums.size();\n    set<int> s = {INT_MIN / 2, INT_MAX}; \n    for (int i = x; i < n; i++) {\n        s.insert(nums[i - x]);\n        int y = nums[i];\n        auto it = s.lower_bound(y); \n        ans = min(ans, min(*it - y, y - *prev(it))); \n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 43, "prediction_id": 0, "pro_prediction": "ListNode* doubleIt(ListNode* head) {\n    if (head->val > 4) {\n        head = new ListNode(0, head);\n    }\n    ListNode* cur = head;\n    while (cur) {\n        cur->val = (cur->val * 2) % 10;\n        if (cur->next && cur->next->val > 4) {\n            cur->val += 1;\n        }\n        cur = cur->next;\n    }\n    return head;\n}", "main_fun_name": "doubleIt", "raw_prediction": "```cpp\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* doubleIt(ListNode* head) {\n    if (head->val > 4) {\n        head = new ListNode(0, head);\n    }\n    ListNode* cur = head;\n    while (cur) {\n        cur->val = (cur->val * 2) % 10;\n        if (cur->next && cur->next->val > 4) {\n            cur->val += 1;\n        }\n        cur = cur->next;\n    }\n    return head;\n}\n```\n\nNote: The above code assumes that the `ListNode` struct and `doubleIt` function are defined in the same file. If they are defined in separate files, you will need to include the appropriate header file for the `ListNode` struct.", "sl_gold_code": "def doubleIt(head: Optional[ListNode]) -> Optional[ListNode]:\n    if head.val > 4:\n        head = ListNode(0, head)\n    cur = head\n    while cur:\n        cur.val = cur.val * 2 % 10\n        if cur.next and cur.next.val > 4:\n            cur.val += 1\n        cur = cur.next\n    return head", "tl_gold_code": "ListNode *doubleIt(ListNode *head) {\n    if (head->val > 4)\n        head = new ListNode(0, head);\n    for (auto cur = head; cur; cur = cur->next) {\n        cur->val = cur->val * 2 % 10;\n        if (cur->next && cur->next->val > 4)\n            cur->val++;\n    }\n    return head;\n}"}
{"task": "python_c++", "problem_id": 44, "prediction_id": 0, "pro_prediction": "int maxSum(std::vector<int> nums) {\n    int ans = -1;\n    std::vector<int> max_val(10, INT_MIN);\n    for (int v : nums) {\n        int max_d = *std::max_element(str(v).begin(), str(v).end()) - '0';\n        ans = std::max(ans, v + max_val[max_d]);\n        max_val[max_d] = std::max(max_val[max_d], v);\n    }\n    return ans;\n}", "main_fun_name": "maxSum", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nint maxSum(std::vector<int> nums) {\n    int ans = -1;\n    std::vector<int> max_val(10, INT_MIN);\n    for (int v : nums) {\n        int max_d = *std::max_element(str(v).begin(), str(v).end()) - '0';\n        ans = std::max(ans, v + max_val[max_d]);\n        max_val[max_d] = std::max(max_val[max_d], v);\n    }\n    return ans;\n}\n```", "sl_gold_code": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    max_val = [-inf] * 10\n    for v in nums:\n        max_d = max(map(int, str(v)))\n        ans = max(ans, v + max_val[max_d])\n        max_val[max_d] = max(max_val[max_d], v)\n    return ans", "tl_gold_code": "int maxSum(vector<int> &nums) {\n    int ans = -1;\n    vector<int> max_val(10, INT_MIN);\n    for (int v: nums) {\n        int max_d = 0;\n        for (int x = v; x; x /= 10)\n            max_d = max(max_d, x % 10);\n        ans = max(ans, v + max_val[max_d]);\n        max_val[max_d] = max(max_val[max_d], v);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 45, "prediction_id": 0, "pro_prediction": "std::string finalString(std::string s) {\n    std::deque<char> q;\n    bool tail = true;\n    for (char c : s) {\n        if (c == 'i') {\n            tail = !tail;\n        } else if (tail) {\n            q.push_back(c);\n        } else {\n            q.push_front(c);\n        }\n    }\n    return std::string(q.begin(), q.end()) + (tail ? \"\" : std::string(q.rbegin(), q.rend()));\n}", "main_fun_name": "finalString", "raw_prediction": "```cpp\n#include <deque>\n#include <string>\n\nstd::string finalString(std::string s) {\n    std::deque<char> q;\n    bool tail = true;\n    for (char c : s) {\n        if (c == 'i') {\n            tail = !tail;\n        } else if (tail) {\n            q.push_back(c);\n        } else {\n            q.push_front(c);\n        }\n    }\n    return std::string(q.begin(), q.end()) + (tail ? \"\" : std::string(q.rbegin(), q.rend()));\n}\n```", "sl_gold_code": "def finalString(s: str) -> str:\n    q = deque()\n    tail = True\n    for c in s:\n        if c == 'i':\n            tail = not tail  \n        elif tail:  \n            q.append(c)\n        else:  \n            q.appendleft(c)\n    return ''.join(q if tail else reversed(q))", "tl_gold_code": "string finalString(string s) {\n    deque<char> q;\n    bool tail = true;\n    for (char c: s) {\n        if (c == 'i') tail = !tail;\n        else if (tail) q.push_back(c);\n        else q.push_front(c);\n    }\n    return tail ? string(q.begin(), q.end()) : string(q.rbegin(), q.rend());\n}"}
{"task": "python_c++", "problem_id": 46, "prediction_id": 0, "pro_prediction": "bool canSplitArray(std::vector<int> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) {\n        return true;\n    }\n    for (int i = 1; i < n; i++) {\n        if (nums[i - 1] + nums[i] >= m) {\n            return true;\n        }\n    }\n    return false;\n}", "main_fun_name": "canSplitArray", "raw_prediction": "```cpp\n#include <vector>\n\nbool canSplitArray(std::vector<int> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) {\n        return true;\n    }\n    for (int i = 1; i < n; i++) {\n        if (nums[i - 1] + nums[i] >= m) {\n            return true;\n        }\n    }\n    return false;\n}\n```", "sl_gold_code": "def canSplitArray(nums, m):\n    n = len(nums)\n    if n <= 2: \n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False", "tl_gold_code": "bool canSplitArray(vector<int> &nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums[i - 1] + nums[i] >= m)\n            return true;\n    return false;\n}"}
{"task": "python_c++", "problem_id": 47, "prediction_id": 0, "pro_prediction": "int longestAlternatingSubarray(std::vector<int> a, int threshold) {\n    int ans = 0, i = 0, n = a.size();\n    while (i < n) {\n        if (a[i] % 2 != 0 || a[i] > threshold) {\n            i++;\n        } else {\n            int i0 = i;\n            i++;\n            while (i < n && a[i] <= threshold && (a[i] % 2 == 0) != (a[i - 1] % 2 == 0)) {\n                i++;\n            }\n            ans = std::max(ans, i - i0);\n        }\n    }\n    return ans;\n}", "main_fun_name": "longestAlternatingSubarray", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint longestAlternatingSubarray(std::vector<int> a, int threshold) {\n    int ans = 0, i = 0, n = a.size();\n    while (i < n) {\n        if (a[i] % 2 != 0 || a[i] > threshold) {\n            i++;\n        } else {\n            int i0 = i;\n            i++;\n            while (i < n && a[i] <= threshold && (a[i] % 2 == 0) != (a[i - 1] % 2 == 0)) {\n                i++;\n            }\n            ans = std::max(ans, i - i0);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def longestAlternatingSubarray(a: List[int], threshold: int) -> int:\n    ans, i, n = 0, 0, len(a)\n    while i < n:\n        if a[i] % 2 or a[i] > threshold:\n            i += 1\n        else:\n            i0 = i\n            i += 1\n            while i < n and a[i] <= threshold and a[i] % 2 != a[i - 1] % 2:\n                i += 1 \n            ans = max(ans, i - i0)\n    return ans", "tl_gold_code": "int longestAlternatingSubarray(vector<int>& a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.size();\n    while (i < n) {\n        if (a[i] % 2 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = max(ans, i - i0);\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 48, "prediction_id": 0, "pro_prediction": "int minimumSeconds(vector<int>& nums) {\n    unordered_map<int, vector<int>> pos;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        pos[nums[i]].push_back(i);\n    }\n    int ans = nums.size();\n    for (const auto& a : pos) {\n        a.second.push_back(a.second[0] + nums.size());\n        int mx = 0;\n        for (size_t i = 1; i < a.second.size(); ++i) {\n            mx = max(mx, (a.second[i] - a.second[i-1]) / 2);\n        }\n        ans = min(ans, mx);\n    }\n    return ans;\n}", "main_fun_name": "minimumSeconds", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint minimumSeconds(vector<int>& nums) {\n    unordered_map<int, vector<int>> pos;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        pos[nums[i]].push_back(i);\n    }\n    int ans = nums.size();\n    for (const auto& a : pos) {\n        a.second.push_back(a.second[0] + nums.size());\n        int mx = 0;\n        for (size_t i = 1; i < a.second.size(); ++i) {\n            mx = max(mx, (a.second[i] - a.second[i-1]) / 2);\n        }\n        ans = min(ans, mx);\n    }\n    return ans;\n}\n```", "sl_gold_code": "def minimumSeconds(nums: List[int]) -> int:\n    pos = defaultdict(list)\n    for i, x in enumerate(nums):\n        pos[x].append(i)\n    ans = n = len(nums)\n    for a in pos.values():\n        a.append(a[0] + n)\n        mx = max((j - i) // 2 for i, j in pairwise(a))\n        ans = min(ans, mx)\n    return ans", "tl_gold_code": "int minimumSeconds(vector<int>& nums) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> umap;\n    for (int i = 0; i < n; i++) {\n        umap[nums[i]].push_back(i);\n    }\n    int ans = n;\n    for (auto &iter : umap) {\n        auto &v = iter.second;\n        v.push_back(v[0] + n);\n        int mx = - 1;\n        for (int i = 1; i < v.size(); i++) {\n            mx = max(mx, (v[i] - v[i - 1]) / 2);\n        }\n        ans = min(ans, mx);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 49, "prediction_id": 0, "pro_prediction": "int numberOfEmployeesWhoMetTarget(std::vector<int> hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        if (h >= target) {\n            ans += 1;\n        }\n    }\n    return ans;\n}", "main_fun_name": "numberOfEmployeesWhoMetTarget", "raw_prediction": "```cpp\n#include <vector>\n\nint numberOfEmployeesWhoMetTarget(std::vector<int> hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        if (h >= target) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n        ans = 0\n        for h in hours:\n                if h >= target:\n                        ans += 1\n        return ans", "tl_gold_code": "int numberOfEmployeesWhoMetTarget(vector<int> &hours, int target) {\n    int ans = 0;\n    for (int h: hours) {\n        ans += h >= target;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 50, "prediction_id": 0, "pro_prediction": "std::vector<std::string> splitWordsBySeparator(std::vector<std::string> words, char separator) {\n    std::vector<std::string> ans;\n    for (auto& str : words) {\n        std::string t = \"\";\n        for (char i : str) {\n            if (i == ' ') {\n                continue;\n            }\n            if (i == separator) {\n                if (!t.empty()) {\n                    ans.push_back(t);\n                }\n                t.clear();\n            } else {\n                t += i;\n            }\n        }\n        if (!t.empty()) {\n            ans.push_back(t);\n        }\n    }\n    return ans;\n}", "main_fun_name": "splitWordsBySeparator", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> splitWordsBySeparator(std::vector<std::string> words, char separator) {\n    std::vector<std::string> ans;\n    for (auto& str : words) {\n        std::string t = \"\";\n        for (char i : str) {\n            if (i == ' ') {\n                continue;\n            }\n            if (i == separator) {\n                if (!t.empty()) {\n                    ans.push_back(t);\n                }\n                t.clear();\n            } else {\n                t += i;\n            }\n        }\n        if (!t.empty()) {\n            ans.push_back(t);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def splitWordsBySeparator(words, separator):\n    ans = []\n    def func(str):\n        t = \"\"\n        for i in str:\n            if i == ' ':\n                continue\n            if i == separator:\n                if t:\n                    ans.append(t)\n                t = \"\"\n            else:\n                t += i\n        if t:\n            ans.append(t)\n\n    for i in words:\n        func(i)\n    return ans", "tl_gold_code": "vector<string> splitWordsBySeparator(vector<string>& words, char separator) {\n    vector<string>ans; \n    function<void(string)> func = [&](string str){\n        string t=\"\";\n        for(char i:str){\n            if(i==' ')continue;\n            if(i==separator){\n                if(t.size())ans.push_back(t);\n                t=\"\";\n            }else t+=i;\n        }\n        if(t.size())ans.push_back(t);\n    };\n    for(auto i:words){\n        func(i);\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 51, "prediction_id": 0, "pro_prediction": "std::vector<int> miniMaxSum(std::vector<int> a) {\n    int s = std::accumulate(a.begin(), a.end(), 0);\n    int max_ = *std::max_element(a.begin(), a.end());\n    int min_ = *std::min_element(a.begin(), a.end());\n    return {s - max_, s - min_};\n}", "main_fun_name": "miniMaxSum", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> miniMaxSum(std::vector<int> a) {\n    int s = std::accumulate(a.begin(), a.end(), 0);\n    int max_ = *std::max_element(a.begin(), a.end());\n    int min_ = *std::min_element(a.begin(), a.end());\n    return {s - max_, s - min_};\n}\n```", "sl_gold_code": "def miniMaxSum(a):\n    s = sum(a)\n    max_ = max(a)\n    min_ = min(a)\n    return [s - max_, s - min_]", "tl_gold_code": "vector<int> miniMaxSum(vector<int>& a) {\n    long long sum = std::accumulate(a.begin(), a.end(), 0LL);\n    int max = *std::max_element(a.begin(), a.end());\n    int min = *std::min_element(a.begin(), a.end());\n    return {sum - max, sum - min};\n}"}
{"task": "python_c++", "problem_id": 52, "prediction_id": 0, "pro_prediction": "int pickingNumbers(std::vector<int> a) {\n    std::unordered_map<int, int> d;\n    for (int num : a) {\n        d[num]++;\n    }\n    int best = 0;\n    for (int i = 0; i < 99; i++) {\n        best = std::max(d[i] + d[i+1], best);\n    }\n    return best;\n}", "main_fun_name": "pickingNumbers", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint pickingNumbers(std::vector<int> a) {\n    std::unordered_map<int, int> d;\n    for (int num : a) {\n        d[num]++;\n    }\n    int best = 0;\n    for (int i = 0; i < 99; i++) {\n        best = std::max(d[i] + d[i+1], best);\n    }\n    return best;\n}\n```", "sl_gold_code": "def pickingNumbers(a):\n    from collections import Counter\n    d = Counter(a)\n    best = 0\n    for i in range(99):\n        best = max(d[i] + d[i+1], best)\n    return best", "tl_gold_code": "int pickingNumbers(const vector<int>& a) {\n    unordered_map<int, int> d;\n    for (int num : a) {\n        ++d[num];\n    }\n    int best = 0;\n    for (int i = 0; i < 99; ++i) {\n        best = max(d[i] + d[i + 1], best);\n    }\n    return best;\n}"}
{"task": "python_c++", "problem_id": 53, "prediction_id": 0, "pro_prediction": "int summingSeries(long long n) {\n    return (n * n) % 1000000007;\n}", "main_fun_name": "summingSeries", "raw_prediction": "```cpp\n#include <iostream>\n\nint summingSeries(long long n) {\n    return (n * n) % 1000000007;\n}\n```", "sl_gold_code": "def summingSeries(n):\n    return (n*n) % 1000000007", "tl_gold_code": "int summingSeries(long n) {\n  return ((n % 1000000007)*(n % 1000000007)) % 1000000007;\n}"}
{"task": "python_c++", "problem_id": 54, "prediction_id": 0, "pro_prediction": "std::vector<int> matchingStrings(std::vector<std::string> stringList, std::vector<std::string> queries) {\n    int k = 0;\n    std::vector<int> arr;\n    for (auto i : queries) {\n        for (auto j : stringList) {\n            if (i == j) {\n                k += 1;\n            }\n        }\n        arr.push_back(k);\n        k = 0;\n    }\n    return arr;\n}", "main_fun_name": "matchingStrings", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> matchingStrings(std::vector<std::string> stringList, std::vector<std::string> queries) {\n    int k = 0;\n    std::vector<int> arr;\n    for (auto i : queries) {\n        for (auto j : stringList) {\n            if (i == j) {\n                k += 1;\n            }\n        }\n        arr.push_back(k);\n        k = 0;\n    }\n    return arr;\n}\n```", "sl_gold_code": "def matchingStrings(stringList, queries):\n    k = 0\n    arr = []\n    for i in queries:\n        for j in stringList:\n            if i == j:\n                k += 1\n        arr.append(k)\n        k = 0\n        \n    return [i for i in arr]", "tl_gold_code": "vector<int> matchingStrings(const vector<string>& stringList, const vector<string>& queries) {\n    vector<int> arr;\n    for (const auto& i : queries) {\n        int k = 0;\n        for (const auto& j : stringList) {\n            if (i == j) {\n                ++k;\n            }\n        }\n        arr.push_back(k);\n    }\n    return arr;\n}"}
{"task": "python_c++", "problem_id": 55, "prediction_id": 0, "pro_prediction": "std::vector<int> climbingLeaderboard(const std::vector<int>& ranked, const std::vector<int>& player) {\n    std::unordered_set<int> rank_nums(ranked.begin(), ranked.end());\n    std::vector<int> result;\n    for (int score : player) {\n        std::vector<int> rank = bsearch(rank_nums, score);\n        result.push_back(rank[0]);\n    }\n    return result;\n}\n\nstd::vector<int> bsearch(std::vector<int>& arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0; // ranking\n    while (low <= high) {\n        mid = (high + low) / 2;\n        if (arr[mid] > x) {\n            low = mid + 1;\n        } else if (arr[mid] < x) {\n            high = mid - 1;\n        } else {\n            return {mid + 1};\n        }\n    }\n    return {low + 1};\n}", "main_fun_name": "climbingLeaderboard", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n\nstd::vector<int> bsearch(std::vector<int>& arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0; // ranking\n    while (low <= high) {\n        mid = (high + low) / 2;\n        if (arr[mid] > x) {\n            low = mid + 1;\n        } else if (arr[mid] < x) {\n            high = mid - 1;\n        } else {\n            return {mid + 1};\n        }\n    }\n    return {low + 1};\n}\n\nstd::vector<int> climbingLeaderboard(const std::vector<int>& ranked, const std::vector<int>& player) {\n    std::unordered_set<int> rank_nums(ranked.begin(), ranked.end());\n    std::vector<int> result;\n    for (int score : player) {\n        std::vector<int> rank = bsearch(rank_nums, score);\n        result.push_back(rank[0]);\n    }\n    return result;\n}\n```\n\nNote: The above code assumes that the `bsearch` function should only return a single value instead of a list with a single value as in the original Python code. If the returned list is necessary, you can modify the return type and usage accordingly.", "sl_gold_code": "def bsearch(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0  # ranking\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] > x:\n            low = mid + 1\n        elif arr[mid] < x:\n            high = mid - 1\n        else:\n            return mid + 1\n    return low + 1\ndef climbingLeaderboard(ranked, player):\n    from collections import OrderedDict\n    rank_nums = list(OrderedDict.fromkeys(ranked))\n    result = []\n    for score in player:\n        rank = bsearch(rank_nums, score)\n        result.append(rank)\n    return result", "tl_gold_code": "int bsearch(const vector<int>& arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0;\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n        if (arr[mid] < x) {\n            high = mid - 1;\n        } else if (arr[mid] > x) {\n            low = mid + 1;\n        } else {\n            return mid + 1;\n        }\n    }\n    return low + 1;\n}\nvector<int> climbingLeaderboard(vector<int>& ranked, const vector<int>& player) {\n    unordered_set<int> rank_set(ranked.begin(), ranked.end());\n    vector<int> rank_nums(rank_set.begin(), rank_set.end());\n    sort(rank_nums.begin(), rank_nums.end(), greater<int>());\n    vector<int> result;\n    for (int score : player) {\n        int rank = bsearch(rank_nums, score);\n        result.push_back(rank);\n    }\n    return result;\n}"}
{"task": "python_c++", "problem_id": 56, "prediction_id": 0, "pro_prediction": "long long arrayManipulation(int n, std::vector<std::vector<int>> queries) {\n    std::vector<long long> arr(n + 2, 0);\n    long long max_val = 0;\n    long long sum_val = 0;\n\n    for (const auto& query : queries) {\n        arr[query[0]] += query[2];\n        arr[query[1] + 1] -= query[2];\n    }\n\n    for (int i = 0; i < arr.size(); ++i) {\n        sum_val += arr[i];\n        max_val = std::max(max_val, sum_val);\n    }\n\n    return max_val;\n}", "main_fun_name": "arrayManipulation", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nlong long arrayManipulation(int n, std::vector<std::vector<int>> queries) {\n    std::vector<long long> arr(n + 2, 0);\n    long long max_val = 0;\n    long long sum_val = 0;\n\n    for (const auto& query : queries) {\n        arr[query[0]] += query[2];\n        arr[query[1] + 1] -= query[2];\n    }\n\n    for (int i = 0; i < arr.size(); ++i) {\n        sum_val += arr[i];\n        max_val = std::max(max_val, sum_val);\n    }\n\n    return max_val;\n}\n```", "sl_gold_code": "def arrayManipulation(n, queries):\n    arr = [0] * (n + 2)\n    max_val = 0\n    sum_val = 0\n    \n    for query in queries:\n        arr[query[0]] += query[2]\n        arr[query[1] + 1] -= query[2]\n    \n    for val in arr:\n        sum_val += val\n        max_val = max(max_val, sum_val)\n        \n    return max_val", "tl_gold_code": "long arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long> arr(n + 2, 0);\n    long max = 0; long sum = 0;\n    \n    for(auto query: queries){\n        arr[query[0]] += query[2];\n        arr[query[1] + 1] -= query[2];\n    }\n    \n    for (auto val : arr){\n        sum += val;\n        if(sum > max) max = sum;\n    }\n    return max;\n}"}
{"task": "python_c++", "problem_id": 57, "prediction_id": 0, "pro_prediction": "ListNode* deleteNode(ListNode* llist, int position) {\n    if (!llist) {\n        return nullptr;\n    }\n    if (position == 0) {\n        return llist->next;\n    }\n    ListNode* current = llist;\n    ListNode* previous = nullptr;\n    int pointer = 1;\n    while (pointer < position + 1) {\n        previous = current;\n        current = current->next;\n        pointer += 1;\n    }\n    previous->next = current->next;\n    return llist;\n}", "main_fun_name": "deleteNode", "raw_prediction": "```cpp\n#include <iostream>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* deleteNode(ListNode* llist, int position) {\n    if (!llist) {\n        return nullptr;\n    }\n    if (position == 0) {\n        return llist->next;\n    }\n    ListNode* current = llist;\n    ListNode* previous = nullptr;\n    int pointer = 1;\n    while (pointer < position + 1) {\n        previous = current;\n        current = current->next;\n        pointer += 1;\n    }\n    previous->next = current->next;\n    return llist;\n}\n```\n\nNote: The above code assumes that the `ListNode` struct is defined in the same file. If it is not, you will need to include the appropriate header file or define the struct before the function.", "sl_gold_code": "def deleteNode(llist, position):\n    if not llist:\n        return \n    if position == 0:\n        return llist.next\n    current = previous = llist\n    pointer = 1\n    while pointer < position+1:\n        previous = current\n        current = current.next\n        pointer += 1\n    previous.next = current.next\n    return llist", "tl_gold_code": "SinglyLinkedListNode* deleteNode(SinglyLinkedListNode* llist, int position) {\n    if (llist == nullptr) {\n        return nullptr;\n    }\n    if (position == 0) {\n        SinglyLinkedListNode* newHead = llist->next;\n        delete llist; \n        return newHead;\n    }\n    SinglyLinkedListNode* current = llist;\n    for (int i = 0; current != nullptr && i < position - 1; ++i) {\n        current = current->next;\n    }\n    if (current == nullptr || current->next == nullptr) {\n        return llist;\n    }\n    SinglyLinkedListNode* nodeToDelete = current->next;\n    current->next = current->next->next;\n    delete nodeToDelete; \n    return llist;\n}"}
{"task": "python_c++", "problem_id": 58, "prediction_id": 0, "pro_prediction": "bool evaluateTree(TreeNode* root) {\n    if (!root->left) {\n        return bool(root->val);\n    }\n    bool l = evaluateTree(root->left.value());\n    bool r = evaluateTree(root->right.value());\n    return (root->val == 2) ? (l || r) : (l && r);\n}", "main_fun_name": "evaluateTree", "raw_prediction": "```cpp\n#include <optional>\n\nclass TreeNode {\npublic:\n    int val;\n    std::optional<TreeNode*> left;\n    std::optional<TreeNode*> right;\n\n    TreeNode(int val) : val(val), left(std::nullopt), right(std::nullopt) {}\n};\n\nbool evaluateTree(TreeNode* root) {\n    if (!root->left) {\n        return bool(root->val);\n    }\n    bool l = evaluateTree(root->left.value());\n    bool r = evaluateTree(root->right.value());\n    return (root->val == 2) ? (l || r) : (l && r);\n}\n```\n\nNote: The above code assumes that the `TreeNode` class has already been defined in the same file or a separate header file.", "sl_gold_code": "def evaluateTree(root: Optional[TreeNode]) -> bool:\n    if root.left is None:\n        return bool(root.val)\n    l = evaluateTree(root.left)\n    r = evaluateTree(root.right)\n    return l or r if root.val == 2 else l and r", "tl_gold_code": "bool evaluateTree(TreeNode* root) {\n    if (!root->left) {\n        return root->val;\n    }\n    bool l = evaluateTree(root->left);\n    bool r = evaluateTree(root->right);\n    return root->val == 2 ? l or r : l and r;\n}"}
{"task": "python_c++", "problem_id": 59, "prediction_id": 0, "pro_prediction": "int andXorOr(std::vector<int> a) {\n    int m = 0;\n    std::vector<int> s;\n    for (int i : a) {     \n        while (!s.empty() && s.back() >= i) {\n            m = std::max(m, i^s.back());\n            s.pop_back();\n        }\n        if (!s.empty()) {\n            m = std::max(m, i^s.back());\n        }\n        s.push_back(i);\n    }\n    return m;\n}", "main_fun_name": "andXorOr", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint andXorOr(std::vector<int> a) {\n    int m = 0;\n    std::vector<int> s;\n    for (int i : a) {     \n        while (!s.empty() && s.back() >= i) {\n            m = std::max(m, i^s.back());\n            s.pop_back();\n        }\n        if (!s.empty()) {\n            m = std::max(m, i^s.back());\n        }\n        s.push_back(i);\n    }\n    return m;\n}\n```", "sl_gold_code": "def andXorOr(a):\n    m = 0\n    s = []\n    for i in a:     \n        while s and s[-1] >= i:\n            m = max(m, i^s.pop())\n        if s:\n            m = max(m, i^s[-1])\n        s.append(i)\n    return m", "tl_gold_code": "int andXorOr(vector<int> &a) {\n    int m = 0;\n    stack<int> s;\n    for (int i : a) {\n        while (!s.empty() && s.top() >= i) {\n            m = max(m, i ^ s.top());\n            s.pop();\n        }\n        if (!s.empty()) {\n            m = max(m, i ^ s.top());\n        }\n        s.push(i);\n    }\n    return m;\n}"}
{"task": "python_c++", "problem_id": 60, "prediction_id": 0, "pro_prediction": "std::vector<int> missingNumbers(std::vector<int> arr, std::vector<int> brr) {\n    std::unordered_map<int, int> mp;\n    for (int num : brr) {\n        mp[num]++;\n    }\n    \n    for (int num : arr) {\n        if (mp.find(num) != mp.end()) {\n            mp[num]--;\n        }\n    }\n    \n    std::vector<int> result;\n    for (auto& pair : mp) {\n        if (pair.second > 0) {\n            result.push_back(pair.first);\n        }\n    }\n    \n    std::sort(result.begin(), result.end());\n    \n    return result;\n}", "main_fun_name": "missingNumbers", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nstd::vector<int> missingNumbers(std::vector<int> arr, std::vector<int> brr) {\n    std::unordered_map<int, int> mp;\n    for (int num : brr) {\n        mp[num]++;\n    }\n    \n    for (int num : arr) {\n        if (mp.find(num) != mp.end()) {\n            mp[num]--;\n        }\n    }\n    \n    std::vector<int> result;\n    for (auto& pair : mp) {\n        if (pair.second > 0) {\n            result.push_back(pair.first);\n        }\n    }\n    \n    std::sort(result.begin(), result.end());\n    \n    return result;\n}\n```", "sl_gold_code": "def missingNumbers(arr, brr):\n    from collections import Counter\n    \n    mp = Counter(brr)\n    for num in arr:\n        mp[num] -= 1\n        \n    result = sorted([num for num, count in mp.items() if count > 0])\n    \n    return result", "tl_gold_code": "vector<int> missingNumbers(vector<int> arr, vector<int> brr) {\n    map<int, int> mp;\n    for(int i = 0; i < brr.size(); i++) mp[brr[i]]++;\n    for(int i = 0; i < arr.size(); i++) mp[arr[i]]--;\n    map<int, int>::iterator it;\n    vector<int> result;\n    for(it = mp.begin(); it != mp.end(); it++)\n        if(it->second > 0) result.push_back(it->first);\n    \n    return result;\n}"}
{"task": "python_c++", "problem_id": 61, "prediction_id": 0, "pro_prediction": "long long maximumSum(std::vector<long long> a, long long m) {\n    long long max_sum = 0;\n    long long current_sum = 0;\n    std::vector<long long> sorted_sums = {0};\n    for (auto value : a) {\n        current_sum = (current_sum + value) % m;\n        max_sum = std::max(max_sum, current_sum);\n        auto it = std::upper_bound(sorted_sums.begin(), sorted_sums.end(), current_sum);\n        if (it != sorted_sums.end()) {\n            long long possible_max = (current_sum - *it + m) % m;\n            max_sum = std::max(max_sum, possible_max);\n        }\n        sorted_sums.insert(it, current_sum);\n    }\n    return max_sum;\n}", "main_fun_name": "maximumSum", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nlong long maximumSum(std::vector<long long> a, long long m) {\n    long long max_sum = 0;\n    long long current_sum = 0;\n    std::vector<long long> sorted_sums = {0};\n    for (auto value : a) {\n        current_sum = (current_sum + value) % m;\n        max_sum = std::max(max_sum, current_sum);\n        auto it = std::upper_bound(sorted_sums.begin(), sorted_sums.end(), current_sum);\n        if (it != sorted_sums.end()) {\n            long long possible_max = (current_sum - *it + m) % m;\n            max_sum = std::max(max_sum, possible_max);\n        }\n        sorted_sums.insert(it, current_sum);\n    }\n    return max_sum;\n}\n```\n\nNote: The `bisect_right` and `insort` functions from the Python code have been replaced with their C++ equivalents `std::upper_bound` and `std::insert`, respectively.", "sl_gold_code": "def maximumSum(a, m):\n    max_sum = 0\n    current_sum = 0\n    sorted_sums = [0] \n    for value in a:\n        current_sum = (current_sum + value) % m\n        max_sum = max(max_sum, current_sum)\n        idx = bisect_right(sorted_sums, current_sum)\n        if idx < len(sorted_sums):\n            possible_max = (current_sum - sorted_sums[idx] + m) % m\n            max_sum = max(max_sum, possible_max)\n        insort(sorted_sums, current_sum)\n    return max_sum", "tl_gold_code": "long maximumSum(vector<long> &a, long m) {\n    long long max=0, sum=0;\n    set<long long> s;\n    for (auto i=a.begin() ; i!=a.end() ; i++) {\n        sum=(sum+*i)%m;\n        if (sum>max) max=sum;\n        auto b=s.upper_bound(sum);\n        if (b!=s.end()) {\n            long long possiblemax=(sum-*b+m)%m;\n            if (possiblemax>max) max=possiblemax;\n        }\n        s.insert(sum);\n    }\n    return max;\n}"}
{"task": "python_c++", "problem_id": 62, "prediction_id": 0, "pro_prediction": "int formingMagicSquare(std::vector<std::vector<int>>& s) {\n    std::vector<std::vector<std::vector<int>>> magicSquares = {\n        {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n        {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n        {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n        {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n        {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n        {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n        {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n        {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n    };\n    int minCost = 8 * 3;\n    for (const auto& magicSquare : magicSquares) {\n        int cost = 0;\n        for (size_t i = 0; i < 3; ++i) {\n            for (size_t j = 0; j < 3; ++j) {\n                cost += std::abs(s[i][j] - magicSquare[i][j]);\n            }\n        }\n        minCost = std::min(cost, minCost);\n    }\n    return minCost;\n}", "main_fun_name": "formingMagicSquare", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint formingMagicSquare(std::vector<std::vector<int>>& s) {\n    std::vector<std::vector<std::vector<int>>> magicSquares = {\n        {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n        {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n        {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n        {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n        {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n        {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n        {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n        {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n    };\n    int minCost = 8 * 3;\n    for (const auto& magicSquare : magicSquares) {\n        int cost = 0;\n        for (size_t i = 0; i < 3; ++i) {\n            for (size_t j = 0; j < 3; ++j) {\n                cost += std::abs(s[i][j] - magicSquare[i][j]);\n            }\n        }\n        minCost = std::min(cost, minCost);\n    }\n    return minCost;\n}\n```", "sl_gold_code": "def formingMagicSquare(s):\n    magicSquares = [\n        [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\n        [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\n        [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\n        [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\n        [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\n        [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\n        [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\n        [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    ]\n    minCost = 8*3\n    for magicSquare in magicSquares:\n        cost = 0\n        for i in range(3):\n            for j in range(3):\n                cost += abs(s[i][j] - magicSquare[i][j])\n        minCost = min(cost , minCost)\n    return minCost", "tl_gold_code": "int formingMagicSquare(vector<vector<int>>& s) {\n    vector<vector<vector<int>>> magicSquares = {\n        {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n        {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n        {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n        {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n        {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n        {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n        {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n        {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n    };\n    int minCost = 8 * 3;\n    for (const auto& magicSquare : magicSquares) {\n        int cost = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                cost += abs(s[i][j] - magicSquare[i][j]);\n            }\n        }\n        minCost = min(cost, minCost);\n    }\n    return minCost;\n}"}
{"task": "python_c++", "problem_id": 63, "prediction_id": 0, "pro_prediction": "std::string isFibo(long long n) {\n    long long start = 0;\n    long long last = 1;\n    while (last <= n) {\n        long long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}", "main_fun_name": "isFibo", "raw_prediction": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string isFibo(long long n) {\n    long long start = 0;\n    long long last = 1;\n    while (last <= n) {\n        long long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}\n```\n```", "sl_gold_code": "def isFibo(n):\n    start = 0\n    last = 1\n    while last <= n:\n        tmp = last + start\n        start = last\n        last = tmp\n        if last== n:\n            return \"IsFibo\"\n    return \"IsNotFibo\"", "tl_gold_code": "string isFibo(long long n) {\n    long long start = 0, last = 1;\n    while (last <= n) {\n        long long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}"}
{"task": "python_c++", "problem_id": 64, "prediction_id": 0, "pro_prediction": "int solve(long long l, long long r) {\n    std::set<long long> seen;\n    std::deque<int> q;\n    for (int i = 0; i < 10; i++) {\n        q.push_back(i);\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        if (std::to_string(u).length() >= 20) {\n            continue;\n        }\n        if (seen.find(u) != seen.end()) {\n            continue;\n        }\n        seen.insert(u);\n        int length = std::to_string(u).length();\n        for (int k = length; k < length + 5; k++) {\n            if (std::to_string(u * k).length() == k) {\n                q.push_back(u * k);\n            }\n        }\n    }\n    int sum = 0;\n    for (const auto& s : seen) {\n        if (l <= s && s <= r) {\n            sum++;\n        }\n    }\n    std::cout << \"[\" << l << \", \" << r << \"]: \" << sum << std::endl;\n    return sum;\n}", "main_fun_name": "solve", "raw_prediction": "```cpp\n#include <iostream>\n#include <string>\n#include <set>\n#include <deque>\n\nint solve(long long l, long long r) {\n    std::set<long long> seen;\n    std::deque<int> q;\n    for (int i = 0; i < 10; i++) {\n        q.push_back(i);\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        if (std::to_string(u).length() >= 20) {\n            continue;\n        }\n        if (seen.find(u) != seen.end()) {\n            continue;\n        }\n        seen.insert(u);\n        int length = std::to_string(u).length();\n        for (int k = length; k < length + 5; k++) {\n            if (std::to_string(u * k).length() == k) {\n                q.push_back(u * k);\n            }\n        }\n    }\n    int sum = 0;\n    for (const auto& s : seen) {\n        if (l <= s && s <= r) {\n            sum++;\n        }\n    }\n    std::cout << \"[\" << l << \", \" << r << \"]: \" << sum << std::endl;\n    return sum;\n}\n```\n\nNote: The above code assumes that the input values of `l` and `r` are within the range of `long long`. If the input values can be outside this range, you may need to modify the code accordingly.", "sl_gold_code": "def solve(l, r):\n    from collections import deque\n    seen = set()\n    q = deque()\n    q.extend(range(10))\n    while q:\n        u = q.pop()\n        if len(str(u)) >= 20:\n            continue\n        if u in seen:\n            continue\n        seen.add(u)\n        length = len(str(u))\n        for k in range(length, length + 5):\n            if len(str(u * k)) == k:\n                q.append(u * k)\n    print(f'[{l}, {r}]: {sum(l <= s <= r for s in seen)}')\n    return sum(l <= s <= r for s in seen)", "tl_gold_code": "int solve(long long l, long long r) {\n    set<long long> seen;\n    deque<long long> q;\n    for (int i = 0; i < 10; ++i) q.push_back(i);\n    while (!q.empty()) {\n        long long u = q.back();\n        q.pop_back();\n        if (to_string(u).length() >= 20) continue;\n        if (seen.find(u) != seen.end()) continue;\n        seen.insert(u);\n        int length = to_string(u).length();\n        for (int k = length; k < length + 5; ++k) {\n            if (to_string(u * k).length() == k) {\n                q.push_back(u * k);\n            }\n        }\n    }\n    int count = 0;\n    for (const auto &s : seen) {\n        if (l <= s && s <= r) count++;\n    }\n    cout << \"[\" << l << \", \" << r << \"]: \" << count << endl;\n    return count;\n}"}
{"task": "python_c++", "problem_id": 65, "prediction_id": 0, "pro_prediction": "std::vector<std::string> cavityMap(std::vector<std::string> grid) {\n    for (int k = 1; k < grid.size() - 1; ++k) {\n        std::string& i = grid[k];\n        std::string d = grid[k + 1];\n        std::string u = grid[k - 1];\n        for (int j = 1; j < i.size() - 1; ++j) {\n            if ((i[j - 1] < i[j]) && (i[j] > i[j + 1]) && (d[j] < i[j]) && (i[j] > u[j])) {\n                i[j] = 'X';\n            }\n        }\n    }\n    return grid;\n}", "main_fun_name": "cavityMap", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> cavityMap(std::vector<std::string> grid) {\n    for (int k = 1; k < grid.size() - 1; ++k) {\n        std::string& i = grid[k];\n        std::string d = grid[k + 1];\n        std::string u = grid[k - 1];\n        for (int j = 1; j < i.size() - 1; ++j) {\n            if ((i[j - 1] < i[j]) && (i[j] > i[j + 1]) && (d[j] < i[j]) && (i[j] > u[j])) {\n                i[j] = 'X';\n            }\n        }\n    }\n    return grid;\n}\n```", "sl_gold_code": "def cavityMap(grid):\n    for k in range(1,len(grid)-1):\n        i = grid[k]\n        d = grid[k+1]\n        u = grid[k-1]\n        for j in range(1, len(grid)-1):\n            if (i[j-1] < i[j] > i[j+1]) and (d[j] <i[j] > u[j]):\n                x= list(grid[k])\n                x[j] = \"X\"\n                grid[k] = \"\".join(x)\n    return grid", "tl_gold_code": "vector<string> cavityMap(vector<string> grid) {\n    for (size_t k = 1; k < grid.size() - 1; ++k) {\n        for (size_t j = 1; j < grid[k].size() - 1; ++j) {\n            if (grid[k][j - 1] < grid[k][j] && grid[k][j] > grid[k][j + 1] &&\n                grid[k + 1][j] < grid[k][j] && grid[k - 1][j] < grid[k][j]) {\n                grid[k][j] = 'X';\n            }\n        }\n    }\n    return grid;\n}"}
{"task": "python_c++", "problem_id": 66, "prediction_id": 0, "pro_prediction": "long long solve(int a, int b) {\n    int m = a;\n    int n = b;\n    long long ans = std::min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}", "main_fun_name": "solve", "raw_prediction": "```cpp\n#include <iostream>\n#include <algorithm>\n\nlong long solve(int a, int b) {\n    int m = a;\n    int n = b;\n    long long ans = std::min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}\n```", "sl_gold_code": "def solve(a, b):\n    m = a\n    n = b\n    ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)))\n    return m*n - 1", "tl_gold_code": "long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}"}
{"task": "python_c++", "problem_id": 67, "prediction_id": 0, "pro_prediction": "int minimumLoss(std::vector<long> price) {\n    std::unordered_map<long, int> map_index;\n    for (int i = 0; i < price.size(); ++i) {\n        map_index[price[i]] = i;\n    }\n    std::sort(price.begin(), price.end());\n    int min_loss = std::numeric_limits<int>::max();\n    for (int i = 0; i < price.size() - 1; ++i) {\n        int current_loss = price[i+1] - price[i];\n        if (current_loss < min_loss && map_index[price[i]] > map_index[price[i+1]]) {\n            min_loss = current_loss;\n        }\n    }\n    return min_loss;\n}", "main_fun_name": "minimumLoss", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint minimumLoss(std::vector<long> price) {\n    std::unordered_map<long, int> map_index;\n    for (int i = 0; i < price.size(); ++i) {\n        map_index[price[i]] = i;\n    }\n    std::sort(price.begin(), price.end());\n    int min_loss = std::numeric_limits<int>::max();\n    for (int i = 0; i < price.size() - 1; ++i) {\n        int current_loss = price[i+1] - price[i];\n        if (current_loss < min_loss && map_index[price[i]] > map_index[price[i+1]]) {\n            min_loss = current_loss;\n        }\n    }\n    return min_loss;\n}\n```", "sl_gold_code": "def minimumLoss(price):\n    map_index = {p: i for i, p in enumerate(price)}\n    price.sort()\n    min_loss = float('inf')\n    for i in range(len(price) - 1):\n        current_loss = price[i+1] - price[i]\n        if current_loss < min_loss and map_index[price[i]] > map_index[price[i+1]]:\n            min_loss = current_loss\n    return int(min_loss)", "tl_gold_code": "int minimumLoss(vector<long> price) {\n    unordered_map<long, int> map;\n    for (int i = 0; i < price.size(); ++i) {\n        map[price[i]] = i;\n    }\n    sort(price.begin(), price.end());\n    long min = numeric_limits<int>::max();\n    for (int i = 0; i < price.size() - 1; ++i) {\n        long currentMin = price[i + 1] - price[i];\n        if (currentMin < min && map[price[i]] > map[price[i + 1]]) min = currentMin;\n    }\n    return static_cast<int>(min);\n}"}
{"task": "python_c++", "problem_id": 68, "prediction_id": 0, "pro_prediction": "std::string dayOfProgrammer(int year) {\n    if (1918 == year) {\n        return \"26.09.1918\";\n    }\n    bool leap_year = true;\n    if (year % 4 || (year > 1918 && !(year % 100) && year % 400)) {\n        leap_year = false;\n    }\n    std::string month = leap_year ? \"12\" : \"13\";\n    return month + \".09.\" + std::to_string(year);\n}", "main_fun_name": "dayOfProgrammer", "raw_prediction": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string dayOfProgrammer(int year) {\n    if (1918 == year) {\n        return \"26.09.1918\";\n    }\n    bool leap_year = true;\n    if (year % 4 || (year > 1918 && !(year % 100) && year % 400)) {\n        leap_year = false;\n    }\n    std::string month = leap_year ? \"12\" : \"13\";\n    return month + \".09.\" + std::to_string(year);\n}\n```\n```", "sl_gold_code": "def dayOfProgrammer(year):\n    if 1918==year:\n        return '26.09.1918'\n    leap_year = True\n    if year % 4 or year > 1918 and not year % 100 and year % 400:\n        leap_year = False\n    return '.'.join(['12' if leap_year else '13', '09', str(year)])", "tl_gold_code": "string dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    bool leap_year = true;\n    if ((year % 4 != 0) || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leap_year = false;\n    }\n    return leap_year ? \"12.09.\" + to_string(year) : \"13.09.\" + to_string(year);\n}"}
{"task": "python_c++", "problem_id": 69, "prediction_id": 0, "pro_prediction": "std::vector<int> acmTeam(std::vector<std::string> topic) {\n    int teamLen = topic.size();\n    int topicLen = topic[0].size();\n    int maxKnown = 0;\n    int maxTeams = 0;\n    for (int i = 0; i < teamLen; i++) {\n        std::string t1 = topic[i];\n        for (int j = i + 1; j < teamLen; j++) {\n            int know = 0;\n            std::string t2 = topic[j];\n            for (int k = 0; k < topicLen; k++) {\n                if (t1[k] == '1' || t2[k] == '1') {\n                    know += 1;\n                }\n            }\n            if (know == maxKnown) {\n                maxTeams += 1;\n            } else if (know > maxKnown) {\n                maxKnown = know;\n                maxTeams = 1;\n            }\n        }\n    }\n    std::vector<int> result = {maxKnown, maxTeams};\n    return result;\n}", "main_fun_name": "acmTeam", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> acmTeam(std::vector<std::string> topic) {\n    int teamLen = topic.size();\n    int topicLen = topic[0].size();\n    int maxKnown = 0;\n    int maxTeams = 0;\n    for (int i = 0; i < teamLen; i++) {\n        std::string t1 = topic[i];\n        for (int j = i + 1; j < teamLen; j++) {\n            int know = 0;\n            std::string t2 = topic[j];\n            for (int k = 0; k < topicLen; k++) {\n                if (t1[k] == '1' || t2[k] == '1') {\n                    know += 1;\n                }\n            }\n            if (know == maxKnown) {\n                maxTeams += 1;\n            } else if (know > maxKnown) {\n                maxKnown = know;\n                maxTeams = 1;\n            }\n        }\n    }\n    std::vector<int> result = {maxKnown, maxTeams};\n    return result;\n}\n```", "sl_gold_code": "def acmTeam(topic):\n    teamLen = len(topic)\n    topicLen = len(topic[0])\n    maxKnown = 0\n    maxTeams = 0\n    for i in range(teamLen):\n        t1 = topic[i]\n        for j in range(i + 1, teamLen):\n            know = 0\n            t2 = topic[j]\n            for k in range(topicLen):\n                if t1[k] == '1' or t2[k] == '1':\n                    know += 1\n            if know == maxKnown:\n                maxTeams += 1\n            elif know > maxKnown:\n                maxKnown = know\n                maxTeams = 1\n    return [maxKnown, maxTeams]", "tl_gold_code": "vector<int> acmTeam(const vector<string>& topic) {\n    int teamLen = topic.size();\n    int topicLen = topic[0].size();\n    int maxKnown = 0;\n    int maxTeams = 0;\n    for (int i = 0; i < teamLen; ++i) {\n        const string& t1 = topic[i];\n        for (int j = i + 1; j < teamLen; ++j) {\n            int know = 0;\n            const string& t2 = topic[j];\n            for (int k = 0; k < topicLen; ++k) {\n                if (t1[k] == '1' || t2[k] == '1')\n                    ++know;\n            }\n            if (know == maxKnown)\n                ++maxTeams;\n            else if (know > maxKnown) {\n                maxKnown = know;\n                maxTeams = 1;\n            }\n        }\n    }\n    return {maxKnown, maxTeams};\n}"}
{"task": "python_c++", "problem_id": 70, "prediction_id": 0, "pro_prediction": "std::string timeInWords(int h, int m) {\n    std::vector<std::string> hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"};\n    std::vector<std::string> minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\",\n                                       \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \n                                       \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \n                                       \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[(h % 12)];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (0 < m && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}", "main_fun_name": "timeInWords", "raw_prediction": "```cpp\n#include <string>\n#include <vector>\n\nstd::string timeInWords(int h, int m) {\n    std::vector<std::string> hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"};\n    std::vector<std::string> minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\",\n                                       \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \n                                       \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \n                                       \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[(h % 12)];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (0 < m && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}\n```", "sl_gold_code": "def timeInWords(h, m):\n    hour = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"]\n    minutes = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\",\n               \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \n               \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \n               \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"]\n    if m == 0:\n        return hour[h - 1] + \" o' clock\"\n    elif m == 15:\n        return \"quarter past \" + hour[h - 1]\n    elif m == 30:\n        return \"half past \" + hour[h - 1]\n    elif m == 45:\n        return \"quarter to \" + hour[(h % 12)]\n    elif m == 1:\n        return minutes[m - 1] + \" minute past \" + hour[h - 1]\n    elif 0 < m < 30:\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1]\n    else:\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12]", "tl_gold_code": "string timeInWords(int h, int m) {\n    vector<string> hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                                     \"ten\", \"eleven\", \"twelve\"};\n    vector<string> minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                                        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                                        \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                                        \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                                        \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[h % 12];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (m > 0 && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}"}
{"task": "python_c++", "problem_id": 71, "prediction_id": 0, "pro_prediction": "int collectTheCoins(std::vector<int> coins, std::vector<std::vector<int>> edges) {\n    int n = coins.size();\n    std::vector<std::vector<int>> g(n);\n    for (auto &edge : edges) {\n        g[edge[0]].push_back(edge[1]);\n        g[edge[1]].push_back(edge[0]);\n    }\n    std::vector<int> deg(n);\n    for (auto &neighbors : g) {\n        deg[neighbors[0]] += neighbors.size() - 1;\n    }\n    int left_edges = n - 1;\n    std::vector<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] == 1 && coins[i] == 0) {\n            q.push_back(i);\n        }\n    }\n    while (!q.empty()) {\n        left_edges--;\n        int u = q.back();\n        q.pop_back();\n        for (int v : g[u]) {\n            deg[v]--;\n            if (deg[v] == 1 && coins[v] == 0) {\n                q.push_back(v);\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] == 1 && coins[i]) {\n            q.push_back(i);\n        }\n    }\n    left_edges -= q.size();\n    for (int x : q) {\n        for (int y : g[x]) {\n            deg[y]--;\n            if (deg[y] == 1) {\n                left_edges--;\n            }\n        }\n    }\n    return std::max(left_edges * 2, 0);\n}", "main_fun_name": "collectTheCoins", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint collectTheCoins(std::vector<int> coins, std::vector<std::vector<int>> edges) {\n    int n = coins.size();\n    std::vector<std::vector<int>> g(n);\n    for (auto &edge : edges) {\n        g[edge[0]].push_back(edge[1]);\n        g[edge[1]].push_back(edge[0]);\n    }\n    std::vector<int> deg(n);\n    for (auto &neighbors : g) {\n        deg[neighbors[0]] += neighbors.size() - 1;\n    }\n    int left_edges = n - 1;\n    std::vector<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] == 1 && coins[i] == 0) {\n            q.push_back(i);\n        }\n    }\n    while (!q.empty()) {\n        left_edges--;\n        int u = q.back();\n        q.pop_back();\n        for (int v : g[u]) {\n            deg[v]--;\n            if (deg[v] == 1 && coins[v] == 0) {\n                q.push_back(v);\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] == 1 && coins[i]) {\n            q.push_back(i);\n        }\n    }\n    left_edges -= q.size();\n    for (int x : q) {\n        for (int y : g[x]) {\n            deg[y]--;\n            if (deg[y] == 1) {\n                left_edges--;\n            }\n        }\n    }\n    return std::max(left_edges * 2, 0);\n}\n```", "sl_gold_code": "def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)  \n    deg = list(map(len, g))  \n    left_edges = n - 1      \n    q = []\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c == 0:  \n            q.append(i)\n    while q:\n        left_edges -= 1  \n        for y in g[q.pop()]:\n            deg[y] -= 1\n            if deg[y] == 1 and coins[y] == 0:  \n                q.append(y)\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c:  \n            q.append(i)\n    left_edges -= len(q)  \n    for x in q:  \n        for y in g[x]:\n            deg[y] -= 1\n            if deg[y] == 1:  \n                left_edges -= 1  \n    return max(left_edges * 2, 0)", "tl_gold_code": "int collectTheCoins(vector<int> &coins, vector<vector<int>> &edges) {\n    int n = coins.size();\n    vector<vector<int>> g(n);\n    vector<int> deg(n);\n    for (auto &e: edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x); \n        deg[x]++;\n        deg[y]++; \n    }\n    int left_edges = n - 1; \n    vector<int> q;\n    for (int i = 0; i < n; i++)\n        if (deg[i] == 1 && coins[i] == 0) \n            q.push_back(i);\n    while (!q.empty()) {\n        left_edges--; \n        int x = q.back(); q.pop_back();\n        for (int y: g[x])\n            if (--deg[y] == 1 && coins[y] == 0) \n                q.push_back(y);\n    }\n    for (int i = 0; i < n; i++)\n        if (deg[i] == 1 && coins[i]) \n            q.push_back(i);\n    left_edges -= q.size(); \n    for (int x: q) \n        for (int y: g[x])\n            if (--deg[y] == 1) \n                left_edges--; \n    return max(left_edges * 2, 0);\n}"}
{"task": "python_c++", "problem_id": 72, "prediction_id": 0, "pro_prediction": "vector<vector<int>> matrixRotation(vector<vector<int>>& matrix, int r) {\n    int l, br, bc;\n    l = 0;\n    br = matrix.size();\n    bc = matrix[0].size();\n    while (l < min(br, bc) / 2) {\n        int rr = r % (2 * (br + bc - l * 4 - 2));\n        while (rr != 0) {\n            rr -= 1;\n            int buf = matrix[l][l];\n            for (int j = l; j < bc - l - 1; j++) {\n                matrix[l][j] = matrix[l][j + 1];\n            }\n            for (int i = l; i < br - l - 1; i++) {\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1];\n            }\n            for (int j = bc - l - 1; j > l; j--) {\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1];\n            }\n            for (int i = br - l - 1; i > l; i--) {\n                matrix[i][l] = matrix[i - 1][l];\n            }\n            matrix[l + 1][l] = buf;\n        }\n        l++;\n    }\n    return matrix;\n}", "main_fun_name": "matrixRotation", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixRotation(vector<vector<int>>& matrix, int r) {\n    int l, br, bc;\n    l = 0;\n    br = matrix.size();\n    bc = matrix[0].size();\n    while (l < min(br, bc) / 2) {\n        int rr = r % (2 * (br + bc - l * 4 - 2));\n        while (rr != 0) {\n            rr -= 1;\n            int buf = matrix[l][l];\n            for (int j = l; j < bc - l - 1; j++) {\n                matrix[l][j] = matrix[l][j + 1];\n            }\n            for (int i = l; i < br - l - 1; i++) {\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1];\n            }\n            for (int j = bc - l - 1; j > l; j--) {\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1];\n            }\n            for (int i = br - l - 1; i > l; i--) {\n                matrix[i][l] = matrix[i - 1][l];\n            }\n            matrix[l + 1][l] = buf;\n        }\n        l++;\n    }\n    return matrix;\n}\n```", "sl_gold_code": "def matrixRotation(matrix, r):\n    l, br, bc = 0, len(matrix), len(matrix[0])\n    while l < min(br, bc) / 2:\n        rr = r % (2 * (br + bc - l * 4 - 2))\n        while (rr) != 0:\n            rr -= 1\n            buf = matrix[l][l]\n            for j in range(l, bc - l - 1):\n                matrix[l][j] = matrix[l][j + 1]\n            for i in range(l, br - l - 1):\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]\n            for j in range(bc - l - 1, l, -1):\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]\n            for i in range(br - l - 1, l + 1, -1):\n                matrix[i][l] = matrix[i - 1][l]\n            matrix[l + 1][l] = buf\n        l += 1\n    return matrix", "tl_gold_code": "vector<vector<int>> matrixRotation(vector<vector<int>>& matrix, int r) {\n    int l = 0;\n    int br = matrix.size();\n    int bc = matrix[0].size();\n    while (l < min(br, bc) / 2) {\n        int rr = r % (2 * (br + bc - 4 * l - 2));\n        while (rr--) {\n            int buf = matrix[l][l];\n            for (int j = l; j < bc - l - 1; ++j) {\n                matrix[l][j] = matrix[l][j + 1];\n            }\n            for (int i = l; i < br - l - 1; ++i) {\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1];\n            }\n            for (int j = bc - l - 1; j > l; --j) {\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1];\n            }\n            for (int i = br - l - 1; i > l + 1; --i) {\n                matrix[i][l] = matrix[i - 1][l];\n            }\n            matrix[l + 1][l] = buf;\n        }\n        ++l;\n    }\n    return matrix;\n}"}
{"task": "python_c++", "problem_id": 73, "prediction_id": 0, "pro_prediction": "int divisorSubstrings(int num, int k) {\n    std::string s = std::to_string(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = std::stoi(s.substr(i, k));\n        if (tmp != 0 && num % tmp == 0) {\n            res += 1;\n        }\n    }\n    return res;\n}", "main_fun_name": "divisorSubstrings", "raw_prediction": "```cpp\n#include <string>\n\nint divisorSubstrings(int num, int k) {\n    std::string s = std::to_string(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = std::stoi(s.substr(i, k));\n        if (tmp != 0 && num % tmp == 0) {\n            res += 1;\n        }\n    }\n    return res;\n}\n```", "sl_gold_code": "def divisorSubstrings(num: int, k: int) -> int:\n    s = str(num)\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        tmp = int(s[i:i+k])\n        if tmp != 0 and num % tmp == 0:\n            res += 1\n    return res", "tl_gold_code": "int divisorSubstrings(int num, int k) {\n    string s = to_string(num);\n    int n = s.size();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = stoi(s.substr(i, k));\n        if (tmp && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}"}
{"task": "python_c++", "problem_id": 74, "prediction_id": 0, "pro_prediction": "std::vector<int> solve(std::vector<int> a) {\n    std::vector<int> result;\n    std::vector<int> cum(a.size());\n    cum[0] = a[0];\n    for (int i = 1; i < a.size(); i++) {\n        cum[i] = cum[i-1] + a[i];\n    }\n    int total = cum.back();\n    for (int i = 0; i < cum.size(); i++) {\n        if (total % cum[i] == 0) {\n            int j = i + 1;\n            int segment_sum = 0;\n            while (j < a.size() && segment_sum < cum[i]) {\n                segment_sum += a[j];\n                if (segment_sum == cum[i]) {\n                    segment_sum = 0;\n                }\n                j++;\n            }\n            if (segment_sum == 0 && (j == a.size() || cum[i] == total)) {\n                result.push_back(cum[i]);\n            }\n        }\n    }\n    return result;\n}", "main_fun_name": "solve", "raw_prediction": "```cpp\n#include <vector>\n#include <iostream>\n\nstd::vector<int> solve(std::vector<int> a) {\n    std::vector<int> result;\n    std::vector<int> cum(a.size());\n    cum[0] = a[0];\n    for (int i = 1; i < a.size(); i++) {\n        cum[i] = cum[i-1] + a[i];\n    }\n    int total = cum.back();\n    for (int i = 0; i < cum.size(); i++) {\n        if (total % cum[i] == 0) {\n            int j = i + 1;\n            int segment_sum = 0;\n            while (j < a.size() && segment_sum < cum[i]) {\n                segment_sum += a[j];\n                if (segment_sum == cum[i]) {\n                    segment_sum = 0;\n                }\n                j++;\n            }\n            if (segment_sum == 0 && (j == a.size() || cum[i] == total)) {\n                result.push_back(cum[i]);\n            }\n        }\n    }\n    return result;\n}\n```\n\nNote: The code assumes that the input vector `a` is not empty.", "sl_gold_code": "def solve(a):\n    result = []\n    cum = [0] * len(a)\n    cum[0] = a[0]\n    for i in range(1, len(a)):\n        cum[i] = cum[i-1] + a[i]\n    total = cum[-1]\n    for i in range(len(cum)):\n        if total % cum[i] == 0:\n            j = i + 1\n            segment_sum = 0\n            while j < len(a) and segment_sum < cum[i]:\n                segment_sum += a[j]\n                if segment_sum == cum[i]:\n                    segment_sum = 0\n                j += 1\n            if segment_sum == 0 and (j == len(a) or cum[i] == total):\n                result.append(cum[i])\n    return result", "tl_gold_code": "vector<int> solve(const vector<int>& a) {\n    vector<int> result;\n    vector<int> cum(a.size(), 0);\n    cum[0] = a[0];\n    for (size_t i = 1; i < a.size(); i++) {\n        cum[i] = cum[i - 1] + a[i];\n    }\n    int total = cum.back();\n    for (size_t i = 0; i < cum.size(); i++) {\n        if (total % cum[i] == 0) {\n            size_t j = i + 1;\n            int segment_sum = 0;\n            while (j < a.size() && segment_sum < cum[i]) {\n                segment_sum += a[j];\n                if (segment_sum == cum[i]) {\n                    segment_sum = 0;\n                }\n                j++;\n            }\n            if (segment_sum == 0 && (j == a.size() || cum[i] == total)) {\n                result.push_back(cum[i]);\n            }\n        }\n    }\n    return result;\n}"}
{"task": "python_c++", "problem_id": 75, "prediction_id": 0, "pro_prediction": "int maximumToys(vector<int> prices, int k) {\n    sort(prices.begin(), prices.end());\n    int toys = 0;\n    for (int i : prices) {\n        if (i <= k) {\n            k -= i;\n            toys++;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}", "main_fun_name": "maximumToys", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint maximumToys(vector<int> prices, int k) {\n    sort(prices.begin(), prices.end());\n    int toys = 0;\n    for (int i : prices) {\n        if (i <= k) {\n            k -= i;\n            toys++;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}\n```", "sl_gold_code": "def maximumToys(prices, k):\n    prices = sorted(prices)\n    toys = 0\n    for i in prices:\n        if i <= k:\n            k = k - i\n            toys = toys + 1\n        else:\n            break\n    return toys", "tl_gold_code": "int maximumToys(vector<int>& prices, int k) {\n    sort(prices.begin(), prices.end());\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            ++toys;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}"}
{"task": "python_c++", "problem_id": 76, "prediction_id": 0, "pro_prediction": "int sumOfSquares(const std::vector<int>& nums) {\n    int ans = 0;\n    int n = nums.size();\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}", "main_fun_name": "sumOfSquares", "raw_prediction": "```cpp\n#include <vector>\n\nint sumOfSquares(const std::vector<int>& nums) {\n    int ans = 0;\n    int n = nums.size();\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def sumOfSquares(nums):\n    ans = 0\n    n = len(nums)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            ans += nums[i - 1] ** 2\n    return ans", "tl_gold_code": "int sumOfSquares(vector<int> &nums) {\n    int ans = 0, n = nums.size();\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 77, "prediction_id": 0, "pro_prediction": "bool checkArray(vector<int> nums, int k) {\n    int n = nums.size();\n    vector<int> d(n + 1, 0);\n    int sum_d = 0;\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        nums[i] += sum_d;\n        if (nums[i] == 0) continue;\n        if (nums[i] < 0 || i + k > n - 1) return false;\n        sum_d -= nums[i];\n        d[i + k] += nums[i];\n    }\n    return true;\n}", "main_fun_name": "checkArray", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nbool checkArray(vector<int> nums, int k) {\n    int n = nums.size();\n    vector<int> d(n + 1, 0);\n    int sum_d = 0;\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        nums[i] += sum_d;\n        if (nums[i] == 0) continue;\n        if (nums[i] < 0 || i + k > n - 1) return false;\n        sum_d -= nums[i];\n        d[i + k] += nums[i];\n    }\n    return true;\n}\n```", "sl_gold_code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    d = [0] * (n + 1)\n    sum_d = 0\n    for i, x in enumerate(nums):\n        sum_d += d[i]\n        x += sum_d\n        if x == 0: continue  \n        if x < 0 or i + k > n: return False  \n        sum_d -= x  \n        d[i + k] += x\n    return True", "tl_gold_code": "bool checkArray(vector<int> &nums, int k) {\n    int n = nums.size(), sum_d = 0;\n    vector<int> d(n + 1);\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        int x = nums[i];\n        x += sum_d;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sum_d -= x;\n        d[i + k] += x;\n    }\n    return true;\n}"}
{"task": "python_c++", "problem_id": 78, "prediction_id": 0, "pro_prediction": "int maxNonDecreasingLength(std::vector<int> nums1, std::vector<int> nums2) {\n    int n = nums1.size();\n    if (n == 1) {\n        return 1;\n    }\n    std::vector<std::vector<int>> dp(n, std::vector<int>(2, 1));\n    int ans = 0;\n    for (int i = 1; i < n; ++i) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i - 1]) {\n            dp[i][0] = std::max(dp[i][0], dp[i - 1][0] + 1);\n        }\n        if (nums1[i] >= nums2[i - 1]) {\n            dp[i][0] = std::max(dp[i][0], dp[i - 1][1] + 1);\n        }\n        if (nums2[i] >= nums1[i - 1]) {\n            dp[i][1] = std::max(dp[i][1], dp[i - 1][0] + 1);\n        }\n        if (nums2[i] >= nums2[i - 1]) {\n            dp[i][1] = std::max(dp[i][1], dp[i - 1][1] + 1);\n        }\n        ans = std::max(ans, std::max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}", "main_fun_name": "maxNonDecreasingLength", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint maxNonDecreasingLength(std::vector<int> nums1, std::vector<int> nums2) {\n    int n = nums1.size();\n    if (n == 1) {\n        return 1;\n    }\n    std::vector<std::vector<int>> dp(n, std::vector<int>(2, 1));\n    int ans = 0;\n    for (int i = 1; i < n; ++i) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i - 1]) {\n            dp[i][0] = std::max(dp[i][0], dp[i - 1][0] + 1);\n        }\n        if (nums1[i] >= nums2[i - 1]) {\n            dp[i][0] = std::max(dp[i][0], dp[i - 1][1] + 1);\n        }\n        if (nums2[i] >= nums1[i - 1]) {\n            dp[i][1] = std::max(dp[i][1], dp[i - 1][0] + 1);\n        }\n        if (nums2[i] >= nums2[i - 1]) {\n            dp[i][1] = std::max(dp[i][1], dp[i - 1][1] + 1);\n        }\n        ans = std::max(ans, std::max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}\n```", "sl_gold_code": "def maxNonDecreasingLength(nums1, nums2):\n    n = len(nums1)\n    if n == 1:\n        return 1\n    dp = [[1] * 2 for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        dp[i][0] = dp[i][1] = 1\n        if nums1[i] >= nums1[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][0] + 1)\n        if nums1[i] >= nums2[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\n        if nums2[i] >= nums1[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][0] + 1)\n        if nums2[i] >= nums2[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\n        ans = max(ans, max(dp[i][0], dp[i][1]))\n    return ans", "tl_gold_code": "int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size();\n    if (n == 1) return 1;\n    vector<vector<int>> dp(n, vector<int>(2, 1));\n    int ans = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][1]+1);\n        ans = max(ans, max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 79, "prediction_id": 0, "pro_prediction": "int maximumJumps(std::vector<int> nums, int target) {\n    int n = nums.size();\n    std::vector<int> f(n, INT_MIN);\n    f[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (std::abs(nums[i] - nums[j]) <= target) {\n                f[i] = std::max(f[i], f[j] + 1);\n            }\n        }\n    }\n    return f.back() < 0 ? -1 : f.back();\n}", "main_fun_name": "maximumJumps", "raw_prediction": "```cpp\n#include <vector>\n#include <climits>\n\nint maximumJumps(std::vector<int> nums, int target) {\n    int n = nums.size();\n    std::vector<int> f(n, INT_MIN);\n    f[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (std::abs(nums[i] - nums[j]) <= target) {\n                f[i] = std::max(f[i], f[j] + 1);\n            }\n        }\n    }\n    return f.back() < 0 ? -1 : f.back();\n}\n```", "sl_gold_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-inf] * n\n    f[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= target:\n                f[i] = max(f[i], f[j] + 1)\n    return -1 if f[-1] < 0 else f[-1]", "tl_gold_code": "int maximumJumps(vector<int>& nums, int target) {\n    vector<int> dp(nums.size());\n    dp[0] = 0;\n    for(int i = 1; i < nums.size(); ++i)\n    {\n        int res = INT_MIN;\n        for(int j = 0; j < i; ++j)\n        {\n            if(abs(nums[i] - nums[j]) <= target)\n                res = max(res, dp[j] + 1);\n            dp[i] = res;\n        }\n    }\n    return dp.back() < 0 ? -1 : dp.back();\n}"}
{"task": "python_c++", "problem_id": 80, "prediction_id": 0, "pro_prediction": "int theMaximumAchievableX(int num, int t) {\n    return num + t * 2;\n}", "main_fun_name": "theMaximumAchievableX", "raw_prediction": "```cpp\n#include <iostream>\n\nint theMaximumAchievableX(int num, int t) {\n    return num + t * 2;\n}\n```", "sl_gold_code": "def theMaximumAchievableX(num: int, t: int) -> int:\n        return num + t * 2", "tl_gold_code": "int theMaximumAchievableX(int num, int t){\n    return num+t*2;\n}"}
{"task": "python_c++", "problem_id": 81, "prediction_id": 0, "pro_prediction": "std::vector<long long> countBlackBlocks(int m, int n, std::vector<std::vector<int>>& coordinates) {\n    std::vector<long long> ans(5, 0);\n    long long sum_blocks = (m - 1) * (n - 1);\n    std::set<int> st;\n    for (auto& [x, y] : coordinates) {\n        st.insert(x * n + y);\n    }\n    std::vector<std::vector<std::pair<int, int>>> arr = {\n        {{0, -1}, {-1, -1}, {-1, 0}},\n        {{0, 1}, {-1, 0}, {-1, 1}},\n        {{0, -1}, {1, 0}, {1, -1}},\n        {{0, 1}, {1, 0}, {1, 1}}\n    };\n    for (auto& [x, y] : coordinates) {\n        for (auto& a : arr) {\n            int cnt = 1;\n            for (auto& [dx, dy] : a) {\n                int nx = x + dx, ny = y + dy;\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if (st.find(nx * n + ny) != st.end()) {\n                    cnt += 1;\n                }\n            }\n            ans[cnt] += 1;\n        }\n    }\n    for (int i = 2; i < 5; ++i) {\n        ans[i] /= i;\n    }\n    ans[0] = sum_blocks - std::accumulate(ans.begin() + 1, ans.end(), 0LL);\n    return ans;\n}", "main_fun_name": "countBlackBlocks", "raw_prediction": "```cpp\n#include <vector>\n#include <set>\n\nstd::vector<long long> countBlackBlocks(int m, int n, std::vector<std::vector<int>>& coordinates) {\n    std::vector<long long> ans(5, 0);\n    long long sum_blocks = (m - 1) * (n - 1);\n    std::set<int> st;\n    for (auto& [x, y] : coordinates) {\n        st.insert(x * n + y);\n    }\n    std::vector<std::vector<std::pair<int, int>>> arr = {\n        {{0, -1}, {-1, -1}, {-1, 0}},\n        {{0, 1}, {-1, 0}, {-1, 1}},\n        {{0, -1}, {1, 0}, {1, -1}},\n        {{0, 1}, {1, 0}, {1, 1}}\n    };\n    for (auto& [x, y] : coordinates) {\n        for (auto& a : arr) {\n            int cnt = 1;\n            for (auto& [dx, dy] : a) {\n                int nx = x + dx, ny = y + dy;\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if (st.find(nx * n + ny) != st.end()) {\n                    cnt += 1;\n                }\n            }\n            ans[cnt] += 1;\n        }\n    }\n    for (int i = 2; i < 5; ++i) {\n        ans[i] /= i;\n    }\n    ans[0] = sum_blocks - std::accumulate(ans.begin() + 1, ans.end(), 0LL);\n    return ans;\n}\n```", "sl_gold_code": "def countBlackBlocks(m, n, coordinates):\n    ans = [0] * 5\n    sum_blocks = (m - 1) * (n - 1)\n    st = set((x * n + y) for x, y in coordinates)\n    arr = [\n        [(0, -1), (-1, -1), (-1, 0)],\n        [(0, 1), (-1, 0), (-1, 1)],\n        [(0, -1), (1, 0), (1, -1)],\n        [(0, 1), (1, 0), (1, 1)]\n    ]\n    for x, y in coordinates:\n        for a in arr:\n            cnt = 1\n            for dx, dy in a:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or ny < 0 or nx >= m or ny >= n:\n                    cnt = 0\n                    break\n                if (nx * n + ny) in st:\n                    cnt += 1\n            ans[cnt] += 1\n    for i in range(2, 5):\n        ans[i] //= i\n    ans[0] = sum_blocks - sum(ans[1:])\n    return ans", "tl_gold_code": "vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& coordinates) {\n    vector<long long> ans(5);\n    long long sum = (long long)(m-1) * (n-1);\n    unordered_set<long long> st;\n    int num = coordinates.size();\n    for(int i = 0; i < num; i++)\n        st.insert((long long)coordinates[i][0] * n + coordinates[i][1]);\n    vector<vector<pair<int, int>>> arr(4);\n    arr[0] = {{0, -1}, {-1, -1}, {-1, 0}};\n    arr[1] = {{0, 1}, {-1, 0}, {-1, 1}};\n    arr[2] = {{0, -1}, {1, 0}, {1, -1}};\n    arr[3] = {{0, 1}, {1, 0}, {1, 1}};\n    for(int i = 0; i < num; i++) {\n        long long x = coordinates[i][0], y = coordinates[i][1];\n        for(auto &a : arr) {\n            int cnt = 1;\n            for(auto& [dx, dy] : a) {\n                long long nx = x + dx, ny = y + dy;\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if(st.count(nx * n + ny)) cnt++;\n            }\n            ans[cnt]++;\n        }            \n    }\n    for(int i = 2; i <= 4; i++) ans[i] /= i;\n    ans[0] = sum - ans[1] - ans[2] - ans[3] - ans[4];\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 82, "prediction_id": 0, "pro_prediction": "int minimumBeautifulSubstrings(std::string s) {\n    if (s[0] == '0') {\n        return -1;\n    }\n    int n = s.length();\n    std::vector<int> f(n + 10, std::numeric_limits<int>::max());\n    f[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            std::string current_substring = s.substr(i, j - i + 1);\n            if (beautiful_strings.find(current_substring) != beautiful_strings.end()) {\n                f[j + 1] = std::min(f[j + 1], f[i] + 1);\n            }\n        }\n    }\n    if (f[n] == std::numeric_limits<int>::max()) {\n        return -1;\n    }\n    return f[n];\n}", "main_fun_name": "minimumBeautifulSubstrings", "raw_prediction": "```cpp\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nstd::vector<int> beautiful_strings{\"1\", \"101\", \"11001\", \"1111101\", \"1001110001\", \"110000110101\", \"11110100001001\"};\n\nint minimumBeautifulSubstrings(std::string s) {\n    if (s[0] == '0') {\n        return -1;\n    }\n    int n = s.length();\n    std::vector<int> f(n + 10, std::numeric_limits<int>::max());\n    f[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            std::string current_substring = s.substr(i, j - i + 1);\n            if (beautiful_strings.find(current_substring) != beautiful_strings.end()) {\n                f[j + 1] = std::min(f[j + 1], f[i] + 1);\n            }\n        }\n    }\n    if (f[n] == std::numeric_limits<int>::max()) {\n        return -1;\n    }\n    return f[n];\n}\n```", "sl_gold_code": "def minimumBeautifulSubstrings(s):\n    if s[0] == '0':\n        return -1\n    beautiful_strings = {\"1\", \"101\", \"11001\", \"1111101\", \"1001110001\", \"110000110101\", \"11110100001001\"}\n    n = len(s)\n    f = [float('inf')] * (n + 10)\n    f[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            current_substring = s[i:j+1]\n            if current_substring in beautiful_strings:\n                f[j+1] = min(f[j+1], f[i] + 1)\n    if f[n] == float('inf'):\n        return -1\n    return f[n]", "tl_gold_code": "int minimumBeautifulSubstrings(string s) {\n    if(s[0]==0) return -1;\n    unordered_map<string,int>s1;\n    int n = s.size();\n    s1[\"1\"]++;\n    s1[\"101\"]++;\n    s1[\"11001\"]++;\n    s1[\"1111101\"]++;\n    s1[\"1001110001\"]++;\n    s1[\"110000110101\"]++;\n    s1[\"11110100001001\"]++;\n    string s2=\"\";\n    vector<int>f(n+10,1e9);\n    f[0]=0;\n    for(int i =0;i<n;i++)\n        for(int j =i;j<n;j++)\n        {\n            s2=\"\";\n            for(int k=i;k<=j;k++)\n                s2+=s[k];\n            if(s1.find(s2)!=s1.end()) f[j+1]=min(f[j+1],f[i]+1);\n        }\n    if(f[n]==1e9) return -1;\n    return f[n];\n}"}
{"task": "python_c++", "problem_id": 83, "prediction_id": 0, "pro_prediction": "int gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; ++i) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n\nint gcd(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    int r = x % y;\n    while (r != 0) {\n        x = y;\n        y = r;\n        r = x % y;\n    }\n    return y;\n}\n\nint lcm(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    int m = x;\n    while (x % y != 0) {\n        x += m;\n    }\n    return x;\n}", "main_fun_name": "gcdAndLcm", "raw_prediction": "```cpp\n#include <iostream>\n\nint gcd(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    int r = x % y;\n    while (r != 0) {\n        x = y;\n        y = r;\n        r = x % y;\n    }\n    return y;\n}\n\nint lcm(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    int m = x;\n    while (x % y != 0) {\n        x += m;\n    }\n    return x;\n}\n\nint gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; ++i) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans += 1;\n        }\n    }\n    return ans;\n}\n```\n\nNote: The translated code assumes that the input parameters are valid integers.", "sl_gold_code": "def gcdAndLcm(x: int, y: int) -> int:\n    n = x * y\n    ans = 0\n    for i in range(x,y+1):\n        if n % i == 0 and gcd(i, n // i) == x and lcm(i, n // i) == y:\n            ans += 1\n    return ans\ndef gcd(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    r = x % y  \n    while r != 0:\n        x = y\n        y = r\n        r = x % y\n    return y\ndef lcm(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    m = x\n    while x % y != 0:\n        x = x+m\n    return x", "tl_gold_code": "int gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; ++i) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans++;\n        }\n    }\n    return ans;\n}\nint gcd(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    while (y != 0) {\n        int r = x % y;\n        x = y;\n        y = r;\n    }\n    return x;\n}\nint lcm(int x, int y) {\n    return x / gcd(x, y) * y;\n}"}
{"task": "python_c++", "problem_id": 84, "prediction_id": 0, "pro_prediction": "int findFirstPairExceedingSum(vector<vector<int>> pairs) {\n    int max_sum = 0;\n    int day_index = 0;\n    for (size_t i = 0; i < pairs.size(); i++) {\n        int a = pairs[i][0];\n        int b = pairs[i][1];\n        int sum = a + b;\n        if (sum > 8 && sum > max_sum) {\n            max_sum = sum;\n            day_index = i + 1;\n        }\n    }\n    return day_index;\n}", "main_fun_name": "findFirstPairExceedingSum", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nint findFirstPairExceedingSum(vector<vector<int>> pairs) {\n    int max_sum = 0;\n    int day_index = 0;\n    for (size_t i = 0; i < pairs.size(); i++) {\n        int a = pairs[i][0];\n        int b = pairs[i][1];\n        int sum = a + b;\n        if (sum > 8 && sum > max_sum) {\n            max_sum = sum;\n            day_index = i + 1;\n        }\n    }\n    return day_index;\n}\n```", "sl_gold_code": "def findFirstPairExceedingSum(pairs: List[List[int]]) -> int:\n    max_sum = 0\n    day_index = 0\n    for i, pair in enumerate(pairs, start=1):\n        a = pair[0]\n        b = pair[1]\n        sum = a + b\n        if sum > 8 and sum > max_sum:\n            max_sum = sum\n            day_index = i\n    return day_index", "tl_gold_code": "int findFirstPairExceedingSum(vector<pair<int, int>>& pairs) {\n      int maxSum = 0;\n      int dayIndex = 0;\n      for (int i = 0; i < pairs.size(); ++i) {\n          int a = pairs[i].first;\n          int b = pairs[i].second;\n          int sum = a + b;\n          if (sum > 8 && sum > maxSum) {\n              maxSum = sum;\n              dayIndex = i + 1;\n          }\n      }\n      return dayIndex;\n  }"}
{"task": "python_c++", "problem_id": 85, "prediction_id": 0, "pro_prediction": "int maximumValue(std::vector<std::string> strs) {\n    int res = 0;\n    for (const auto& s : strs) {\n        bool is_digits = true;\n        for (char c : s) {\n            if (!isdigit(c)) {\n                is_digits = false;\n                break;\n            }\n        }\n        res = std::max(res, is_digits ? std::stoi(s) : static_cast<int>(s.length()));\n    }\n    return res;\n}", "main_fun_name": "maximumValue", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n\nint maximumValue(std::vector<std::string> strs) {\n    int res = 0;\n    for (const auto& s : strs) {\n        bool is_digits = true;\n        for (char c : s) {\n            if (!isdigit(c)) {\n                is_digits = false;\n                break;\n            }\n        }\n        res = std::max(res, is_digits ? std::stoi(s) : static_cast<int>(s.length()));\n    }\n    return res;\n}\n```", "sl_gold_code": "def maximumValue(strs: List[str]) -> int:\n    res = 0\n    for s in strs:\n        is_digits = all(c.isdigit() for c in s)\n        res = max(res, int(s) if is_digits else len(s))\n    return res", "tl_gold_code": "int maximumValue(vector<string>& strs) {\n    int res = 0;\n    for (auto& s : strs) {\n        bool isDigits = true;\n        for (char& c : s) {\n            isDigits &= isdigit(c);\n        }\n        res = max(res, isDigits ? stoi(s) : (int)s.size());\n    }\n    return res;\n}"}
{"task": "python_c++", "problem_id": 86, "prediction_id": 0, "pro_prediction": "int countBeautifulPairs(std::vector<int>& nums) {\n    int ans = 0;\n    std::array<int, 10> cnt = {0};\n    for (int x : nums) {\n        for (int y = 1; y < 10; ++y) {\n            if (cnt[y] && gcd(x % 10, y) == 1) {\n                ans += cnt[y];\n            }\n        }\n        while (x >= 10) {\n            x /= 10;\n        }\n        ++cnt[x];\n    }\n    return ans;\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}", "main_fun_name": "countBeautifulPairs", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint countBeautifulPairs(std::vector<int>& nums) {\n    int ans = 0;\n    std::array<int, 10> cnt = {0};\n    for (int x : nums) {\n        for (int y = 1; y < 10; ++y) {\n            if (cnt[y] && gcd(x % 10, y) == 1) {\n                ans += cnt[y];\n            }\n        }\n        while (x >= 10) {\n            x /= 10;\n        }\n        ++cnt[x];\n    }\n    return ans;\n}\n```", "sl_gold_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    ans, cnt = 0, [0] * 10\n    for x in nums:\n        for y in range(1, 10):\n            if cnt[y] and gcd(x % 10, y) == 1:\n                ans += cnt[y]\n        while x >= 10: x //= 10\n        cnt[x] += 1\n    return ans", "tl_gold_code": "int countBeautifulPairs(vector<int> &nums) {\n    int ans = 0, cnt[10]{};\n    for (int x: nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 87, "prediction_id": 0, "pro_prediction": "std::vector<int> countServers(int n, std::vector<std::vector<int>> logs, int x, std::vector<int> queries) {\n    std::sort(logs.begin(), logs.end(), [](const std::vector<int>& a, const std::vector<int>& b) { return a[1] < b[1]; });\n    std::vector<int> ans(queries.size());\n    std::vector<int> cnt(n + 1, 0);\n    int out_of_range = n;\n    int left = 0, right = 0;\n    for (size_t qi = 0; qi < queries.size(); ++qi) {\n        while (right < logs.size() && logs[right][1] <= queries[qi]) {\n            int i = logs[right][0];\n            if (cnt[i] == 0) out_of_range -= 1;\n            cnt[i] += 1;\n            right += 1;\n        }\n        while (left < logs.size() && logs[left][1] < queries[qi] - x) {\n            int i = logs[left][0];\n            cnt[i] -= 1;\n            if (cnt[i] == 0) out_of_range += 1;\n            left += 1;\n        }\n        ans[qi] = out_of_range;\n    }\n    return ans;\n}", "main_fun_name": "countServers", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> countServers(int n, std::vector<std::vector<int>> logs, int x, std::vector<int> queries) {\n    std::sort(logs.begin(), logs.end(), [](const std::vector<int>& a, const std::vector<int>& b) { return a[1] < b[1]; });\n    std::vector<int> ans(queries.size());\n    std::vector<int> cnt(n + 1, 0);\n    int out_of_range = n;\n    int left = 0, right = 0;\n    for (size_t qi = 0; qi < queries.size(); ++qi) {\n        while (right < logs.size() && logs[right][1] <= queries[qi]) {\n            int i = logs[right][0];\n            if (cnt[i] == 0) out_of_range -= 1;\n            cnt[i] += 1;\n            right += 1;\n        }\n        while (left < logs.size() && logs[left][1] < queries[qi] - x) {\n            int i = logs[left][0];\n            cnt[i] -= 1;\n            if (cnt[i] == 0) out_of_range += 1;\n            left += 1;\n        }\n        ans[qi] = out_of_range;\n    }\n    return ans;\n}\n```\n\nNote: The input and return types of the translated function are as follows:\n- `int n`: an integer representing the number of servers.\n- `std::vector<std::vector<int>> logs`: a vector of vectors of integers representing the server logs. Each inner vector contains two elements, where the first element is the index of the server and the second element is the time at which the log was recorded.\n- `int x`: an integer representing the threshold time.\n- `std::vector<int> queries`: a vector of integers representing the query times.\n- Return value: a vector of integers representing the number of servers that have been inactive for at least `x` units of time at each query time.", "sl_gold_code": "def countServers(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    logs.sort(key=lambda p: p[1])  \n    ans = [0] * len(queries)\n    cnt = [0] * (n + 1)\n    out_of_range = n\n    left = right = 0\n    for qi, q in sorted(enumerate(queries), key=lambda p: p[1]):\n        while right < len(logs) and logs[right][1] <= q:  \n            i = logs[right][0]\n            if cnt[i] == 0: out_of_range -= 1\n            cnt[i] += 1\n            right += 1\n        while left < len(logs) and logs[left][1] < q - x:  \n            i = logs[left][0]\n            cnt[i] -= 1\n            if cnt[i] == 0: out_of_range += 1\n            left += 1\n        ans[qi] = out_of_range\n    return ans", "tl_gold_code": "vector<int> countServers(int n, vector<vector<int>> &logs, int x, vector<int> &queries) {\n    int nq = queries.size(), id[nq], cnt[n + 1];\n    memset(cnt, 0, sizeof(cnt));\n    iota(id, id + nq, 0);\n    sort(id, id + nq, [&](int i, int j) {\n        return queries[i] < queries[j];\n    });\n    sort(logs.begin(), logs.end(), [](const auto &a, const auto &b) {\n        return a[1] < b[1];\n    });\n    vector<int> ans(nq);\n    int out_of_range = n, left = 0, right = 0;\n    for (int i: id) {\n        while (right < logs.size() && logs[right][1] <= queries[i])\n            if (cnt[logs[right++][0]]++ == 0)\n                out_of_range--;\n        while (left < logs.size() && logs[left][1] < queries[i] - x)\n            if (--cnt[logs[left++][0]] == 0)\n                out_of_range++;\n        ans[i] = out_of_range;\n    }\n    return ans;\n}"}
{"task": "python_c++", "problem_id": 88, "prediction_id": 0, "pro_prediction": "bool isPossible(int n, std::vector<std::vector<int>> edges) {\n    std::unordered_map<int, std::set<int>> g;\n    for (auto &[x, y] : edges) {\n        g[x].insert(y);\n        g[y].insert(x);\n    }\n    std::vector<int> odd;\n    for (auto &[i, nb] : g) {\n        if (nb.size() % 2) {\n            odd.push_back(i);\n        }\n    }\n    int m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd[0], y = odd[1];\n        return g.find(y) == g.end() || std::any_of(\n                std::begin(edges), std::end(edges),\n                [&](const auto &e) { return e[0] != x && e[0] != y && g[e[0]].find(x) == g[e[0]].end() && g[e[0]].find(y) == g[e[0]].end(); });\n    }\n    if (m == 4) {\n        int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\n        return g.find(b) == g.end() || g.find(d) == g[c].end() ||\n               g.find(c) == g[a].end() || g.find(d) == g[b].end() ||\n               g.find(d) == g[a].end() || g.find(c) == g[b].end();\n    }\n    return false;\n}", "main_fun_name": "isPossible", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <set>\n\nbool isPossible(int n, std::vector<std::vector<int>> edges) {\n    std::unordered_map<int, std::set<int>> g;\n    for (auto &[x, y] : edges) {\n        g[x].insert(y);\n        g[y].insert(x);\n    }\n    std::vector<int> odd;\n    for (auto &[i, nb] : g) {\n        if (nb.size() % 2) {\n            odd.push_back(i);\n        }\n    }\n    int m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd[0], y = odd[1];\n        return g.find(y) == g.end() || std::any_of(\n                std::begin(edges), std::end(edges),\n                [&](const auto &e) { return e[0] != x && e[0] != y && g[e[0]].find(x) == g[e[0]].end() && g[e[0]].find(y) == g[e[0]].end(); });\n    }\n    if (m == 4) {\n        int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\n        return g.find(b) == g.end() || g.find(d) == g[c].end() ||\n               g.find(c) == g[a].end() || g.find(d) == g[b].end() ||\n               g.find(d) == g[a].end() || g.find(c) == g[b].end();\n    }\n    return false;\n}\n```\n\nNote: I've assumed that the `defaultdict` in Python is replaced with an `unordered_map` in C++ and the `List` in Python is replaced with a `vector` in C++.", "sl_gold_code": "def isPossible(n: int, edges: List[List[int]]) -> bool:\n    g = defaultdict(set)\n    for x, y in edges:\n        g[x].add(y)\n        g[y].add(x)\n    odd = [i for i, nb in g.items() if len(nb) % 2]\n    m = len(odd)\n    if m == 0: return True\n    if m == 2:\n        x, y = odd\n        return x not in g[y] or any(\n            i != x and i != y and x not in g[i] and y not in g[i]\n            for i in range(1, n + 1))\n    if m == 4:\n        a, b, c, d = odd\n        return b not in g[a] and d not in g[c] or \\\n                c not in g[a] and d not in g[b] or \\\n                d not in g[a] and c not in g[b]\n    return False", "tl_gold_code": "bool isPossible(int n, vector<vector<int>> &edges) {\n    unordered_set<int> g[n + 1];\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].insert(y);\n        g[y].insert(x);\n    }\n    vector<int> odd;\n    for (int i = 1; i <= n; ++i)\n        if (g[i].size() % 2) odd.push_back(i);\n    int m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd[0], y = odd[1];\n        if (!g[x].count(y)) return true;\n        for (int i = 1; i <= n; ++i)\n            if (i != x && i != y && !g[i].count(x) && !g[i].count(y))\n                return true;\n        return false;\n    }\n    if (m == 4) {\n        int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\n        return !g[a].count(b) && !g[c].count(d) ||\n                !g[a].count(c) && !g[b].count(d) ||\n                !g[a].count(d) && !g[b].count(c);\n    }\n    return false;\n}"}
{"task": "python_c++", "problem_id": 89, "prediction_id": 0, "pro_prediction": "int minExtraChar(std::string s, std::vector<std::string> dictionary) {\n    std::set<std::string> d(dictionary.begin(), dictionary.end());\n    int n = s.length();\n    std::vector<int> f(n + 1);\n    for (int i = 0; i < n; ++i) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j <= i; ++j) {\n            if (d.find(s.substr(j, i - j + 1)) != d.end()) {\n                f[i + 1] = std::min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}", "main_fun_name": "minExtraChar", "raw_prediction": "```cpp\n#include <vector>\n#include <string>\n#include <set>\n\nint minExtraChar(std::string s, std::vector<std::string> dictionary) {\n    std::set<std::string> d(dictionary.begin(), dictionary.end());\n    int n = s.length();\n    std::vector<int> f(n + 1);\n    for (int i = 0; i < n; ++i) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j <= i; ++j) {\n            if (d.find(s.substr(j, i - j + 1)) != d.end()) {\n                f[i + 1] = std::min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}\n```", "sl_gold_code": "def minExtraChar(s: str, dictionary: List[str]) -> int:\n    d = set(dictionary)\n    n = len(s)\n    f = [0] * (n + 1)\n    for i in range(n):\n        f[i + 1] = f[i] + 1  \n        for j in range(i + 1):  \n            if s[j:i + 1] in d:\n                f[i + 1] = min(f[i + 1], f[j])\n    return f[n]", "tl_gold_code": "int minExtraChar(string s, vector<string> &dictionary) {\n    unordered_set<string> set(dictionary.begin(), dictionary.end());\n    int n = s.size();\n    vector<int> f(n + 1);\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j < i+1; j++) {\n            if (set.count(s.substr(j, i - j + 1))) {\n                f[i + 1] = min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}"}
{"task": "python_c++", "problem_id": 90, "prediction_id": 0, "pro_prediction": "int maximumPoints(vector<vector<int>>& edges, vector<int>& coins, int k) {\n    vector<vector<int>> g(coins.size());\n    for (auto& edge : edges) {\n        g[edge[0]].push_back(edge[1]);\n        g[edge[1]].push_back(edge[0]);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\n\nvector<int> dfs(int x, int fa, vector<vector<int>>& g, vector<int>& coins, int k) {\n    vector<int> res1(14, 0);\n    vector<int> res2(14, 0);\n    for (auto& y : g[x]) {\n        if (y == fa) continue;\n        auto r = dfs(y, x, g, coins, k);\n        for (size_t j = 0; j < 14; ++j) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (size_t j = 0; j < 14; ++j) {\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}", "main_fun_name": "maximumPoints", "raw_prediction": "```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint maximumPoints(vector<vector<int>>& edges, vector<int>& coins, int k) {\n    vector<vector<int>> g(coins.size());\n    for (auto& edge : edges) {\n        g[edge[0]].push_back(edge[1]);\n        g[edge[1]].push_back(edge[0]);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\n\nvector<int> dfs(int x, int fa, vector<vector<int>>& g, vector<int>& coins, int k) {\n    vector<int> res1(14, 0);\n    vector<int> res2(14, 0);\n    for (auto& y : g[x]) {\n        if (y == fa) continue;\n        auto r = dfs(y, x, g, coins, k);\n        for (size_t j = 0; j < 14; ++j) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (size_t j = 0; j < 14; ++j) {\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}\n```\n\nNote", "sl_gold_code": "def maximumPoints(edges: List[List[int]], coins: List[int], k: int) -> int:\n    g = [[] for _ in coins]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    return dfs(0, -1, g, coins, k)[0]\ndef dfs(x: int, fa: int, g, coins, k) -> List[int]:\n    res1 = [0] * 14\n    res2 = [0] * 14\n    for y in g[x]:\n        if y == fa: continue\n        r = dfs(y, x, g, coins, k)\n        for j, v in enumerate(r):\n            res1[j] += v\n            if j < 13:\n                res2[j] += r[j + 1]\n    for j, (r1, r2) in enumerate(zip(res1, res2)):\n        res1[j] = max(r1 + (coins[x] >> j) - k, r2 + (coins[x] >> (j + 1)))\n    return res1", "tl_gold_code": "int maximumPoints(vector<vector<int>> &edges, vector<int> &coins, int k) {\n    vector<vector<int>> g(coins.size());\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\narray<int, 14> dfs(int x, int fa, const vector<vector<int>> &g, const vector<int> &coins, int k) {\n    array<int, 14> res1{}, res2{};\n    for (int y : g[x]) {\n        if (y == fa) continue;\n        auto r = dfs(y, x, g, coins, k);\n        for (int j = 0; j < 14; j++) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (int j = 0; j < 14; j++) {\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}"}
{"task": "python_c++", "problem_id": 91, "prediction_id": 0, "pro_prediction": "int countCompleteComponents(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> g(n);\n    for (auto& edge : edges) {\n        int x = edge[0], y = edge[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<bool> vis(n, false);\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!vis[i]) {\n            vector<int> counts{0, 0};\n            dfs(i, g, vis, counts);\n            int v = counts[0], e = counts[1];\n            ans += e == v * (v - 1);\n        }\n    }\n    return ans;\n}\n\nvoid dfs(int x, vector<vector<int>>& g, vector<bool>& vis, vector<int>& counts) {\n    vis[x] = true;\n    counts[0]++;\n    counts[1] += g[x].size();\n    for (int y : g[x]) {\n        if (!vis[y]) {\n            dfs(y, g, vis, counts);\n        }\n    }\n}", "main_fun_name": "countCompleteComponents", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nvoid dfs(int x, vector<vector<int>>& g, vector<bool>& vis, vector<int>& counts) {\n    vis[x] = true;\n    counts[0]++;\n    counts[1] += g[x].size();\n    for (int y : g[x]) {\n        if (!vis[y]) {\n            dfs(y, g, vis, counts);\n        }\n    }\n}\n\nint countCompleteComponents(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> g(n);\n    for (auto& edge : edges) {\n        int x = edge[0], y = edge[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<bool> vis(n, false);\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!vis[i]) {\n            vector<int> counts{0, 0};\n            dfs(i, g, vis, counts);\n            int v = counts[0], e = counts[1];\n            ans += e == v * (v - 1);\n        }\n    }\n    return ans;\n}\n```", "sl_gold_code": "def dfs(x: int, g: List[List[int]], vis: List[bool], counts: List[int]) -> None:\n    vis[x] = True\n    counts[0] += 1\n    counts[1] += len(g[x])\n    for y in g[x]:\n        if not vis[y]:\n            dfs(y, g, vis, counts)\ndef countCompleteComponents(n: int, edges: List[List[int]]) -> int:\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    vis = [False] * n\n    ans = 0\n    for i in range(n):\n        if not vis[i]:\n            counts = [0, 0]\n            dfs(i, g, vis, counts)\n            v, e = counts\n            ans += e == v * (v - 1)\n    return ans", "tl_gold_code": "int countCompleteComponents(int n, vector<vector<int>> &edges) {\n    vector<vector<int>> g(n);\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> vis(n, 0);\n    int ans = 0, v, e;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            v = 0;\n            e = 0;\n            dfs(i, vis, g, v, e);\n            ans += e == v * (v - 1);\n        }\n    }\n    return ans;\n}\nvoid dfs(int x, vector<int> &vis, vector<vector<int>> &g, int &v, int &e) {\n    vis[x] = 1;\n    v++;\n    e += g[x].size();\n    for (int y : g[x])\n        if (!vis[y])\n            dfs(y, vis, g, v, e);\n}"}
{"task": "python_c++", "problem_id": 92, "prediction_id": 0, "pro_prediction": "bool isPossibleToCutPath(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1;\n    grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}\n\nbool reach(int x, int y, std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        bool ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}", "main_fun_name": "isPossibleToCutPath", "raw_prediction": "```cpp\n#include <vector>\n\nbool reach(int x, int y, std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        bool ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}\n\nbool isPossibleToCutPath(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1;\n    grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}\n```", "sl_gold_code": "def reach(x: int, y: int, grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if x == n - 1 and y == m - 1:\n        return True\n    grid[x][y] = 0\n    x1, y1 = x, y + 1\n    if y1 < m and grid[x1][y1] == 1:\n        ret = reach(x1, y1, grid)\n        if ret:\n            return ret\n    x2, y2 = x + 1, y\n    if x2 < n and grid[x2][y2] == 1:\n        return reach(x2, y2, grid)\n    return False\ndef isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if not reach(0, 0, grid):\n        return True\n    grid[0][0], grid[n - 1][m - 1] = 1, 1\n    if not reach(0, 0, grid):\n        return True\n    return False", "tl_gold_code": "bool reach(int x, int y, vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        bool ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}\nbool isPossibleToCutPath(vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1; grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}"}
{"task": "python_c++", "problem_id": 93, "prediction_id": 0, "pro_prediction": "bool validPath(int n, std::vector<std::vector<int>> edges, int source, int destination) {\n    std::unordered_map<int, std::vector<int>> adj;\n    for (int i = 0; i < n; ++i) {\n        adj[i] = {};\n    }\n    for (const auto& edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(n, false);\n    return dfs(source, destination, adj, visited);\n}\n\nbool dfs(int source, int destination, std::unordered_map<int, std::vector<int>>& adj, std::vector<bool>& visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (const auto& next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}", "main_fun_name": "validPath", "raw_prediction": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool validPath(int n, std::vector<std::vector<int>> edges, int source, int destination) {\n    std::unordered_map<int, std::vector<int>> adj;\n    for (int i = 0; i < n; ++i) {\n        adj[i] = {};\n    }\n    for (const auto& edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(n, false);\n    return dfs(source, destination, adj, visited);\n}\n\nbool dfs(int source, int destination, std::unordered_map<int, std::vector<int>>& adj, std::vector<bool>& visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (const auto& next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}\n```", "sl_gold_code": "def validPath(n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    adj = {i: [] for i in range(n)}\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    return dfs(source, destination, adj, visited)\ndef dfs(source: int, destination: int, adj: dict, visited: List[bool]) -> bool:\n    if source == destination:\n        return True\n    visited[source] = True\n    for next in adj[source]:\n        if not visited[next] and dfs(next, destination, adj, visited):\n            return True\n    return False", "tl_gold_code": "bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n    vector<list<int>> adj(n);\n    for (auto& edge : edges) {\n        int x = edge[0], y = edge[1];\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    vector<bool> visited(n, false);\n    return dfs(source, destination, adj, visited);\n}\nbool dfs(int source, int destination, vector<list<int>>& adj, vector<bool>& visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (int next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}"}
{"task": "python_c++", "problem_id": 94, "prediction_id": 0, "pro_prediction": "bool isSubPath(ListNode* head, TreeNode* root) {\n    if (!root) {\n        return false;\n    }\n    return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\n}\n\nbool dfs(ListNode* head, TreeNode* rt) {\n    if (!head) {\n        return true;\n    }\n    if (!rt) {\n        return false;\n    }\n    if (rt->val != head->val) {\n        return false;\n    }\n    return dfs(head->next, rt->left) || dfs(head->next, rt->right);\n}", "main_fun_name": "isSubPath", "raw_prediction": "```cpp\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool dfs(ListNode* head, TreeNode* rt) {\n    if (!head) {\n        return true;\n    }\n    if (!rt) {\n        return false;\n    }\n    if (rt->val != head->val) {\n        return false;\n    }\n    return dfs(head->next, rt->left) || dfs(head->next, rt->right);\n}\n\nbool isSubPath(ListNode* head, TreeNode* root) {\n    if (!root) {\n        return false;\n    }\n    return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\n}\n```", "sl_gold_code": "def dfs(head: ListNode, rt: TreeNode) -> bool:\n    if not head:\n        return True\n    if not rt:\n        return False\n    if rt.val != head.val:\n        return False\n    return dfs(head.next, rt.left) or dfs(head.next, rt.right)\ndef isSubPath(head: ListNode, root: TreeNode) -> bool:\n    if not root:\n        return False\n    return dfs(head, root) or isSubPath(head, root.left) or isSubPath(head, root.right)", "tl_gold_code": "bool dfs(TreeNode* rt, ListNode* head) {\n    if (head == NULL) return true;\n    if (rt == NULL) return false;\n    if (rt->val != head->val) return false;\n    return dfs(rt->left, head->next) || dfs(rt->right, head->next);\n}\nbool isSubPath(ListNode* head, TreeNode* root) {\n    if (root == NULL) return false;\n    return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\n}"}
{"task": "python_c++", "problem_id": 95, "prediction_id": 0, "pro_prediction": "vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n    vector<int> nums1, nums2, merged;\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    int p1 = 0, p2 = 0;\n    while (true) {\n        if (p1 == nums1.size()) {\n            merged.insert(merged.end(), nums2.begin()+p2, nums2.end());\n            break;\n        }\n        if (p2 == nums2.size()) {\n            merged.insert(merged.end(), nums1.begin()+p1, nums1.end());\n            break;\n        }\n        if (nums1[p1] < nums2[p2]) {\n            merged.push_back(nums1[p1]);\n            p1++;\n        } else {\n            merged.push_back(nums2[p2]);\n            p2++;\n        }\n    }\n    return merged;\n}\n\nvoid inorder(TreeNode* node, vector<int>& res) {\n    if (node) {\n        inorder(node->left, res);\n        res.push_back(node->val);\n        inorder(node->right, res);\n    }\n}", "main_fun_name": "getAllElements", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n    vector<int> nums1, nums2, merged;\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    int p1 = 0, p2 = 0;\n    while (true) {\n        if (p1 == nums1.size()) {\n            merged.insert(merged.end(), nums2.begin()+p2, nums2.end());\n            break;\n        }\n        if (p2 == nums2.size()) {\n            merged.insert(merged.end(), nums1.begin()+p1, nums1.end());\n            break;\n        }\n        if (nums1[p1] < nums2[p2]) {\n            merged.push_back(nums1[p1]);\n            p1++;\n        } else {\n            merged.push_back(nums2[p2]);\n            p2++;\n        }\n    }\n    return merged;\n}\n\nvoid inorder(TreeNode* node, vector<int>& res) {\n    if (node) {\n        inorder(node->left, res);\n        res.push_back(node->val);\n        inorder(node->right, res);\n    }\n}\n```", "sl_gold_code": "def inorder(node, res):\n    if node:\n        inorder(node.left, res)\n        res.append(node.val)\n        inorder(node.right, res)\ndef getAllElements(root1, root2):\n    nums1, nums2 = [], []\n    inorder(root1, nums1)\n    inorder(root2, nums2)\n    merged = []\n    p1, p2 = 0, 0\n    while True:\n        if p1 == len(nums1):\n            merged.extend(nums2[p2:])\n            break\n        if p2 == len(nums2):\n            merged.extend(nums1[p1:])\n            break\n        if nums1[p1] < nums2[p2]:\n            merged.append(nums1[p1])\n            p1 += 1\n        else:\n            merged.append(nums2[p2])\n            p2 += 1\n    return merged", "tl_gold_code": "void inorder(TreeNode *node, vector<int> &res) {\n    if (node) {\n        inorder(node->left, res);\n        res.push_back(node->val);\n        inorder(node->right, res);\n    }\n}\nvector<int> getAllElements(TreeNode *root1, TreeNode *root2) {\n    vector<int> nums1, nums2;\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    vector<int> merged;\n    auto p1 = nums1.begin(), p2 = nums2.begin();\n    while (true) {\n        if (p1 == nums1.end()) {\n            merged.insert(merged.end(), p2, nums2.end());\n            break;\n        }\n        if (p2 == nums2.end()) {\n            merged.insert(merged.end(), p1, nums1.end());\n            break;\n        }\n        if (*p1 < *p2) {\n            merged.push_back(*p1++);\n        } else {\n            merged.push_back(*p2++);\n        }\n    }\n    return merged;\n}"}
{"task": "python_c++", "problem_id": 96, "prediction_id": 0, "pro_prediction": "int maxLevelSum(TreeNode* root) {\n    vector<int> sums;\n    dfs(root, 0, sums);\n    return distance(sums.begin(), max_element(sums.begin(), sums.end())) + 1;\n}\n\nvoid dfs(TreeNode* node, int level, vector<int>& sums) {\n    if (level == sums.size()) {\n        sums.push_back(node->val);\n    } else {\n        sums[level] += node->val;\n    }\n    if (node->left) {\n        dfs(node->left, level + 1, sums);\n    }\n    if (node->right) {\n        dfs(node->right, level + 1, sums);\n    }\n}", "main_fun_name": "maxLevelSum", "raw_prediction": "```cpp\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nint maxLevelSum(TreeNode* root) {\n    vector<int> sums;\n    dfs(root, 0, sums);\n    return distance(sums.begin(), max_element(sums.begin(), sums.end())) + 1;\n}\n\nvoid dfs(TreeNode* node, int level, vector<int>& sums) {\n    if (level == sums.size()) {\n        sums.push_back(node->val);\n    } else {\n        sums[level] += node->val;\n    }\n    if (node->left) {\n        dfs(node->left, level + 1, sums);\n    }\n    if (node->right) {\n        dfs(node->right, level + 1, sums);\n    }\n}\n```", "sl_gold_code": "def maxLevelSum(root: Optional[TreeNode]) -> int:\n    sums = []\n    dfs(root, 0, sums)\n    return sums.index(max(sums)) + 1  \ndef dfs(node: TreeNode, level: int, sums) -> None:\n    if level == len(sums):\n        sums.append(node.val)\n    else:\n        sums[level] += node.val\n    if node.left:\n        dfs(node.left, level + 1, sums)\n    if node.right:\n        dfs(node.right, level + 1, sums)", "tl_gold_code": "int maxLevelSum(TreeNode* root) {\n    std::vector<int> sums;\n    dfs(root, 0, sums);\n    return (int)(std::max_element(sums.begin(), sums.end()) - sums.begin()) + 1;\n}\nvoid dfs(TreeNode* node, int level, std::vector<int>& sums) {\n    if (!node) return;\n    if (level == sums.size()) {\n        sums.push_back(node->val);\n    } else {\n        sums[level] += node->val;\n    }\n    dfs(node->left, level + 1, sums);\n    dfs(node->right, level + 1, sums);\n}"}
{"task": "python_c++", "problem_id": 97, "prediction_id": 0, "pro_prediction": "int sumRootToLeaf(const std::optional<TreeNode>& root) {\n    return dfs(root, 0);\n}\n\nint dfs(const std::optional<TreeNode>& node, int val) {\n    if (!node) {\n        return 0;\n    }\n    val = (val << 1) | node->val;\n    if (!node->left && !node->right) {\n        return val;\n    }\n    return dfs(node->left, val) + dfs(node->right, val);\n}", "main_fun_name": "sumRootToLeaf", "raw_prediction": "```cpp\n#include <optional>\n\nstruct TreeNode {\n    int val;\n    std::optional<TreeNode> left;\n    std::optional<TreeNode> right;\n    TreeNode(int x) : val(x), left(std::nullopt), right(std::nullopt) {}\n};\n\nint sumRootToLeaf(const std::optional<TreeNode>& root) {\n    return dfs(root, 0);\n}\n\nint dfs(const std::optional<TreeNode>& node, int val) {\n    if (!node) {\n        return 0;\n    }\n    val = (val << 1) | node->val;\n    if (!node->left && !node->right) {\n        return val;\n    }\n    return dfs(node->left, val) + dfs(node->right, val);\n}\n```", "sl_gold_code": "def sumRootToLeaf(root: Optional[TreeNode]) -> int:\n    return dfs(root, 0)\ndef dfs(node: Optional[TreeNode], val: int) -> int:\n    if node is None:\n        return 0\n    val = (val << 1) | node.val\n    if node.left is None and node.right is None:\n        return val\n    return dfs(node.left, val) + dfs(node.right, val)", "tl_gold_code": "int dfs(TreeNode *root, int val) {\n    if (root == nullptr) {\n        return 0;\n    }\n    val = (val << 1) | root->val;\n    if (root->left == nullptr && root->right == nullptr) {\n        return val;\n    }\n    return dfs(root->left, val) + dfs(root->right, val);\n}\nint sumRootToLeaf(TreeNode* root) {\n    return dfs(root, 0);\n}"}
{"task": "python_c++", "problem_id": 98, "prediction_id": 0, "pro_prediction": "bool isCousins(TreeNode* root, int x, int y) {\n    pair<int, int> xi = dfs(root, nullptr, 0, x);\n    pair<int, int> yi = dfs(root, nullptr, 0, y);\n    return xi.second == yi.second && xi.first != yi.first;\n}\n\npair<int, int> dfs(TreeNode* root, TreeNode* fa, int depth, int t) {\n    if (root == nullptr) {\n        return {-1, -1};\n    }\n    if (root->val == t) {\n        return {fa ? fa->val : -1, depth};\n    }\n    pair<int, int> l = dfs(root->left, root, depth + 1, t);\n    if (l.first != -1) {\n        return l;\n    }\n    return dfs(root->right, root, depth + 1, t);\n}", "main_fun_name": "isCousins", "raw_prediction": "```cpp\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\npair<int, int> dfs(TreeNode* root, TreeNode* fa, int depth, int t) {\n    if (root == nullptr) {\n        return {-1, -1};\n    }\n    if (root->val == t) {\n        return {fa ? fa->val : -1, depth};\n    }\n    pair<int, int> l = dfs(root->left, root, depth + 1, t);\n    if (l.first != -1) {\n        return l;\n    }\n    return dfs(root->right, root, depth + 1, t);\n}\n\nbool isCousins(TreeNode* root, int x, int y) {\n    pair<int, int> xi = dfs(root, nullptr, 0, x);\n    pair<int, int> yi = dfs(root, nullptr, 0, y);\n    return xi.second == yi.second && xi.first != yi.first;\n}\n```", "sl_gold_code": "def dfs(root, fa, depth, t):\n    if root is None:\n        return [-1, -1]\n    if root.val == t:\n        return [fa.val if fa else -1, depth]\n    l = dfs(root.left, root, depth + 1, t)\n    if l[0] != -1:\n        return l\n    return dfs(root.right, root, depth + 1, t)\ndef isCousins(root, x, y):\n    xi = dfs(root, None, 0, x)\n    yi = dfs(root, None, 0, y)\n    return xi[1] == yi[1] and xi[0] != yi[0]", "tl_gold_code": "vector<int> dfs(TreeNode* root, TreeNode* fa, int depth, int t){\n    if(root ==nullptr)  return vector<int>{-1, -1};\n    if(root->val == t){\n        return vector<int>{fa != nullptr ? fa->val : 1, depth};\n    }\n    vector<int> l = dfs(root->left, root, depth + 1, t);\n    if(l[0] != -1)  return l;\n    return dfs(root->right, root, depth + 1, t);\n}\nbool isCousins(TreeNode* root, int x, int y) {\n    vector<int> xi = dfs(root, nullptr, 0, x);\n    vector<int> yi = dfs(root, nullptr, 0, y);\n    return xi[1] == yi[1] && xi[0] != yi[0];\n}"}
{"task": "python_c++", "problem_id": 99, "prediction_id": 0, "pro_prediction": "int longestSquareStreak(std::vector<int> nums) {\n    int ans = 0;\n    std::set<int> s(nums.begin(), nums.end());\n    for (int x : s) {\n        int cnt = 0;\n        while (s.find(x) != s.end()) {\n            cnt++;\n            x *= x;\n        }\n        ans = std::max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}", "main_fun_name": "longestSquareStreak", "raw_prediction": "```cpp\n#include <vector>\n#include <set>\n\nint longestSquareStreak(std::vector<int> nums) {\n    int ans = 0;\n    std::set<int> s(nums.begin(), nums.end());\n    for (int x : s) {\n        int cnt = 0;\n        while (s.find(x) != s.end()) {\n            cnt++;\n            x *= x;\n        }\n        ans = std::max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}\n```", "sl_gold_code": "def longestSquareStreak(nums: List[int]) -> int:\n    ans, s = 0, set(nums)\n    for x in s:\n        cnt = 0\n        while x in s:\n            cnt += 1\n            x *= x\n        ans = max(ans, cnt)\n    return ans if ans > 1 else -1", "tl_gold_code": "int longestSquareStreak(vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> s(nums.begin(), nums.end());\n    for (int x : s) {\n        int cnt = 0;\n        while (s.find(x) != s.end()) {\n            cnt += 1;\n            if (x > std::sqrt(INT_MAX)) break;\n            x *= x;\n        }\n        ans = max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}"}
{"task": "python_c++", "problem_id": 100, "prediction_id": 0, "pro_prediction": "int appendCharacters(std::string s, std::string t) {\n    int j = 0, m = t.length();\n    for (char c : s) {\n        if (c == t[j]) {\n            j++;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}", "main_fun_name": "appendCharacters", "raw_prediction": "```cpp\n#include <string>\n\nint appendCharacters(std::string s, std::string t) {\n    int j = 0, m = t.length();\n    for (char c : s) {\n        if (c == t[j]) {\n            j++;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}\n```", "sl_gold_code": "def appendCharacters(s: str, t: str) -> int:\n    j, m = 0, len(t)\n    for c in s:\n        if c == t[j]:\n            j += 1\n            if j == m: return 0\n    return m - j", "tl_gold_code": "int appendCharacters(string s, string t) {\n    int j = 0, m = t.size();\n    for (char c : s) {\n        if (c == t[j]) {\n            j += 1;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}"}