[
    {
        "task": "c++_java",
        "problem_id": 1,
        "prediction_id": 0,
        "pro_prediction": "public static int findKOr(int[] nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "findKOr",
        "raw_prediction": "```java\npublic int findKOr(int[] nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int findKOr(vector<int>& nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int findKOr(int[] nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 2,
        "prediction_id": 0,
        "pro_prediction": "public static long minSum(int[] nums1, int[] nums2) {\n    long s1 = 0;\n    boolean zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long s2 = 0;\n    boolean zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if ((!zero1 && s1 < s2) || (!zero2 && s2 < s1)) {\n        return -1;\n    }\n    return Math.max(s1, s2);\n}",
        "main_fun_name": "minSum",
        "raw_prediction": "```java\npublic long minSum(int[] nums1, int[] nums2) {\n    long s1 = 0;\n    boolean zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long s2 = 0;\n    boolean zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if ((!zero1 && s1 < s2) || (!zero2 && s2 < s1)) {\n        return -1;\n    }\n    return Math.max(s1, s2);\n}\n```",
        "sl_gold_code": "long long minSum(vector<int>& nums1, vector<int>& nums2) {\n    long long s1 = 0;\n    bool zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long long s2 = 0;\n    bool zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if (!zero1 && s1 < s2 || !zero2 && s2 < s1) {\n        return -1;\n    }\n    return max(s1, s2);\n}",
        "tl_gold_code": "public static long minSum(int[] nums1, int[] nums2) {\n    long s1 = 0;\n    boolean zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long s2 = 0;\n    boolean zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if (!zero1 && s1 < s2 || !zero2 && s2 < s1) {\n        return -1;\n    }\n    return Math.max(s1, s2);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 3,
        "prediction_id": 0,
        "pro_prediction": "public static int lengthOfLongestSubsequence(List<Integer> nums, int target) {\n    int[] f = new int[target + 1];\n    Arrays.fill(f, Integer.MIN_VALUE);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = Math.min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = Math.max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}",
        "main_fun_name": "lengthOfLongestSubsequence",
        "raw_prediction": "```java\npublic int lengthOfLongestSubsequence(List<Integer> nums, int target) {\n    int[] f = new int[target + 1];\n    Arrays.fill(f, Integer.MIN_VALUE);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = Math.min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = Math.max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}\n```",
        "sl_gold_code": "int lengthOfLongestSubsequence(vector<int> &nums, int target) {\n    vector<int> f(target + 1, INT_MIN);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}",
        "tl_gold_code": "public static int lengthOfLongestSubsequence(List<Integer> nums, int target) {\n    int[] f = new int[target + 1];\n    Arrays.fill(f, Integer.MIN_VALUE);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = Math.min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = Math.max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 4,
        "prediction_id": 0,
        "pro_prediction": "public static int minChanges(String s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += s.charAt(i) != s.charAt(i + 1) ? 1 : 0;\n    }\n    return ans;\n}",
        "main_fun_name": "minChanges",
        "raw_prediction": "```java\npublic int minChanges(String s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += s.charAt(i) != s.charAt(i + 1) ? 1 : 0;\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int minChanges(string s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += s[i] != s[i + 1];\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int minChanges(String s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s.charAt(i) != s.charAt(i + 1)) {\n            ans++;\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 5,
        "prediction_id": 0,
        "pro_prediction": "public static int minGroupsForValidAssignment(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        int k = Collections.min(cnt.values());\n        for (; ; k--) {\n            int ans = 0;\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int c = entry.getValue();\n                if (c / k < c % k) {\n                    ans = 0;\n                    break;\n                }\n                ans += (c + k) / (k + 1);\n            }\n            if (ans > 0) {\n                return ans;\n            }\n        }\n    }",
        "main_fun_name": "minGroupsForValidAssignment",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int minGroupsForValidAssignment(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        int k = Collections.min(cnt.values());\n        for (; ; k--) {\n            int ans = 0;\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int c = entry.getValue();\n                if (c / k < c % k) {\n                    ans = 0;\n                    break;\n                }\n                ans += (c + k) / (k + 1);\n            }\n            if (ans > 0) {\n                return ans;\n            }\n        }\n    }\n}\n```",
        "sl_gold_code": "int minGroupsForValidAssignment(vector<int>& nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int k = min_element(cnt.begin(), cnt.end(), [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    })->second;\n    for (; ; k--) {\n        int ans = 0;\n        for (auto &[_, c] : cnt) {\n            if (c / k < c % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c + k) / (k + 1);\n        }\n        if (ans) {\n            return ans;\n        }\n    }\n}",
        "tl_gold_code": "public static int minGroupsForValidAssignment(int[] nums) {\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int x : nums) {\n        cnt.merge(x, 1, Integer::sum);\n    }\n    int k = nums.length;\n    for (int c : cnt.values()) {\n        k = Math.min(k, c);\n    }\n    for (; ; k--) {\n        int ans = 0;\n        for (int c : cnt.values()) {\n            if (c / k < c % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c + k) / (k + 1);\n        }\n        if (ans > 0) {\n            return ans;\n        }\n    }\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 6,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumSum(int[] nums) {\n    int n = nums.length;\n    int[] suf = new int[n];\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = Math.min(suf[i + 1], nums[i]);\n    }\n    int ans = Integer.MAX_VALUE;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = Math.min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = Math.min(pre, nums[j]);\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n}",
        "main_fun_name": "minimumSum",
        "raw_prediction": "```java\npublic int minimumSum(int[] nums) {\n    int n = nums.length;\n    int[] suf = new int[n];\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = Math.min(suf[i + 1], nums[i]);\n    }\n    int ans = Integer.MAX_VALUE;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = Math.min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = Math.min(pre, nums[j]);\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n}\n```",
        "sl_gold_code": "int minimumSum(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> suf(n);\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = min(suf[i + 1], nums[i]);\n    }\n    int ans = INT_MAX;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = min(pre, nums[j]);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}",
        "tl_gold_code": "public static int minimumSum(int[] nums) {\n    int n = nums.length;\n    int[] suf = new int[n];\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = Math.min(suf[i + 1], nums[i]);\n    }\n    int ans = Integer.MAX_VALUE;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = Math.min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = Math.min(pre, nums[j]);\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 7,
        "prediction_id": 0,
        "pro_prediction": "public static int[][] constructProductMatrix(int[][] grid) {\n    final int MOD = 12345;\n    int n = grid.length, m = grid[0].length;\n    int[][] p = new int[n][m];\n    long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = (int) suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = (int) (p[i][j] * pre % MOD);\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}",
        "main_fun_name": "constructProductMatrix",
        "raw_prediction": "```java\npublic int[][] constructProductMatrix(int[][] grid) {\n    final int MOD = 12345;\n    int n = grid.length, m = grid[0].length;\n    int[][] p = new int[n][m];\n    long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = (int) suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = (int) (p[i][j] * pre % MOD);\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}\n```",
        "sl_gold_code": "vector<vector<int>> constructProductMatrix(vector<vector<int>> &grid) {\n    const int MOD = 12345;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> p(n, vector<int>(m));\n    long long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = p[i][j] * pre % MOD;\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}",
        "tl_gold_code": "public static int[][] constructProductMatrix(int[][] grid) {\n    final int MOD = 12345;\n    int n = grid.length, m = grid[0].length;\n    int[][] p = new int[n][m];\n    long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = (int) suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = (int) (p[i][j] * pre % MOD);\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 8,
        "prediction_id": 0,
        "pro_prediction": "public static String maximumOddBinaryNumber(String s) {\n    int cnt1 = (int) s.chars().filter(ch -> ch == '1').count();\n    return String.format(\"%s%s1\", \n            String.join(\"\", Collections.nCopies(cnt1 - 1, \"1\")), \n            String.join(\"\", Collections.nCopies(s.length() - cnt1, \"0\")));\n}",
        "main_fun_name": "maximumOddBinaryNumber",
        "raw_prediction": "```java\npublic String maximumOddBinaryNumber(String s) {\n    int cnt1 = (int) s.chars().filter(ch -> ch == '1').count();\n    return String.format(\"%s%s1\", \n            String.join(\"\", Collections.nCopies(cnt1 - 1, \"1\")), \n            String.join(\"\", Collections.nCopies(s.length() - cnt1, \"0\")));\n}\n```\nNote: The Java version uses `String.join()` and `Collections.nCopies()` to create the required strings of '1's and '0's, which is slightly different from the C++ version that uses `string(cnt1 - 1, '1')` and `string(s.length() - cnt1, '0')`. The end result, however, should be the same.",
        "sl_gold_code": "string maximumOddBinaryNumber(string s) {\n    int cnt1 = count(s.begin(), s.end(), '1');\n    return string(cnt1 - 1, '1') + string(s.length() - cnt1, '0') + '1';\n}",
        "tl_gold_code": "public static String maximumOddBinaryNumber(String s) {\n    int cnt1 = (int) s.chars().filter(c -> c == '1').count();\n    return \"1\".repeat(cnt1 - 1) + \"0\".repeat(s.length() - cnt1) + \"1\";\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 9,
        "prediction_id": 0,
        "pro_prediction": "public static String shortestBeautifulSubstring(String s, int k) {\n    if ((int) s.chars().filter(ch -> ch == '1').count() < k) {\n        return \"\";\n    }\n    String ans = s;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length(); right++) {\n        cnt1 += s.charAt(right) - '0';\n        while (cnt1 > k || s.charAt(left) == '0') {\n            cnt1 -= s.charAt(left++) - '0';\n        }\n        if (cnt1 == k) {\n            String t = s.substring(left, right + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "shortestBeautifulSubstring",
        "raw_prediction": "```java\npublic String shortestBeautifulSubstring(String s, int k) {\n    if ((int) s.chars().filter(ch -> ch == '1').count() < k) {\n        return \"\";\n    }\n    String ans = s;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length(); right++) {\n        cnt1 += s.charAt(right) - '0';\n        while (cnt1 > k || s.charAt(left) == '0') {\n            cnt1 -= s.charAt(left++) - '0';\n        }\n        if (cnt1 == k) {\n            String t = s.substring(left, right + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "string shortestBeautifulSubstring(string s, int k) {\n    if (count(s.begin(), s.end(), '1') < k) {\n        return \"\";\n    }\n    string ans = s;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length(); right++) {\n        cnt1 += s[right] - '0';\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= s[left++] - '0';\n        }\n        if (cnt1 == k) {\n            string t = s.substr(left, right - left + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t < ans) {\n                ans = move(t);\n            }\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static String shortestBeautifulSubstring(String S, int k) {\n    if (S.replace(\"0\", \"\").length() < k) {\n        return \"\";\n    }\n    char[] s = S.toCharArray();\n    String ans = S;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length; right++) {\n        cnt1 += s[right] - '0';\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= s[left++] - '0';\n        }\n        if (cnt1 == k) {\n            String t = S.substring(left, right + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {\n                ans = t;\n            }\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 10,
        "prediction_id": 0,
        "pro_prediction": "public static int addMinimum(String s) {\n    int t = 1;\n    for (int i = 1; i < s.length(); ++i)\n        t += s.charAt(i - 1) >= s.charAt(i) ? 1 : 0;\n    return t * 3 - s.length();\n}",
        "main_fun_name": "addMinimum",
        "raw_prediction": "```java\npublic int addMinimum(String s) {\n    int t = 1;\n    for (int i = 1; i < s.length(); ++i)\n        t += s.charAt(i - 1) >= s.charAt(i) ? 1 : 0;\n    return t * 3 - s.length();\n}\n```",
        "sl_gold_code": "int addMinimum(string s) {\n    int t = 1;\n    for (int i = 1; i < s.length(); ++i)\n        t += s[i - 1] >= s[i];\n    return t * 3 - s.length();\n}",
        "tl_gold_code": "public static int addMinimum(String word) {\n    var s = word.toCharArray();\n    int t = 1;\n    for (int i = 1; i < s.length; ++i)\n        if (s[i - 1] >= s[i])\n            ++t;\n    return t * 3 - s.length;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 11,
        "prediction_id": 0,
        "pro_prediction": "public static int maxIncreasingGroups(List<Integer> usageLimits) {\n        Collections.sort(usageLimits);\n        long remain = 0;\n        int require = 1;\n        for (int num : usageLimits) {\n            remain += num;\n            if (remain >= require) {\n                remain -= require;\n                require++;\n            }\n        }\n        return require - 1;\n    }",
        "main_fun_name": "maxIncreasingGroups",
        "raw_prediction": "```java\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static int maxIncreasingGroups(List<Integer> usageLimits) {\n        Collections.sort(usageLimits);\n        long remain = 0;\n        int require = 1;\n        for (int num : usageLimits) {\n            remain += num;\n            if (remain >= require) {\n                remain -= require;\n                require++;\n            }\n        }\n        return require - 1;\n    }\n}\n```",
        "sl_gold_code": "int maxIncreasingGroups(vector<int>& usageLimits) {\n    sort(usageLimits.begin(), usageLimits.end());\n    long long remain = 0;\n    int require = 1;\n    for (int num : usageLimits) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require++;\n        }\n    }\n    return require - 1;\n}",
        "tl_gold_code": "public static int maxIncreasingGroups(List<Integer> usageLimits) {\n    Collections.sort(usageLimits);\n    long remain = 0;\n    int require = 1;\n    for (int num : usageLimits) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require++;\n        }\n    }\n    return require - 1;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 12,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> lastVisitedIntegers(List<String> words) {\n        List<Integer> ans = new ArrayList<>();\n        List<Integer> a = new ArrayList<>();\n        int k = 0;\n        for (String s : words) {\n            if (s.charAt(0) != 'p') {\n                a.add(Integer.parseInt(s));\n                k = 0;\n            } else {\n                ans.add(++k > a.size() ? -1 : a.get(a.size() - k));\n            }\n        }\n        return ans;\n    }",
        "main_fun_name": "lastVisitedIntegers",
        "raw_prediction": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<Integer> lastVisitedIntegers(List<String> words) {\n        List<Integer> ans = new ArrayList<>();\n        List<Integer> a = new ArrayList<>();\n        int k = 0;\n        for (String s : words) {\n            if (s.charAt(0) != 'p') {\n                a.add(Integer.parseInt(s));\n                k = 0;\n            } else {\n                ans.add(++k > a.size() ? -1 : a.get(a.size() - k));\n            }\n        }\n        return ans;\n    }\n}\n```",
        "sl_gold_code": "vector<int> lastVisitedIntegers(vector<string> &words) {\n    vector<int> ans, a;\n    int k = 0;\n    for (auto &s: words) {\n        if (s[0] != 'p') { \n            a.push_back(stoi(s));\n            k = 0;\n        } else {\n            ans.push_back(++k > a.size() ? -1 : a[a.size() - k]); \n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static List<Integer> lastVisitedIntegers(List<String> words) {\n    List<Integer> ans = new ArrayList<>();\n    List<Integer> a = new ArrayList<>();\n    int k = 0;\n    for (String s : words) {\n        if (s.charAt(0) != 'p') { \n            a.add(Integer.parseInt(s));\n            k = 0;\n        } else {\n            ans.add(++k > a.size() ? -1 : a.get(a.size() - k)); \n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 13,
        "prediction_id": 0,
        "pro_prediction": "public static int minOperations(String s1, String s2, int x) {\n    if (s1.equals(s2)) return 0;\n    List<Integer> p = new ArrayList<>();\n    for (int i = 0; i < s1.length(); i++)\n        if (s1.charAt(i) != s2.charAt(i))\n            p.add(i);\n    if (p.size() % 2 != 0) return -1;\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int new_f = Math.min(f1 + x, f0 + (p.get(i) - p.get(i - 1)) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}",
        "main_fun_name": "minOperations",
        "raw_prediction": "```java\npublic int minOperations(String s1, String s2, int x) {\n    if (s1.equals(s2)) return 0;\n    List<Integer> p = new ArrayList<>();\n    for (int i = 0; i < s1.length(); i++)\n        if (s1.charAt(i) != s2.charAt(i))\n            p.add(i);\n    if (p.size() % 2 != 0) return -1;\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int new_f = Math.min(f1 + x, f0 + (p.get(i) - p.get(i - 1)) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}\n```",
        "sl_gold_code": "int minOperations(string s1, string s2, int x) {\n    if (s1 == s2) return 0;\n    vector<int> p;\n    for (int i = 0; i < s1.size(); i++)\n        if (s1[i] != s2[i])\n            p.push_back(i);\n    if (p.size() % 2) return -1;\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}",
        "tl_gold_code": "public static int minOperations(String s1, String s2, int x) {\n    if (s1.equals(s2)) {\n        return 0;\n    }\n    List<Integer> p = new ArrayList<>();\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            p.add(i);\n        }\n    }\n    if (p.size() % 2 != 0) {\n        return -1;\n    }\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int newF = Math.min(f1 + x, f0 + (p.get(i) - p.get(i - 1)) * 2);\n        f0 = f1;\n        f1 = newF;\n    }\n    return f1 / 2;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 14,
        "prediction_id": 0,
        "pro_prediction": "public static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\n    Collections.sort(processorTime);\n    Collections.sort(tasks, Collections.reverseOrder());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4));\n    }\n    return ans;\n}",
        "main_fun_name": "minProcessingTime",
        "raw_prediction": "```java\npublic static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\n    Collections.sort(processorTime);\n    Collections.sort(tasks, Collections.reverseOrder());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4));\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {\n    sort(processorTime.begin(), processorTime.end());\n    sort(tasks.begin(), tasks.end(), greater<int>());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = max(ans, processorTime[i] + tasks[i * 4]);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {\n    Collections.sort(processorTime);\n    tasks.sort(Collections.reverseOrder());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4));\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 15,
        "prediction_id": 0,
        "pro_prediction": "public static int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}",
        "main_fun_name": "differenceOfSums",
        "raw_prediction": "```java\npublic static int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}\n```",
        "sl_gold_code": "int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}",
        "tl_gold_code": "public static int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 16,
        "prediction_id": 0,
        "pro_prediction": "public static int minSizeSubarray(int[] nums, int target) {\n    long total = Arrays.stream(nums).asLongStream().sum();\n    int n = nums.length;\n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = Math.min(ans, right - left + 1);\n        }\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans + (int) (target / total * n);\n}",
        "main_fun_name": "minSizeSubarray",
        "raw_prediction": "```java\npublic int minSizeSubarray(int[] nums, int target) {\n    long total = Arrays.stream(nums).asLongStream().sum();\n    int n = nums.length;\n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = Math.min(ans, right - left + 1);\n        }\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans + (int) (target / total * n);\n}\n```",
        "sl_gold_code": "int minSizeSubarray(vector<int> &nums, int target) {\n    long long total = accumulate(nums.begin(), nums.end(), 0LL);\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    long long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = min(ans, right - left + 1);\n        }\n    }\n    return ans == INT_MAX ? -1 : ans + target / total * n;\n}",
        "tl_gold_code": "public static int minSizeSubarray(int[] nums, int target) {\n    long total = 0;\n    for (int x : nums) total += x;\n    int n = nums.length;\n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = Math.min(ans, right - left + 1);\n        }\n    }\n    return ans == Integer.MAX_VALUE ? -1 : ans + (int) (target / total) * n;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 17,
        "prediction_id": 0,
        "pro_prediction": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] suf_max = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = Math.max(pre_max, nums[j]);\n    }\n    return ans;\n}",
        "main_fun_name": "maximumTripletValue",
        "raw_prediction": "```java\npublic long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] suf_max = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = Math.max(pre_max, nums[j]);\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "long long maximumTripletValue(vector<int> &nums) {\n    int n = nums.size();\n    vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = max(pre_max, nums[j]);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] sufMax = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        sufMax[i] = Math.max(sufMax[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int preMax = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (preMax - nums[j]) * sufMax[j + 1]);\n        preMax = Math.max(preMax, nums[j]);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 18,
        "prediction_id": 0,
        "pro_prediction": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] suf_max = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = Math.max(pre_max, nums[j]);\n    }\n    return ans;\n}",
        "main_fun_name": "maximumTripletValue",
        "raw_prediction": "```java\npublic long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] suf_max = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = Math.max(suf_max[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = Math.max(pre_max, nums[j]);\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "long long maximumTripletValue(vector<int> &nums) {\n    int n = nums.size();\n    vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = max(pre_max, nums[j]);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static long maximumTripletValue(int[] nums) {\n    int n = nums.length;\n    int[] sufMax = new int[n + 1];\n    for (int i = n - 1; i > 1; i--) {\n        sufMax[i] = Math.max(sufMax[i + 1], nums[i]);\n    }\n    long ans = 0;\n    int preMax = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = Math.max(ans, (long) (preMax - nums[j]) * sufMax[j + 1]);\n        preMax = Math.max(preMax, nums[j]);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 19,
        "prediction_id": 0,
        "pro_prediction": "public static int maxSubarrays(int[] nums) {\n    int ans = 0;\n    int a = -1;\n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++;\n            a = -1;\n        }\n    }\n    return Math.max(ans, 1);\n}",
        "main_fun_name": "maxSubarrays",
        "raw_prediction": "```java\npublic int maxSubarrays(int[] nums) {\n    int ans = 0;\n    int a = -1;\n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++;\n            a = -1;\n        }\n    }\n    return Math.max(ans, 1);\n}\n```",
        "sl_gold_code": "int maxSubarrays(vector<int> &nums) {\n    int ans = 0;\n    int a = -1; \n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++; \n            a = -1;\n        }\n    }\n    return max(ans, 1); \n}",
        "tl_gold_code": "public static int maxSubarrays(int[] nums) {\n    int ans = 0;\n    int a = -1; \n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++; \n            a = -1;\n        }\n    }\n    return Math.max(ans, 1); \n}"
    },
    {
        "task": "c++_java",
        "problem_id": 20,
        "prediction_id": 0,
        "pro_prediction": "public static int minOperations(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        int ans = 0;\n        for (var entry : cnt.entrySet()) {\n            int c = entry.getValue();\n            if (c == 1) {\n                return -1;\n            }\n            ans += (c + 2) / 3;\n        }\n        return ans;\n    }",
        "main_fun_name": "minOperations",
        "raw_prediction": "```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static int minOperations(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n        }\n        int ans = 0;\n        for (var entry : cnt.entrySet()) {\n            int c = entry.getValue();\n            if (c == 1) {\n                return -1;\n            }\n            ans += (c + 2) / 3;\n        }\n        return ans;\n    }\n}\n```",
        "sl_gold_code": "int minOperations(vector<int> &nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int ans = 0;\n    for (auto &[_, c] : cnt) {\n        if (c == 1) {\n            return -1;\n        }\n        ans += (c + 2) / 3;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int minOperations(int[] nums) {\n    var cnt = new HashMap<Integer, Integer>();\n    for (int x : nums) {\n        cnt.merge(x, 1, Integer::sum);\n    }\n    int ans = 0;\n    for (int c : cnt.values()) {\n        if (c == 1) {\n            return -1;\n        }\n        ans += (c + 2) / 3;\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 21,
        "prediction_id": 0,
        "pro_prediction": "public static int minOperations(List<Integer> nums, int k) {\n    int n = nums.size();\n    long u = (2L << k) - 2;\n    long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1L << nums[i];\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}",
        "main_fun_name": "minOperations",
        "raw_prediction": "```java\npublic int minOperations(List<Integer> nums, int k) {\n    int n = nums.size();\n    long u = (2L << k) - 2;\n    long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1L << nums[i];\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}\n```",
        "sl_gold_code": "int minOperations(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    long long u = (2LL << k) - 2;\n    long long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1LL << nums[i];\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}",
        "tl_gold_code": "public static int minOperations(List<Integer> nums, int k) {\n    int n = nums.size();\n    long u = (2L << k) - 2; \n    long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1L << nums.get(i);\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 22,
        "prediction_id": 0,
        "pro_prediction": "public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n        int ans = 0;\n        int mx = Collections.min(stock) + budget;\n        for (List<Integer> com : composition) {\n            Check check = new Check(com, stock, cost);\n            int left = 0, right = mx + 1;\n            while (left + 1 < right) {\n                int mid = (left + right) / 2;\n                if (check.test(mid)) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n            ans = Math.max(ans, left);\n        }\n        return ans;\n    }\n\npublic static Check(List<Integer> com, List<Integer> stock, List<Integer> cost) {\n            this.com = com;\n            this.stock = stock;\n            this.cost = cost;\n        }\n\npublic static boolean test(long num) {\n            long money = 0;\n            for (int i = 0; i < com.size(); i++) {\n                if (stock.get(i) < com.get(i) * num) {\n                    money += (com.get(i) * num - stock.get(i)) * cost.get(i);\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }",
        "main_fun_name": "maxNumberOfAlloys",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n        int ans = 0;\n        int mx = Collections.min(stock) + budget;\n        for (List<Integer> com : composition) {\n            Check check = new Check(com, stock, cost);\n            int left = 0, right = mx + 1;\n            while (left + 1 < right) {\n                int mid = (left + right) / 2;\n                if (check.test(mid)) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n            ans = Math.max(ans, left);\n        }\n        return ans;\n    }\n    \n    static class Check {\n        private final List<Integer> com;\n        private final List<Integer> stock;\n        private final List<Integer> cost;\n        \n        public Check(List<Integer> com, List<Integer> stock, List<Integer> cost) {\n            this.com = com;\n            this.stock = stock;\n            this.cost = cost;\n        }\n        \n        public boolean test(long num) {\n            long money = 0;\n            for (int i = 0; i < com.size(); i++) {\n                if (stock.get(i) < com.get(i) * num) {\n                    money += (com.get(i) * num - stock.get(i)) * cost.get(i);\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }\n}\n```",
        "sl_gold_code": "int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>> &composition, vector<int> &stock, vector<int> &cost) {\n    int ans = 0;\n    int mx = *min_element(stock.begin(), stock.end()) + budget;\n    for (auto &com: composition) {\n        auto check = [&](long long num) -> bool {\n            long long money = 0;\n            for (int i = 0; i < n; i++) {\n                if (stock[i] < com[i] * num) {\n                    money += (com[i] * num - stock[i]) * cost[i];\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) { \n            int mid = (left + right) / 2;\n            (check(mid) ? left : right) = mid;\n        }\n        ans = max(ans, left);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n    int ans = 0;\n    int mx = Collections.min(stock) + budget;\n    for (var com : composition) {\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) { \n            int mid = (left + right) / 2;\n            boolean ok = true;\n            long money = 0;\n            for (int i = 0; i < n; ++i) {\n                if (stock.get(i) < (long) com.get(i) * mid) {\n                    money += ((long) com.get(i) * mid - stock.get(i)) * cost.get(i);\n                    if (money > budget) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            if (ok) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        ans = Math.max(ans, left);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 23,
        "prediction_id": 0,
        "pro_prediction": "public static int countWays(List<Integer> nums) {\n    Collections.sort(nums);\n    int n = nums.size();\n    int ans = nums.get(0) > 0 ? 1 : 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (nums.get(i) < i + 1 && i + 1 < nums.get(i + 1)) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}",
        "main_fun_name": "countWays",
        "raw_prediction": "```java\npublic int countWays(List<Integer> nums) {\n    Collections.sort(nums);\n    int n = nums.size();\n    int ans = nums.get(0) > 0 ? 1 : 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (nums.get(i) < i + 1 && i + 1 < nums.get(i + 1)) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}\n```",
        "sl_gold_code": "int countWays(vector<int> &nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    int ans = nums[0] > 0; \n    for (int i = 0; i < n - 1; i++) {\n        if (nums[i] < i + 1 && i + 1 < nums[i + 1]) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}",
        "tl_gold_code": "public static int countWays(List<Integer> nums) {\n    int[] a = nums.stream().mapToInt(i -> i).toArray();\n    Arrays.sort(a);\n    int n = a.length;\n    int ans = a[0] > 0 ? 1 : 0; \n    for (int i = 0; i < n - 1; i++) {\n        if (a[i] < i + 1 && i + 1 < a[i + 1]) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 24,
        "prediction_id": 0,
        "pro_prediction": "public static int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (Integer.bitCount(i) == k) {\n            ans += nums.get(i);\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "sumIndicesWithKSetBits",
        "raw_prediction": "```java\npublic int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (Integer.bitCount(i) == k) {\n            ans += nums.get(i);\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int sumIndicesWithKSetBits(vector<int> &nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (__builtin_popcount(i) == k) {\n            ans += nums[i];\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (Integer.bitCount(i) == k) {\n            ans += nums.get(i);\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 25,
        "prediction_id": 0,
        "pro_prediction": "public static int countPairs(List<List<Integer>> coordinates, int k) {\n        int ans = 0;\n        Map<Long, Integer> cnt = new HashMap<>();\n        for (List<Integer> p : coordinates) {\n            for (int i = 0; i <= k; i++) {\n                long key = ((long)p.get(0) ^ i) * 2000000 + ((long)p.get(1) ^ (k - i));\n                if (cnt.containsKey(key)) {\n                    ans += cnt.get(key);\n                }\n            }\n            long key = (long)p.get(0) * 2000000 + (long)p.get(1);\n            cnt.put(key, cnt.getOrDefault(key, 0) + 1);\n        }\n        return ans;\n    }",
        "main_fun_name": "countPairs",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int countPairs(List<List<Integer>> coordinates, int k) {\n        int ans = 0;\n        Map<Long, Integer> cnt = new HashMap<>();\n        for (List<Integer> p : coordinates) {\n            for (int i = 0; i <= k; i++) {\n                long key = ((long)p.get(0) ^ i) * 2000000 + ((long)p.get(1) ^ (k - i));\n                if (cnt.containsKey(key)) {\n                    ans += cnt.get(key);\n                }\n            }\n            long key = (long)p.get(0) * 2000000 + (long)p.get(1);\n            cnt.put(key, cnt.getOrDefault(key, 0) + 1);\n        }\n        return ans;\n    }\n}\n```",
        "sl_gold_code": "int countPairs(vector<vector<int>> &coordinates, int k) {\n    int ans = 0;\n    unordered_map<long long, int> cnt;\n    for (auto &p: coordinates) {\n        for (int i = 0; i <= k; i++) {\n            auto it = cnt.find((p[0] ^ i) * 2000000LL + (p[1] ^ (k - i)));\n            if (it != cnt.end()) {\n                ans += it->second;\n            }\n        }\n        cnt[p[0] * 2000000LL + p[1]]++;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int countPairs(List<List<Integer>> coordinates, int k) {\n    int ans = 0;\n    var cnt = new HashMap<Long, Integer>();\n    for (var p : coordinates) {\n        int x = p.get(0), y = p.get(1);\n        for (int i = 0; i <= k; i++) {\n            ans += cnt.getOrDefault((x ^ i) * 2000000L + (y ^ (k - i)), 0);\n        }\n        cnt.merge(x * 2000000L + y, 1, Integer::sum);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 26,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumRightShifts(List<Integer> nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums.get(0) < nums.get(n - 1)) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}",
        "main_fun_name": "minimumRightShifts",
        "raw_prediction": "```java\npublic int minimumRightShifts(List<Integer> nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums.get(0) < nums.get(n - 1)) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}\n```",
        "sl_gold_code": "int minimumRightShifts(vector<int>& nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums[0] < nums[n - 1]) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}",
        "tl_gold_code": "public static int minimumRightShifts(List<Integer> nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums.get(0) < nums.get(n - 1)) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums.get(i - 1) < nums.get(i)) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 27,
        "prediction_id": 0,
        "pro_prediction": "public static int minLengthAfterRemovals(List<Integer> nums) {\n    int maxCnt = 0, cnt = 1, pre = nums.get(0);\n    int n = nums.size();\n    for(int i = 1; i < n; ++i) {\n        if(pre == nums.get(i)) cnt++;\n        else {\n            maxCnt = Math.max(maxCnt, cnt);\n            pre = nums.get(i);\n            cnt = 1;\n        }\n    }\n    maxCnt = Math.max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}",
        "main_fun_name": "minLengthAfterRemovals",
        "raw_prediction": "```java\npublic int minLengthAfterRemovals(List<Integer> nums) {\n    int maxCnt = 0, cnt = 1, pre = nums.get(0);\n    int n = nums.size();\n    for(int i = 1; i < n; ++i) {\n        if(pre == nums.get(i)) cnt++;\n        else {\n            maxCnt = Math.max(maxCnt, cnt);\n            pre = nums.get(i);\n            cnt = 1;\n        }\n    }\n    maxCnt = Math.max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}\n```",
        "sl_gold_code": "int minLengthAfterRemovals(vector<int> &nums) {\n    int maxCnt = 0, cnt = 1, pre = nums[0];\n    int n = nums.size();\n    for(int i = 1; i < n; ++i) {\n        if(pre == nums[i]) cnt++;\n        else {\n            maxCnt = max(maxCnt, cnt);\n            pre = nums[i];\n            cnt = 1;\n        }\n    }\n    maxCnt = max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}",
        "tl_gold_code": "public static int minLengthAfterRemovals(List<Integer> nums) {\n    int maxCnt = 0, cnt = 1;\n    int pre = nums.get(0);\n    int n = nums.size();\n    for(int i = 1; i < n; i++) {\n        if(pre == nums.get(i)) cnt++;\n        else {\n            maxCnt = Math.max(maxCnt, cnt);\n            pre = nums.get(i);\n            cnt = 1;\n        }\n    }\n    maxCnt = Math.max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 28,
        "prediction_id": 0,
        "pro_prediction": "public static int numberOfPoints(List<List<Integer>> nums) {\n    int[] diff = new int[102];\n    for (List<Integer> p : nums) {\n        diff[p.get(0)]++;\n        diff[p.get(1) + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d : diff) {\n        s += d;\n        ans += s > 0 ? 1 : 0;\n    }\n    return ans;\n}",
        "main_fun_name": "numberOfPoints",
        "raw_prediction": "```java\npublic int numberOfPoints(List<List<Integer>> nums) {\n    int[] diff = new int[102];\n    for (List<Integer> p : nums) {\n        diff[p.get(0)]++;\n        diff[p.get(1) + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d : diff) {\n        s += d;\n        ans += s > 0 ? 1 : 0;\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int numberOfPoints(vector<vector<int>> &nums) {\n    int diff[102]{};\n    for (auto &p: nums) {\n        diff[p[0]]++;\n        diff[p[1] + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d: diff) {\n        s += d;\n        ans += s > 0;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int numberOfPoints(List<List<Integer>> nums) {\n    var diff = new int[102];\n    for (var p : nums) {\n        diff[p.get(0)]++;\n        diff[p.get(1) + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d : diff) {\n        s += d;\n        if (s > 0) {\n            ans++;\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 29,
        "prediction_id": 0,
        "pro_prediction": "public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy)\n        return t != 1;\n    return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t;\n}",
        "main_fun_name": "isReachableAtTime",
        "raw_prediction": "```java\npublic static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy)\n        return t != 1;\n    return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t;\n}\n```",
        "sl_gold_code": "bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy)\n        return t != 1;\n    return max(abs(sx - fx), abs(sy - fy)) <= t;\n}",
        "tl_gold_code": "public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy) {\n        return t != 1;\n    }\n    return Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) <= t;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 30,
        "prediction_id": 0,
        "pro_prediction": "public static long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    int[] preSum = new int[n+1];\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + ((nums.get(i) % modulo == k)?1:0);\n    Map<Integer, Integer> map = new HashMap<>();\n    for(int i=0;i<=n;i++){\n        int key = (preSum[i]%modulo - k + modulo)%modulo;\n        if(map.containsKey(key))\n            ans += map.get(key);\n        map.put(preSum[i]%modulo, map.getOrDefault(preSum[i]%modulo, 0) + 1);\n    }\n    return ans;\n}",
        "main_fun_name": "countInterestingSubarrays",
        "raw_prediction": "```java\npublic long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    int[] preSum = new int[n+1];\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + ((nums.get(i) % modulo == k)?1:0);\n    Map<Integer, Integer> map = new HashMap<>();\n    for(int i=0;i<=n;i++){\n        int key = (preSum[i]%modulo - k + modulo)%modulo;\n        if(map.containsKey(key))\n            ans += map.get(key);\n        map.put(preSum[i]%modulo, map.getOrDefault(preSum[i]%modulo, 0) + 1);\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "long countInterestingSubarrays(vector<int> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    vector<int> preSum(n+1);\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + (nums[i] % modulo == k?1:0);\n    unordered_map<int,int> map;\n    for(int i=0;i<=n;i++){\n        if(map.count((preSum[i]%modulo - k + modulo)%modulo))\n            ans += map[(preSum[i]%modulo - k + modulo)%modulo];\n        map[preSum[i]%modulo]++;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    int[] preSum = new int[n+1];\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + (nums.get(i) % modulo == k?1:0);\n    Map<Integer,Integer> map = new HashMap<>();\n    for(int i=0;i<=n;i++){\n        if(map.containsKey((preSum[i]%modulo - k + modulo)%modulo))\n            ans += map.get((preSum[i]%modulo - k + modulo)%modulo);\n        map.put(preSum[i]%modulo,map.getOrDefault(preSum[i]%modulo,0)+1);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 31,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumOperations(String num) {\n    int len = num.length();\n    int zero = num.indexOf(\"0\") != -1 ? len - 1 : len;\n    return Math.min(f(\"00\", num), Math.min(f(\"25\", num), Math.min(f(\"50\", num), Math.min(f(\"75\", num), zero))));\n}\n\npublic static int f(String target, String num) {\n    int i = num.lastIndexOf(target.charAt(1));\n    if (i < 0) return num.length();\n    i = num.substring(0, i).lastIndexOf(target.charAt(0));\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}",
        "main_fun_name": "minimumOperations",
        "raw_prediction": "```java\npublic static int minimumOperations(String num) {\n    int len = num.length();\n    int zero = num.indexOf(\"0\") != -1 ? len - 1 : len;\n    return Math.min(f(\"00\", num), Math.min(f(\"25\", num), Math.min(f(\"50\", num), Math.min(f(\"75\", num), zero))));\n}\n\npublic static int f(String target, String num) {\n    int i = num.lastIndexOf(target.charAt(1));\n    if (i < 0) return num.length();\n    i = num.substring(0, i).lastIndexOf(target.charAt(0));\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}\n```",
        "sl_gold_code": "int minimumOperations(string num) {\n    int len = num.length();\n    int zero = num.find(\"0\") != string::npos ? len - 1 : len;\n    return min({f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero});\n}\nint f(string target, string num) {\n    int i = num.rfind(target[1]);\n    if (i < 0) return num.length();\n    i = num.substr(0, i).rfind(target[0]);\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}",
        "tl_gold_code": "public static  int minimumOperations(String num) {\n    int len = num.length();\n    int zero = num.contains(\"0\")? len - 1: len;\n    return Math.min(f(\"00\", num),\n    Math.min( f(\"25\", num), Math.min(f(\"50\", num), Math.min(f(\"75\", num), zero))));\n}\npublic static  int f(String target, String num) {\n    int i = num.lastIndexOf(target.substring(1));\n    if (i < 0) return num.length();\n    i = num.substring(0, i).lastIndexOf(target.substring(0,1));\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 32,
        "prediction_id": 0,
        "pro_prediction": "public static int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        String s = Integer.toString(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s.charAt(j) - '0';\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s.charAt(j) - '0';\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "countSymmetricIntegers",
        "raw_prediction": "```java\npublic int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        String s = Integer.toString(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s.charAt(j) - '0';\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s.charAt(j) - '0';\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        string s = to_string(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s[j];\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s[j];\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        char[] s = Integer.toString(i).toCharArray();\n        int n = s.length;\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s[j];\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s[j];\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 33,
        "prediction_id": 0,
        "pro_prediction": "public static long maxSum(List<Integer> nums, int m, int k) {\n    long ans = 0;\n    long sum = 0;\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int i = 0; i < k - 1; i++) {\n        sum += nums.get(i);\n        cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), 0) + 1);\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += nums.get(i);\n        cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), 0) + 1);\n        if (cnt.size() >= m)\n            ans = Math.max(ans, sum);\n        int out = nums.get(i - k + 1);\n        sum -= out;\n        if (--cnt.get(out) == 0)\n            cnt.remove(out);\n    }\n    return ans;\n}",
        "main_fun_name": "maxSum",
        "raw_prediction": "```java\npublic long maxSum(List<Integer> nums, int m, int k) {\n    long ans = 0;\n    long sum = 0;\n    Map<Integer, Integer> cnt = new HashMap<>();\n    for (int i = 0; i < k - 1; i++) {\n        sum += nums.get(i);\n        cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), 0) + 1);\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += nums.get(i);\n        cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), 0) + 1);\n        if (cnt.size() >= m)\n            ans = Math.max(ans, sum);\n        int out = nums.get(i - k + 1);\n        sum -= out;\n        if (--cnt.get(out) == 0)\n            cnt.remove(out);\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "long long maxSum(vector<int> &nums, int m, int k) {\n    long long ans = 0, sum = 0;\n    unordered_map<int, int> cnt;\n    for (int i = 0; i < k - 1; i++) { \n        sum += nums[i];\n        cnt[nums[i]]++;\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += nums[i]; \n        cnt[nums[i]]++;\n        if (cnt.size() >= m)\n            ans = max(ans, sum);\n        int out = nums[i - k + 1];\n        sum -= out; \n        if (--cnt[out] == 0)\n            cnt.erase(out);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static long maxSum(List<Integer> nums, int m, int k) {\n    var a = nums.stream().mapToInt(i -> i).toArray();\n    long ans = 0, sum = 0;\n    var cnt = new HashMap<Integer, Integer>();\n    for (int i = 0; i < k - 1; i++) { \n        sum += a[i];\n        cnt.merge(a[i], 1, Integer::sum);\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += a[i]; \n        cnt.merge(a[i], 1, Integer::sum);\n        if (cnt.size() >= m)\n            ans = Math.max(ans, sum);\n        int out = a[i - k + 1];\n        sum -= out; \n        if (cnt.merge(out, -1, Integer::sum) == 0)\n            cnt.remove(out);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 34,
        "prediction_id": 0,
        "pro_prediction": "public static boolean checkStrings(String s1, String s2) {\n    int[][] cnt1 = new int[2][26];\n    int[][] cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}",
        "main_fun_name": "checkStrings",
        "raw_prediction": "```java\npublic static boolean checkStrings(String s1, String s2) {\n    int[][] cnt1 = new int[2][26];\n    int[][] cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}\n```",
        "sl_gold_code": "bool checkStrings(string s1, string s2) {\n    int cnt1[2][26]{}, cnt2[2][26]{};\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0;\n}",
        "tl_gold_code": "public static boolean checkStrings(String s1, String s2) {\n    var cnt1 = new int[2][26];\n    var cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 35,
        "prediction_id": 0,
        "pro_prediction": "public static boolean canBeEqual(String s1, String s2) {\n    int[][] cnt1 = new int[2][26];\n    int[][] cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}",
        "main_fun_name": "canBeEqual",
        "raw_prediction": "```java\npublic boolean canBeEqual(String s1, String s2) {\n    int[][] cnt1 = new int[2][26];\n    int[][] cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}\n```",
        "sl_gold_code": "bool canBeEqual(string s1, string s2) {\n    int cnt1[2][26]{}, cnt2[2][26]{};\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0;\n}",
        "tl_gold_code": "public static boolean canBeEqual(String s1, String s2) {\n    var cnt1 = new int[2][26];\n    var cnt2 = new int[2][26];\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1.charAt(i) - 'a']++;\n        cnt2[i % 2][s2.charAt(i) - 'a']++;\n    }\n    return Arrays.deepEquals(cnt1, cnt2);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 36,
        "prediction_id": 0,
        "pro_prediction": "public static int furthestDistanceFromOrigin(String moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves.charAt(i) == 'L') {\n            ans--;\n        } else if (moves.charAt(i) == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return Math.abs(ans) + cn;\n}",
        "main_fun_name": "furthestDistanceFromOrigin",
        "raw_prediction": "```java\npublic int furthestDistanceFromOrigin(String moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves.charAt(i) == 'L') {\n            ans--;\n        } else if (moves.charAt(i) == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return Math.abs(ans) + cn;\n}\n```",
        "sl_gold_code": "int furthestDistanceFromOrigin(string moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves[i] == 'L') {\n            ans--;\n        } else if (moves[i] == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return abs(ans) + cn;\n}",
        "tl_gold_code": "public static int furthestDistanceFromOrigin(String moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves.charAt(i) == 'L') {\n            ans--;\n        } else if (moves.charAt(i) == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return Math.abs(ans) + cn;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 37,
        "prediction_id": 0,
        "pro_prediction": "public static int longestEqualSubarray(List<Integer> nums, int k) {\n    int n = nums.size(), ans = 0;\n    List<List<Integer>> pos = new ArrayList<>();\n    for (int i = 0; i <= n; i++) {\n        pos.add(new ArrayList<>());\n    }\n    for (int i = 0; i < n; i++) {\n        pos.get(nums.get(i)).add(i - pos.get(nums.get(i)).size());\n    }\n    for (List<Integer> ps : pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps.get(right) - ps.get(left) > k) {\n                left++;\n            }\n            ans = Math.max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "longestEqualSubarray",
        "raw_prediction": "```java\npublic int longestEqualSubarray(List<Integer> nums, int k) {\n    int n = nums.size(), ans = 0;\n    List<List<Integer>> pos = new ArrayList<>();\n    for (int i = 0; i <= n; i++) {\n        pos.add(new ArrayList<>());\n    }\n    for (int i = 0; i < n; i++) {\n        pos.get(nums.get(i)).add(i - pos.get(nums.get(i)).size());\n    }\n    for (List<Integer> ps : pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps.get(right) - ps.get(left) > k) {\n                left++;\n            }\n            ans = Math.max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int longestEqualSubarray(vector<int> &nums, int k) {\n    int n = nums.size(), ans = 0;\n    vector<vector<int>> pos(n + 1);\n    for (int i = 0; i < n; i++)\n        pos[nums[i]].push_back(i - pos[nums[i]].size());\n    for (auto &ps: pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps[right] - ps[left] > k) \n                left++;\n            ans = max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int longestEqualSubarray(List<Integer> nums, int k) {\n    int n = nums.size(), ans = 0;\n    List<Integer>[] pos = new ArrayList[n + 1];\n    Arrays.setAll(pos, e -> new ArrayList<>());\n    for (int i = 0; i < n; i++) {\n        int x = nums.get(i);\n        pos[x].add(i - pos[x].size());\n    }\n    for (var ps : pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps.get(right) - ps.get(left) > k) \n                left++;\n            ans = Math.max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 38,
        "prediction_id": 0,
        "pro_prediction": "public static boolean isAcronym(List<String> words, String s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words.get(i).charAt(0) != s.charAt(i))\n            return false;\n    return true;\n}",
        "main_fun_name": "isAcronym",
        "raw_prediction": "```java\npublic static boolean isAcronym(List<String> words, String s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words.get(i).charAt(0) != s.charAt(i))\n            return false;\n    return true;\n}\n```",
        "sl_gold_code": "bool isAcronym(vector<string> &words, string s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words[i][0] != s[i])\n            return false;\n    return true;\n}",
        "tl_gold_code": "public static boolean isAcronym(List<String> words, String s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words.get(i).charAt(0) != s.charAt(i))\n            return false;\n    return true;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 39,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumSum(int n, int k) {\n    int m = Math.min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}",
        "main_fun_name": "minimumSum",
        "raw_prediction": "```java\npublic static int minimumSum(int n, int k) {\n    int m = Math.min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}\n```",
        "sl_gold_code": "int minimumSum(int n, int k) {\n    int m = min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}",
        "tl_gold_code": "public static int minimumSum(int n, int k) {\n    int m = Math.min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 40,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumOperations(List<Integer> nums) {\n    List<Integer> g = new ArrayList<>();\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.add(x);\n        else g.set(j, x);\n    }\n    return nums.size() - g.size();\n}\n\npublic static int upperBound(List<Integer> g, int target) {\n    int left = -1;\n    int right = g.size();\n    while (left + 1 < right) {\n        int mid = left + (right - left) / 2;\n        if (g.get(mid) <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}",
        "main_fun_name": "minimumOperations",
        "raw_prediction": "```java\npublic int minimumOperations(List<Integer> nums) {\n    List<Integer> g = new ArrayList<>();\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.add(x);\n        else g.set(j, x);\n    }\n    return nums.size() - g.size();\n}\n\npublic int upperBound(List<Integer> g, int target) {\n    int left = -1;\n    int right = g.size();\n    while (left + 1 < right) {\n        int mid = left + (right - left) / 2;\n        if (g.get(mid) <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}\n```",
        "sl_gold_code": "int minimumOperations(vector<int>& nums) {\n    vector<int> g;\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.push_back(x);\n        else g[j] = x;\n    }\n    return nums.size() - g.size();\n}\nint upperBound(vector<int>& g, int target) {\n    int left = -1;\n    int right = g.size();\n    while (left + 1 < right) {\n        int mid = left + (right - left) / 2;\n        if (g[mid] <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}",
        "tl_gold_code": "public static int minimumOperations(List<Integer> nums) {\n    List<Integer> g = new ArrayList<>();\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.add(x);\n        else g.set(j, x);\n    }\n    return nums.size() - g.size();\n}\npublic static int upperBound(List<Integer> g, int target) {\n    int left = -1, right = g.size();\n    while (left + 1 < right) {\n        int mid = (left + right) >>> 1;\n        if (g.get(mid) <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 41,
        "prediction_id": 0,
        "pro_prediction": "public static int countPairs(List<Integer> nums, int target) {\n    Collections.sort(nums);\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums.get(left) + nums.get(right) < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "countPairs",
        "raw_prediction": "```java\npublic int countPairs(List<Integer> nums, int target) {\n    Collections.sort(nums);\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums.get(left) + nums.get(right) < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int countPairs(vector<int> &nums, int target) {\n    sort(nums.begin(), nums.end());\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums[left] + nums[right] < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int countPairs(List<Integer> nums, int target) {\n    Collections.sort(nums);\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums.get(left) + nums.get(right) < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 42,
        "prediction_id": 0,
        "pro_prediction": "public static int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE, n = nums.size();\n        TreeSet<Integer> s = new TreeSet<>(Arrays.asList(Integer.MIN_VALUE / 2, Integer.MAX_VALUE));\n        for (int i = x; i < n; i++) {\n            s.add(nums.get(i - x));\n            int y = nums.get(i);\n            Integer ceil = s.ceiling(y);\n            if (ceil == null) {\n                ceil = Integer.MAX_VALUE;\n            }\n            Integer floor = s.lower(y);\n            if (floor == null) {\n                floor = Integer.MIN_VALUE / 2;\n            }\n            ans = Math.min(ans, Math.min(ceil - y, y - floor));\n        }\n        return ans;\n    }",
        "main_fun_name": "minAbsoluteDifference",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int minAbsoluteDifference(List<Integer> nums, int x) {\n        int ans = Integer.MAX_VALUE, n = nums.size();\n        TreeSet<Integer> s = new TreeSet<>(Arrays.asList(Integer.MIN_VALUE / 2, Integer.MAX_VALUE));\n        for (int i = x; i < n; i++) {\n            s.add(nums.get(i - x));\n            int y = nums.get(i);\n            Integer ceil = s.ceiling(y);\n            if (ceil == null) {\n                ceil = Integer.MAX_VALUE;\n            }\n            Integer floor = s.lower(y);\n            if (floor == null) {\n                floor = Integer.MIN_VALUE / 2;\n            }\n            ans = Math.min(ans, Math.min(ceil - y, y - floor));\n        }\n        return ans;\n    }\n}\n```\nNote: In Java, we use `TreeSet` instead of `set` in C++ for maintaining sorted order of elements. Also, Java does not have an equivalent to `prev()` function in C++, so we use `lower()` function to get the element that is less than or equal to the given element in the `TreeSet`. If there is no such element, we assign the minimum possible value to it. Similarly, if `ceiling()` returns null, we assign the maximum possible value to it.",
        "sl_gold_code": "int minAbsoluteDifference(vector<int> &nums, int x) {\n    int ans = INT_MAX, n = nums.size();\n    set<int> s = {INT_MIN / 2, INT_MAX}; \n    for (int i = x; i < n; i++) {\n        s.insert(nums[i - x]);\n        int y = nums[i];\n        auto it = s.lower_bound(y); \n        ans = min(ans, min(*it - y, y - *prev(it))); \n    }\n    return ans;\n}",
        "tl_gold_code": "public static int minAbsoluteDifference(List<Integer> nums, int x) {\n    var a = nums.stream().mapToInt(i -> i).toArray();\n    int ans = Integer.MAX_VALUE, n = a.length;\n    var s = new TreeSet<Integer>();\n    s.add(Integer.MAX_VALUE); \n    s.add(Integer.MIN_VALUE / 2);\n    for (int i = x; i < n; i++) {\n        s.add(a[i - x]);\n        int y = a[i];\n        ans = Math.min(ans, Math.min(s.ceiling(y) - y, y - s.floor(y)));\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 43,
        "prediction_id": 0,
        "pro_prediction": "public static ListNode doubleIt(ListNode head) {\n    if (head.val > 4)\n        head = new ListNode(0, head);\n    for (ListNode cur = head; cur != null; cur = cur.next) {\n        cur.val = cur.val * 2 % 10;\n        if (cur.next != null && cur.next.val > 4)\n            cur.val++;\n    }\n    return head;\n}",
        "main_fun_name": "doubleIt",
        "raw_prediction": "```java\npublic ListNode doubleIt(ListNode head) {\n    if (head.val > 4)\n        head = new ListNode(0, head);\n    for (ListNode cur = head; cur != null; cur = cur.next) {\n        cur.val = cur.val * 2 % 10;\n        if (cur.next != null && cur.next.val > 4)\n            cur.val++;\n    }\n    return head;\n}\n```",
        "sl_gold_code": "ListNode *doubleIt(ListNode *head) {\n    if (head->val > 4)\n        head = new ListNode(0, head);\n    for (auto cur = head; cur; cur = cur->next) {\n        cur->val = cur->val * 2 % 10;\n        if (cur->next && cur->next->val > 4)\n            cur->val++;\n    }\n    return head;\n}",
        "tl_gold_code": "public static ListNode doubleIt(ListNode head) {\n    if (head.val > 4)\n        head = new ListNode(0, head);\n    for (var cur = head; cur != null; cur = cur.next) {\n        cur.val = cur.val * 2 % 10;\n        if (cur.next != null && cur.next.val > 4)\n            cur.val++;\n    }\n    return head;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 44,
        "prediction_id": 0,
        "pro_prediction": "public static int maxSum(int[] nums) {\n    int ans = -1;\n    int[] max_val = new int[10];\n    Arrays.fill(max_val, Integer.MIN_VALUE);\n    for (int v : nums) {\n        int max_d = 0;\n        for (int x = v; x > 0; x /= 10)\n            max_d = Math.max(max_d, x % 10);\n        ans = Math.max(ans, v + max_val[max_d]);\n        max_val[max_d] = Math.max(max_val[max_d], v);\n    }\n    return ans;\n}",
        "main_fun_name": "maxSum",
        "raw_prediction": "```java\npublic int maxSum(int[] nums) {\n    int ans = -1;\n    int[] max_val = new int[10];\n    Arrays.fill(max_val, Integer.MIN_VALUE);\n    for (int v : nums) {\n        int max_d = 0;\n        for (int x = v; x > 0; x /= 10)\n            max_d = Math.max(max_d, x % 10);\n        ans = Math.max(ans, v + max_val[max_d]);\n        max_val[max_d] = Math.max(max_val[max_d], v);\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int maxSum(vector<int> &nums) {\n    int ans = -1;\n    vector<int> max_val(10, INT_MIN);\n    for (int v: nums) {\n        int max_d = 0;\n        for (int x = v; x; x /= 10)\n            max_d = max(max_d, x % 10);\n        ans = max(ans, v + max_val[max_d]);\n        max_val[max_d] = max(max_val[max_d], v);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int maxSum(int[] nums) {\n    int ans = -1;\n    var maxVal = new int[10];\n    Arrays.fill(maxVal, Integer.MIN_VALUE);\n    for (int v : nums) {\n        int maxD = 0;\n        for (int x = v; x > 0; x /= 10)\n            maxD = Math.max(maxD, x % 10);\n        ans = Math.max(ans, v + maxVal[maxD]);\n        maxVal[maxD] = Math.max(maxVal[maxD], v);\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 45,
        "prediction_id": 0,
        "pro_prediction": "public static String finalString(String s) {\n        Deque<Character> q = new LinkedList<>();\n        boolean tail = true;\n        for (char c : s.toCharArray()) {\n            if (c == 'i') tail = !tail;\n            else if (tail) q.offerLast(c);\n            else q.offerFirst(c);\n        }\n        return tail ? String.valueOf(q) : new StringBuilder(q).reverse().toString();\n    }",
        "main_fun_name": "finalString",
        "raw_prediction": "```java\nimport java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Main {\n    public static String finalString(String s) {\n        Deque<Character> q = new LinkedList<>();\n        boolean tail = true;\n        for (char c : s.toCharArray()) {\n            if (c == 'i') tail = !tail;\n            else if (tail) q.offerLast(c);\n            else q.offerFirst(c);\n        }\n        return tail ? String.valueOf(q) : new StringBuilder(q).reverse().toString();\n    }\n}\n```",
        "sl_gold_code": "string finalString(string s) {\n    deque<char> q;\n    bool tail = true;\n    for (char c: s) {\n        if (c == 'i') tail = !tail;\n        else if (tail) q.push_back(c);\n        else q.push_front(c);\n    }\n    return tail ? string(q.begin(), q.end()) : string(q.rbegin(), q.rend());\n}",
        "tl_gold_code": "public static String finalString(String s) {\n    var q = new ArrayDeque<Character>();\n    var tail = true;\n    for (var c : s.toCharArray()) {\n        if (c == 'i') tail = !tail;\n        else if (tail) q.addLast(c);\n        else q.addFirst(c);\n    }\n    var ans = new StringBuilder();\n    for (var c : q) ans.append(c);\n    if (!tail) ans.reverse();\n    return ans.toString();\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 46,
        "prediction_id": 0,
        "pro_prediction": "public static boolean canSplitArray(List<Integer> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums.get(i - 1) + nums.get(i) >= m)\n            return true;\n    return false;\n}",
        "main_fun_name": "canSplitArray",
        "raw_prediction": "```java\npublic boolean canSplitArray(List<Integer> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums.get(i - 1) + nums.get(i) >= m)\n            return true;\n    return false;\n}\n```",
        "sl_gold_code": "bool canSplitArray(vector<int> &nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums[i - 1] + nums[i] >= m)\n            return true;\n    return false;\n}",
        "tl_gold_code": "public static boolean canSplitArray(List<Integer> nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums.get(i - 1) + nums.get(i) >= m)\n            return true;\n    return false;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 47,
        "prediction_id": 0,
        "pro_prediction": "public static int longestAlternatingSubarray(int[] a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.length;\n    while (i < n) {\n        if (a[i] % 2 != 0 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = Math.max(ans, i - i0);\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "longestAlternatingSubarray",
        "raw_prediction": "```java\npublic int longestAlternatingSubarray(int[] a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.length;\n    while (i < n) {\n        if (a[i] % 2 != 0 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = Math.max(ans, i - i0);\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int longestAlternatingSubarray(vector<int>& a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.size();\n    while (i < n) {\n        if (a[i] % 2 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = max(ans, i - i0);\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int longestAlternatingSubarray(int[] a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.length;\n    while (i < n) {\n        if (a[i] % 2 != 0 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = Math.max(ans, i - i0);\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 48,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumSeconds(List<Integer> nums) {\n        int n = nums.size();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        int ans = n;\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\n            List<Integer> v = entry.getValue();\n            v.add(v.get(0) + n);\n            int mx = -1;\n            for (int i = 1; i < v.size(); i++) {\n                mx = Math.max(mx, (v.get(i) - v.get(i - 1)) / 2);\n            }\n            ans = Math.min(ans, mx);\n        }\n        return ans;\n    }",
        "main_fun_name": "minimumSeconds",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int minimumSeconds(List<Integer> nums) {\n        int n = nums.size();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], new ArrayList<>());\n            }\n            map.get(nums[i]).add(i);\n        }\n        int ans = n;\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\n            List<Integer> v = entry.getValue();\n            v.add(v.get(0) + n);\n            int mx = -1;\n            for (int i = 1; i < v.size(); i++) {\n                mx = Math.max(mx, (v.get(i) - v.get(i - 1)) / 2);\n            }\n            ans = Math.min(ans, mx);\n        }\n        return ans;\n    }\n}\n```",
        "sl_gold_code": "int minimumSeconds(vector<int>& nums) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> umap;\n    for (int i = 0; i < n; i++) {\n        umap[nums[i]].push_back(i);\n    }\n    int ans = n;\n    for (auto &iter : umap) {\n        auto &v = iter.second;\n        v.push_back(v[0] + n);\n        int mx = - 1;\n        for (int i = 1; i < v.size(); i++) {\n            mx = max(mx, (v[i] - v[i - 1]) / 2);\n        }\n        ans = min(ans, mx);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int minimumSeconds(List<Integer> nums) {\n    int n = nums.size();\n    Map<Integer, List<Integer>> map = new HashMap<>(); \n    for(int i = 0; i < nums.size(); i++){\n        if(!map.containsKey(nums.get(i))) map.put(nums.get(i), new ArrayList<>());\n        map.get(nums.get(i)).add(i);\n    }\n    int ans = n / 2;\n    for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){\n        List<Integer> list = entry.getValue();\n        list.add(list.get(0) + n);\n        int mx = -1;\n        for(int j = 1; j < list.size(); j++){\n            mx = Math.max(mx, (list.get(j) - list.get(j-1)) / 2);\n        }\n        ans = Math.min(ans, mx);\n    }   \n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 49,
        "prediction_id": 0,
        "pro_prediction": "public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        ans += h >= target ? 1 : 0;\n    }\n    return ans;\n}",
        "main_fun_name": "numberOfEmployeesWhoMetTarget",
        "raw_prediction": "```java\npublic int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        ans += h >= target ? 1 : 0;\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int numberOfEmployeesWhoMetTarget(vector<int> &hours, int target) {\n    int ans = 0;\n    for (int h: hours) {\n        ans += h >= target;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n    int ans = 0;\n    for (int h : hours) {\n        if (h >= target) {\n            ans++;\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 50,
        "prediction_id": 0,
        "pro_prediction": "public static List<String> splitWordsBySeparator(List<String> words, char separator) {\n        List<String> ans = new ArrayList<>();\n        for (String str : words) {\n            String t = \"\";\n            for (char i : str.toCharArray()) {\n                if (i == ' ') continue;\n                if (i == separator) {\n                    if (t.length() > 0) ans.add(t);\n                    t = \"\";\n                } else {\n                    t += i;\n                }\n            }\n            if (t.length() > 0) ans.add(t);\n        }\n        return ans;\n    }",
        "main_fun_name": "splitWordsBySeparator",
        "raw_prediction": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<String> splitWordsBySeparator(List<String> words, char separator) {\n        List<String> ans = new ArrayList<>();\n        for (String str : words) {\n            String t = \"\";\n            for (char i : str.toCharArray()) {\n                if (i == ' ') continue;\n                if (i == separator) {\n                    if (t.length() > 0) ans.add(t);\n                    t = \"\";\n                } else {\n                    t += i;\n                }\n            }\n            if (t.length() > 0) ans.add(t);\n        }\n        return ans;\n    }\n}\n```",
        "sl_gold_code": "vector<string> splitWordsBySeparator(vector<string>& words, char separator) {\n    vector<string> ans; \n    function<void(string)> func = [&](string str){\n        string t=\"\";\n        for(char i:str){\n            if(i==' ')continue;\n            if(i==separator){\n                if(t.size())ans.push_back(t);\n                t=\"\";\n            }else t+=i;\n        }\n        if(t.size())ans.push_back(t);\n    };\n    for(auto i:words){\n        func(i);\n    }\n    return ans;\n}",
        "tl_gold_code": "public static List<String> splitWordsBySeparator(List<String> words, char separator) {\n    List<String> rs = new ArrayList<>();\n    StringBuffer sb = new StringBuffer();\n    for (String word : words) {\n        for (char c : word.toCharArray()) {\n            if (c == separator) {\n                if (sb.length() > 0) {\n                    rs.add(sb.toString());\n                    sb = new StringBuffer();\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n        if (sb.length() > 0) {\n            rs.add(sb.toString());\n            sb = new StringBuffer();\n        }\n    }\n    return rs;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 51,
        "prediction_id": 0,
        "pro_prediction": "public static List<Long> miniMaxSum(List<Integer> a) {\n    long sum = a.stream().mapToLong(Integer::longValue).sum();\n    int max = a.stream().max(Integer::compareTo).orElse(0);\n    int min = a.stream().min(Integer::compareTo).orElse(0);\n    return Arrays.asList(sum - max, sum - min);\n}",
        "main_fun_name": "miniMaxSum",
        "raw_prediction": "```java\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic List<Long> miniMaxSum(List<Integer> a) {\n    long sum = a.stream().mapToLong(Integer::longValue).sum();\n    int max = a.stream().max(Integer::compareTo).orElse(0);\n    int min = a.stream().min(Integer::compareTo).orElse(0);\n    return Arrays.asList(sum - max, sum - min);\n}\n```",
        "sl_gold_code": "vector<long> miniMaxSum(vector<int>& a) {\n    long long sum = std::accumulate(a.begin(), a.end(), 0LL);\n    int max = *std::max_element(a.begin(), a.end());\n    int min = *std::min_element(a.begin(), a.end());\n    return {sum - max, sum - min};\n}",
        "tl_gold_code": "public static List<Long> miniMaxSum(List<Integer> a) {\n    long sum = a.stream().mapToLong(Integer::longValue).sum(); \n    int max = Collections.max(a);\n    int min = Collections.min(a);\n    return Arrays.asList(sum - max, sum - min);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 52,
        "prediction_id": 0,
        "pro_prediction": "public static int pickingNumbers(List<Integer> a) {\n        Map<Integer, Integer> d = new HashMap<>();\n        for (int num : a) {\n            d.put(num, d.getOrDefault(num, 0) + 1);\n        }\n        int best = 0;\n        for (int i = 0; i < 99; ++i) {\n            best = Math.max(d.getOrDefault(i, 0) + d.getOrDefault(i + 1, 0), best);\n        }\n        return best;\n    }",
        "main_fun_name": "pickingNumbers",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int pickingNumbers(List<Integer> a) {\n        Map<Integer, Integer> d = new HashMap<>();\n        for (int num : a) {\n            d.put(num, d.getOrDefault(num, 0) + 1);\n        }\n        int best = 0;\n        for (int i = 0; i < 99; ++i) {\n            best = Math.max(d.getOrDefault(i, 0) + d.getOrDefault(i + 1, 0), best);\n        }\n        return best;\n    }\n}\n```",
        "sl_gold_code": "int pickingNumbers(const vector<int>& a) {\n    unordered_map<int, int> d;\n    for (int num : a) {\n        ++d[num];\n    }\n    int best = 0;\n    for (int i = 0; i < 99; ++i) {\n        best = max(d[i] + d[i + 1], best);\n    }\n    return best;\n}",
        "tl_gold_code": "public static  int pickingNumbers(List<Integer> a) {\n    HashMap<Integer, Integer> d = new HashMap<>();\n    for (int num : a) {\n        d.put(num, d.getOrDefault(num, 0) + 1);\n    }\n    int best = 0;\n    for (int i = 0; i < 99; ++i) {\n        best = Math.max(d.getOrDefault(i, 0) + d.getOrDefault(i + 1, 0), best);\n    }\n    return best;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 53,
        "prediction_id": 0,
        "pro_prediction": "public static int summingSeries(long n) {\n  return (int)(((n % 1000000007) * (n % 1000000007)) % 1000000007);\n}",
        "main_fun_name": "summingSeries",
        "raw_prediction": "```java\npublic static int summingSeries(long n) {\n  return (int)(((n % 1000000007) * (n % 1000000007)) % 1000000007);\n}\n```",
        "sl_gold_code": "int summingSeries(long n) {\n  return ((n % 1000000007)*(n % 1000000007)) % 1000000007;\n}",
        "tl_gold_code": "public static  int summingSeries(long n) {\n    return (int)((n % 1000000007) * (n % 1000000007) % 1000000007);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 54,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> matchingStrings(List<String> stringList, List<String> queries) {\n        List<Integer> arr = new ArrayList<>();\n        for (String i : queries) {\n            int k = 0;\n            for (String j : stringList) {\n                if (i.equals(j)) {\n                    k++;\n                }\n            }\n            arr.add(k);\n        }\n        return arr;\n    }",
        "main_fun_name": "matchingStrings",
        "raw_prediction": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<Integer> matchingStrings(List<String> stringList, List<String> queries) {\n        List<Integer> arr = new ArrayList<>();\n        for (String i : queries) {\n            int k = 0;\n            for (String j : stringList) {\n                if (i.equals(j)) {\n                    k++;\n                }\n            }\n            arr.add(k);\n        }\n        return arr;\n    }\n}\n```",
        "sl_gold_code": "vector<int> matchingStrings(const vector<string>& stringList, const vector<string>& queries) {\n    vector<int> arr;\n    for (const auto& i : queries) {\n        int k = 0;\n        for (const auto& j : stringList) {\n            if (i == j) {\n                ++k;\n            }\n        }\n        arr.push_back(k);\n    }\n    return arr;\n}",
        "tl_gold_code": "public static  List<Integer> matchingStrings(List<String> stringList, List<String> queries) {\n    List<Integer> arr = new ArrayList<>();\n    for (String i : queries) {\n        int k = 0;\n        for (String j : stringList) {\n            if (i.equals(j)) {\n                k++;\n            }\n        }\n        arr.add(k);\n    }\n    return arr;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 55,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) {\n        Set<Integer> rankSet = new HashSet<>(ranked);\n        List<Integer> rankNums = new ArrayList<>(rankSet);\n        rankNums.sort(Collections.reverseOrder());\n        List<Integer> result = new ArrayList<>();\n        for (int score : player) {\n            int rank = bsearch(rankNums, score);\n            result.add(rank);\n        }\n        return result;\n    }\n\npublic static int bsearch(List<Integer> arr, int x) {\n        int low = 0;\n        int high = arr.size() - 1;\n        int mid = 0;\n        while (low <= high) {\n            mid = low + (high - low) / 2;\n            if (arr.get(mid) < x) {\n                high = mid - 1;\n            } else if (arr.get(mid) > x) {\n                low = mid + 1;\n            } else {\n                return mid + 1;\n            }\n        }\n        return low + 1;\n    }",
        "main_fun_name": "climbingLeaderboard",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> ranked = Arrays.asList(100, 90, 85, 80);\n        List<Integer> player = Arrays.asList(80, 100, 105);\n        System.out.println(climbingLeaderboard(ranked, player));\n    }\n\n    public static int bsearch(List<Integer> arr, int x) {\n        int low = 0;\n        int high = arr.size() - 1;\n        int mid = 0;\n        while (low <= high) {\n            mid = low + (high - low) / 2;\n            if (arr.get(mid) < x) {\n                high = mid - 1;\n            } else if (arr.get(mid) > x) {\n                low = mid + 1;\n            } else {\n                return mid + 1;\n            }\n        }\n        return low + 1;\n    }\n\n    public static List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) {\n        Set<Integer> rankSet = new HashSet<>(ranked);\n        List<Integer> rankNums = new ArrayList<>(rankSet);\n        rankNums.sort(Collections.reverseOrder());\n        List<Integer> result = new ArrayList<>();\n        for (int score : player) {\n            int rank = bsearch(rankNums, score);\n            result.add(rank);\n        }\n        return result;\n    }\n}\n```",
        "sl_gold_code": "int bsearch(const vector<int>& arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0;\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n        if (arr[mid] < x) {\n            high = mid - 1;\n        } else if (arr[mid] > x) {\n            low = mid + 1;\n        } else {\n            return mid + 1;\n        }\n    }\n    return low + 1;\n}\nvector<int> climbingLeaderboard(vector<int>& ranked, const vector<int>& player) {\n    unordered_set<int> rank_set(ranked.begin(), ranked.end());\n    vector<int> rank_nums(rank_set.begin(), rank_set.end());\n    sort(rank_nums.begin(), rank_nums.end(), greater<int>());\n    vector<int> result;\n    for (int score : player) {\n        int rank = bsearch(rank_nums, score);\n        result.push_back(rank);\n    }\n    return result;\n}",
        "tl_gold_code": "public static  int bsearch(List<Integer> arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0;\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n        if (arr.get(mid) < x) {\n            high = mid - 1;\n        } else if (arr.get(mid) > x) {\n            low = mid + 1;\n        } else {\n            return mid + 1;\n        }\n    }\n    return low + 1;\n}\npublic static  List<Integer> climbingLeaderboard(List<Integer> ranked, List<Integer> player) {\n    LinkedHashSet<Integer> rankSet = new LinkedHashSet<>(ranked);\n    List<Integer> rankNums = new ArrayList<>(rankSet);\n    Collections.sort(rankNums, Collections.reverseOrder());\n    List<Integer> result = new ArrayList<>();\n    for (int score : player) {\n        int rank = bsearch(rankNums, score);\n        result.add(rank);\n    }\n    return result;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 56,
        "prediction_id": 0,
        "pro_prediction": "public static long arrayManipulation(int n, List<List<Integer>> queries) {\n    long[] arr = new long[n + 2];\n    long max = 0; long sum = 0;\n    for(List<Integer> query: queries){\n        arr[query.get(0)] += query.get(2);\n        arr[query.get(1) + 1] -= query.get(2);\n    }\n    for (long val : arr){\n        sum += val;\n        if(sum > max) max = sum;\n    }\n    return max;\n}",
        "main_fun_name": "arrayManipulation",
        "raw_prediction": "```java\npublic long arrayManipulation(int n, List<List<Integer>> queries) {\n    long[] arr = new long[n + 2];\n    long max = 0; long sum = 0;\n    for(List<Integer> query: queries){\n        arr[query.get(0)] += query.get(2);\n        arr[query.get(1) + 1] -= query.get(2);\n    }\n    for (long val : arr){\n        sum += val;\n        if(sum > max) max = sum;\n    }\n    return max;\n}\n```",
        "sl_gold_code": "long arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long> arr(n + 2, 0);\n    long max = 0; long sum = 0;\n    for(auto query: queries){\n        arr[query[0]] += query[2];\n        arr[query[1] + 1] -= query[2];\n    }\n    for (auto val : arr){\n        sum += val;\n        if(sum > max) max = sum;\n    }\n    return max;\n}",
        "tl_gold_code": "public static  long arrayManipulation(int n, List<List<Integer>> queries) {\n    long[] arr = new long[n + 2];\n    long max = 0;\n    long sum = 0;\n    \n    for (List<Integer> query : queries) {\n        arr[query.get(0)] += query.get(2);\n        arr[query.get(1) + 1] -= query.get(2);\n    }\n    \n    for (long val : arr) {\n        sum += val;\n        if (sum > max) max = sum;\n    }\n    return max;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 57,
        "prediction_id": 0,
        "pro_prediction": "public static ListNode deleteNode(ListNode llist, int position) {\n    if (llist == null) {\n        return null;\n    }\n    if (position == 0) {\n        ListNode newHead = llist.next;\n        llist = null; \n        return newHead;\n    }\n    ListNode current = llist;\n    for (int i = 0; current != null && i < position - 1; ++i) {\n        current = current.next;\n    }\n    if (current == null || current.next == null) {\n        return llist;\n    }\n    ListNode nodeToDelete = current.next;\n    current.next = current.next.next;\n    nodeToDelete = null; \n    return llist;\n}",
        "main_fun_name": "deleteNode",
        "raw_prediction": "```java\npublic ListNode deleteNode(ListNode llist, int position) {\n    if (llist == null) {\n        return null;\n    }\n    if (position == 0) {\n        ListNode newHead = llist.next;\n        llist = null; \n        return newHead;\n    }\n    ListNode current = llist;\n    for (int i = 0; current != null && i < position - 1; ++i) {\n        current = current.next;\n    }\n    if (current == null || current.next == null) {\n        return llist;\n    }\n    ListNode nodeToDelete = current.next;\n    current.next = current.next.next;\n    nodeToDelete = null; \n    return llist;\n}\n```",
        "sl_gold_code": "ListNode* deleteNode(ListNode* llist, int position) {\n    if (llist == nullptr) {\n        return nullptr;\n    }\n    if (position == 0) {\n        ListNode* newHead = llist->next;\n        delete llist; \n        return newHead;\n    }\n    ListNode* current = llist;\n    for (int i = 0; current != nullptr && i < position - 1; ++i) {\n        current = current->next;\n    }\n    if (current == nullptr || current->next == nullptr) {\n        return llist;\n    }\n    ListNode* nodeToDelete = current->next;\n    current->next = current->next->next;\n    delete nodeToDelete; \n    return llist;\n}",
        "tl_gold_code": "public static  ListNode deleteNode(ListNode llist, int position) {\n    if (llist == null) {\n        return null;\n    }\n    if (position == 0) {\n        return llist.next;\n    }\n    ListNode current = llist;\n    for (int i = 0; current != null && i < position - 1; i++) {\n        current = current.next;\n    }\n    if (current == null || current.next == null) {\n        return llist;\n    }\n    ListNode next = current.next.next;\n    current.next = next;\n    return llist;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 58,
        "prediction_id": 0,
        "pro_prediction": "public static boolean evaluateTree(TreeNode root) {\n    if (root.left == null) {\n        return root.val;\n    }\n    boolean l = evaluateTree(root.left);\n    boolean r = evaluateTree(root.right);\n    return root.val == 2 ? l || r : l && r;\n}",
        "main_fun_name": "evaluateTree",
        "raw_prediction": "```java\nboolean evaluateTree(TreeNode root) {\n    if (root.left == null) {\n        return root.val;\n    }\n    boolean l = evaluateTree(root.left);\n    boolean r = evaluateTree(root.right);\n    return root.val == 2 ? l || r : l && r;\n}\n```",
        "sl_gold_code": "bool evaluateTree(TreeNode* root) {\n    if (!root->left) {\n        return root->val;\n    }\n    bool l = evaluateTree(root->left);\n    bool r = evaluateTree(root->right);\n    return root->val == 2 ? l or r : l and r;\n}",
        "tl_gold_code": "public static boolean evaluateTree(TreeNode root) {\n    if (root.left == null) {\n        return root.val == 1;\n    }\n    boolean l = evaluateTree(root.left);\n    boolean r = evaluateTree(root.right);\n    return root.val == 2 ? l || r : l && r;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 59,
        "prediction_id": 0,
        "pro_prediction": "public static int andXorOr(List<Integer> a) {\n    int m = 0;\n    Stack<Integer> s = new Stack<>();\n    for (int i : a) {\n        while (!s.isEmpty() && s.peek() >= i) {\n            m = Math.max(m, i ^ s.pop());\n        }\n        if (!s.isEmpty()) {\n            m = Math.max(m, i ^ s.peek());\n        }\n        s.push(i);\n    }\n    return m;\n}",
        "main_fun_name": "andXorOr",
        "raw_prediction": "```java\npublic int andXorOr(List<Integer> a) {\n    int m = 0;\n    Stack<Integer> s = new Stack<>();\n    for (int i : a) {\n        while (!s.isEmpty() && s.peek() >= i) {\n            m = Math.max(m, i ^ s.pop());\n        }\n        if (!s.isEmpty()) {\n            m = Math.max(m, i ^ s.peek());\n        }\n        s.push(i);\n    }\n    return m;\n}\n```",
        "sl_gold_code": "int andXorOr(vector<int> &a) {\n    int m = 0;\n    stack<int> s;\n    for (int i : a) {\n        while (!s.empty() && s.top() >= i) {\n            m = max(m, i ^ s.top());\n            s.pop();\n        }\n        if (!s.empty()) {\n            m = max(m, i ^ s.top());\n        }\n        s.push(i);\n    }\n    return m;\n}",
        "tl_gold_code": "public static  int andXorOr(List<Integer> a) {\n    int m = 0;\n    Stack<Integer> s = new Stack<>();\n    for (int i : a) {\n        while (!s.isEmpty() && s.peek() >= i) {\n            m = Math.max(m, i ^ s.pop());\n        }\n        if (!s.isEmpty()) {\n            m = Math.max(m, i ^ s.peek());\n        }\n        s.push(i);\n    }\n    return m;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 60,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) {\n        Map<Integer, Integer> mp = new HashMap<>();\n        for (int i = 0; i < brr.size(); i++) mp.put(brr.get(i), mp.getOrDefault(brr.get(i), 0) + 1);\n        for (int i = 0; i < arr.size(); i++) mp.put(arr.get(i), mp.get(arr.get(i)) - 1);\n        \n        List<Integer> result = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\n            if (entry.getValue() > 0) result.add(entry.getKey());\n        }\n        \n        return result;\n    }",
        "main_fun_name": "missingNumbers",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) {\n        Map<Integer, Integer> mp = new HashMap<>();\n        for (int i = 0; i < brr.size(); i++) mp.put(brr.get(i), mp.getOrDefault(brr.get(i), 0) + 1);\n        for (int i = 0; i < arr.size(); i++) mp.put(arr.get(i), mp.get(arr.get(i)) - 1);\n        \n        List<Integer> result = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\n            if (entry.getValue() > 0) result.add(entry.getKey());\n        }\n        \n        return result;\n    }\n}\n```",
        "sl_gold_code": "vector<int> missingNumbers(vector<int> arr, vector<int> brr) {\n    map<int, int> mp;\n    for(int i = 0; i < brr.size(); i++) mp[brr[i]]++;\n    for(int i = 0; i < arr.size(); i++) mp[arr[i]]--;\n    map<int, int>::iterator it;\n    vector<int> result;\n    for(it = mp.begin(); it != mp.end(); it++)\n        if(it->second > 0) result.push_back(it->first);\n    \n    return result;\n}",
        "tl_gold_code": "public static  List<Integer> missingNumbers(List<Integer> arr, List<Integer> brr) {\n\tMap<Integer, Integer> mp = new HashMap<>();\n\tfor (int num : brr) mp.put(num, mp.getOrDefault(num, 0) + 1);\n\tfor (int num : arr) mp.put(num, mp.getOrDefault(num, 0) - 1);\n\t\n\tList<Integer> result = new ArrayList<>();\n\tfor (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\n\t\tif (entry.getValue() > 0) result.add(entry.getKey());\n\t}\n\t\n\treturn result;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 61,
        "prediction_id": 0,
        "pro_prediction": "public static long maximumSum(List<Long> a, long m) {\n        long max = 0, sum = 0;\n        Set<Long> s = new HashSet<>();\n        for (Long i : a) {\n            sum = (sum + i) % m;\n            if (sum > max) max = sum;\n            Long b = s.stream().filter(x -> x > sum).findFirst().orElse(null);\n            if (b != null) {\n                long possiblemax = (sum - b + m) % m;\n                if (possiblemax > max) max = possiblemax;\n            }\n            s.add(sum);\n        }\n        return max;\n    }",
        "main_fun_name": "maximumSum",
        "raw_prediction": "```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    public static long maximumSum(List<Long> a, long m) {\n        long max = 0, sum = 0;\n        Set<Long> s = new HashSet<>();\n        for (Long i : a) {\n            sum = (sum + i) % m;\n            if (sum > max) max = sum;\n            Long b = s.stream().filter(x -> x > sum).findFirst().orElse(null);\n            if (b != null) {\n                long possiblemax = (sum - b + m) % m;\n                if (possiblemax > max) max = possiblemax;\n            }\n            s.add(sum);\n        }\n        return max;\n    }\n}\n```\nNote: Java's `Set` interface does not have an `upper_bound` method like C++'s `set` container, so we use `stream()` and `filter()` to find the element in the set that is greater than the current sum. If no such element is found, `findFirst()` will return an empty optional, and `orElse(null)` will set `b` to `null`.",
        "sl_gold_code": "long maximumSum(vector<long> &a, long m) {\n    long long max=0, sum=0;\n    set<long long> s;\n    for (auto i=a.begin() ; i!=a.end() ; i++) {\n        sum=(sum+*i)%m;\n        if (sum>max) max=sum;\n        auto b=s.upper_bound(sum);\n        if (b!=s.end()) {\n            long long possiblemax=(sum-*b+m)%m;\n            if (possiblemax>max) max=possiblemax;\n        }\n        s.insert(sum);\n    }\n    return max;\n}",
        "tl_gold_code": "public static  long maximumSum(List<Long> a, long m) {\n    long maxSum = 0;\n    long currentSum = 0;\n    TreeSet<Long> s = new TreeSet<>();\n    for (long number : a) {\n        currentSum = (currentSum + number) % m;\n        maxSum = Math.max(maxSum, currentSum);\n        Long b = s.higher(currentSum);\n        if (b != null) {\n            long possibleMax = (currentSum - b + m) % m;\n            maxSum = Math.max(maxSum, possibleMax);\n        }\n        s.add(currentSum);\n    }\n    return maxSum;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 62,
        "prediction_id": 0,
        "pro_prediction": "public static int formingMagicSquare(List<List<Integer>> s) {\n    List<List<List<Integer>>> magicSquares = Arrays.asList(\n        Arrays.asList(Arrays.asList(8, 1, 6), Arrays.asList(3, 5, 7), Arrays.asList(4, 9, 2)),\n        Arrays.asList(Arrays.asList(6, 1, 8), Arrays.asList(7, 5, 3), Arrays.asList(2, 9, 4)),\n        Arrays.asList(Arrays.asList(4, 9, 2), Arrays.asList(3, 5, 7), Arrays.asList(8, 1, 6)),\n        Arrays.asList(Arrays.asList(2, 9, 4), Arrays.asList(7, 5, 3), Arrays.asList(6, 1, 8)),\n        Arrays.asList(Arrays.asList(8, 3, 4), Arrays.asList(1, 5, 9), Arrays.asList(6, 7, 2)),\n        Arrays.asList(Arrays.asList(4, 3, 8), Arrays.asList(9, 5, 1), Arrays.asList(2, 7, 6)),\n        Arrays.asList(Arrays.asList(6, 7, 2), Arrays.asList(1, 5, 9), Arrays.asList(8, 3, 4)),\n        Arrays.asList(Arrays.asList(2, 7, 6), Arrays.asList(9, 5, 1), Arrays.asList(4, 3, 8))\n    );\n    int minCost = 8 * 3;\n    for (List<List<Integer>> magicSquare : magicSquares) {\n        int cost = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                cost += Math.abs(s.get(i).get(j) - magicSquare.get(i).get(j));\n            }\n        }\n        minCost = Math.min(cost, minCost);\n    }\n    return minCost;\n}",
        "main_fun_name": "formingMagicSquare",
        "raw_prediction": "```java\npublic int formingMagicSquare(List<List<Integer>> s) {\n    List<List<List<Integer>>> magicSquares = Arrays.asList(\n        Arrays.asList(Arrays.asList(8, 1, 6), Arrays.asList(3, 5, 7), Arrays.asList(4, 9, 2)),\n        Arrays.asList(Arrays.asList(6, 1, 8), Arrays.asList(7, 5, 3), Arrays.asList(2, 9, 4)),\n        Arrays.asList(Arrays.asList(4, 9, 2), Arrays.asList(3, 5, 7), Arrays.asList(8, 1, 6)),\n        Arrays.asList(Arrays.asList(2, 9, 4), Arrays.asList(7, 5, 3), Arrays.asList(6, 1, 8)),\n        Arrays.asList(Arrays.asList(8, 3, 4), Arrays.asList(1, 5, 9), Arrays.asList(6, 7, 2)),\n        Arrays.asList(Arrays.asList(4, 3, 8), Arrays.asList(9, 5, 1), Arrays.asList(2, 7, 6)),\n        Arrays.asList(Arrays.asList(6, 7, 2), Arrays.asList(1, 5, 9), Arrays.asList(8, 3, 4)),\n        Arrays.asList(Arrays.asList(2, 7, 6), Arrays.asList(9, 5, 1), Arrays.asList(4, 3, 8))\n    );\n    int minCost = 8 * 3;\n    for (List<List<Integer>> magicSquare : magicSquares) {\n        int cost = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                cost += Math.abs(s.get(i).get(j) - magicSquare.get(i).get(j));\n            }\n        }\n        minCost = Math.min(cost, minCost);\n    }\n    return minCost;\n}\n```",
        "sl_gold_code": "int formingMagicSquare(vector<vector<int>>& s) {\n    vector<vector<vector<int>>> magicSquares = {\n        {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n        {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n        {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n        {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n        {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n        {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n        {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n        {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n    };\n    int minCost = 8 * 3;\n    for (const auto& magicSquare : magicSquares) {\n        int cost = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                cost += abs(s[i][j] - magicSquare[i][j]);\n            }\n        }\n        minCost = min(cost, minCost);\n    }\n    return minCost;\n}",
        "tl_gold_code": "public static  int formingMagicSquare(List<List<Integer>> sList) {\n\tint[][] s = sList.stream()\n\t\t\t\t\t  .map(l -> l.stream().mapToInt(Integer::intValue).toArray())\n\t\t\t\t\t  .toArray(int[][]::new);\n\tint[][][] magicSquares = {\n\t\t{{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n\t\t{{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n\t\t{{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n\t\t{{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n\t\t{{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n\t\t{{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n\t\t{{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n\t\t{{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n\t};\n\tint minCost = 8 * 3;\n\tfor (int[][] magicSquare : magicSquares) {\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tcost += Math.abs(s[i][j] - magicSquare[i][j]);\n\t\t\t}\n\t\t}\n\t\tminCost = Math.min(cost, minCost);\n\t}\n\treturn minCost;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 63,
        "prediction_id": 0,
        "pro_prediction": "public static String isFibo(long n) {\n    long start = 0;\n    long last = 1;\n    while (last <= n) {\n        long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}",
        "main_fun_name": "isFibo",
        "raw_prediction": "```java\npublic static String isFibo(long n) {\n    long start = 0;\n    long last = 1;\n    while (last <= n) {\n        long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}\n```",
        "sl_gold_code": "string isFibo(long long n) {\n    long long start = 0, last = 1;\n    while (last <= n) {\n        long long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}",
        "tl_gold_code": "public static  String isFibo(long n) {\n    long start = 0;\n    long last = 1;\n    while (last <= n) {\n        long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 64,
        "prediction_id": 0,
        "pro_prediction": "public static int solve(long l, long r) {\n        Set<Long> seen = new HashSet<>();\n        Deque<Long> q = new ArrayDeque<>();\n        for (int i = 0; i < 10; ++i) q.offer(i);\n        while (!q.isEmpty()) {\n            long u = q.peekLast();\n            q.pollLast();\n            if (String.valueOf(u).length() >= 20) continue;\n            if (seen.contains(u)) continue;\n            seen.add(u);\n            int length = String.valueOf(u).length();\n            for (int k = length; k < length + 5; ++k) {\n                if (String.valueOf(u * k).length() == k) {\n                    q.offer(u * k);\n                }\n            }\n        }\n        int count = 0;\n        for (Long s : seen) {\n            if (l <= s && s <= r) count++;\n        }\n        System.out.println(\"[\" + l + \", \" + r + \"]: \" + count);\n        return count;\n    }",
        "main_fun_name": "solve",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int solve(long l, long r) {\n        Set<Long> seen = new HashSet<>();\n        Deque<Long> q = new ArrayDeque<>();\n        for (int i = 0; i < 10; ++i) q.offer(i);\n        while (!q.isEmpty()) {\n            long u = q.peekLast();\n            q.pollLast();\n            if (String.valueOf(u).length() >= 20) continue;\n            if (seen.contains(u)) continue;\n            seen.add(u);\n            int length = String.valueOf(u).length();\n            for (int k = length; k < length + 5; ++k) {\n                if (String.valueOf(u * k).length() == k) {\n                    q.offer(u * k);\n                }\n            }\n        }\n        int count = 0;\n        for (Long s : seen) {\n            if (l <= s && s <= r) count++;\n        }\n        System.out.println(\"[\" + l + \", \" + r + \"]: \" + count);\n        return count;\n    }\n}\n```",
        "sl_gold_code": "int solve(long long l, long long r) {\n    set<long long> seen;\n    deque<long long> q;\n    for (int i = 0; i < 10; ++i) q.push_back(i);\n    while (!q.empty()) {\n        long long u = q.back();\n        q.pop_back();\n        if (to_string(u).length() >= 20) continue;\n        if (seen.find(u) != seen.end()) continue;\n        seen.insert(u);\n        int length = to_string(u).length();\n        for (int k = length; k < length + 5; ++k) {\n            if (to_string(u * k).length() == k) {\n                q.push_back(u * k);\n            }\n        }\n    }\n    int count = 0;\n    for (const auto &s : seen) {\n        if (l <= s && s <= r) count++;\n    }\n    cout << \"[\" << l << \", \" << r << \"]: \" << count << endl;\n    return count;\n}",
        "tl_gold_code": "public static  int solve(long l, long r) {\n\tSet<Long> seen = new HashSet<>();\n\tDeque<Long> q = new ArrayDeque<>();\n\tfor (int i = 0; i < 10; i++) q.addLast((long)i);\n\twhile (!q.isEmpty()) {\n\t\tlong u = q.removeLast();\n\t\tif (String.valueOf(u).length() >= 20) continue;\n\t\tif (seen.contains(u)) continue;\n\t\tseen.add(u);\n\t\tint length = String.valueOf(u).length();\n\t\tfor (int k = length; k < length + 5; k++) {\n\t\t\tif (String.valueOf(u * k).length() == k) {\n\t\t\t\tq.addLast(u * k);\n\t\t\t}\n\t\t}\n\t}\n\tint count = 0;\n\tfor (long s : seen) {\n\t\tif (l <= s && s <= r) count++;\n\t}\n\tSystem.out.println(\"[\" + l + \", \" + r + \"]: \" + count);\n\treturn count;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 65,
        "prediction_id": 0,
        "pro_prediction": "public static List<String> cavityMap(List<String> grid) {\n    for (int k = 1; k < grid.size() - 1; ++k) {\n        for (int j = 1; j < grid.get(k).length() - 1; ++j) {\n            if (grid.get(k).charAt(j - 1) < grid.get(k).charAt(j) && grid.get(k).charAt(j) > grid.get(k).charAt(j + 1) &&\n                grid.get(k + 1).charAt(j) < grid.get(k).charAt(j) && grid.get(k - 1).charAt(j) < grid.get(k).charAt(j)) {\n                grid.set(k, grid.get(k).substring(0, j) + \"X\" + grid.get(k).substring(j + 1));\n            }\n        }\n    }\n    return grid;\n}",
        "main_fun_name": "cavityMap",
        "raw_prediction": "```java\nimport java.util.List;\n\npublic List<String> cavityMap(List<String> grid) {\n    for (int k = 1; k < grid.size() - 1; ++k) {\n        for (int j = 1; j < grid.get(k).length() - 1; ++j) {\n            if (grid.get(k).charAt(j - 1) < grid.get(k).charAt(j) && grid.get(k).charAt(j) > grid.get(k).charAt(j + 1) &&\n                grid.get(k + 1).charAt(j) < grid.get(k).charAt(j) && grid.get(k - 1).charAt(j) < grid.get(k).charAt(j)) {\n                grid.set(k, grid.get(k).substring(0, j) + \"X\" + grid.get(k).substring(j + 1));\n            }\n        }\n    }\n    return grid;\n}\n```",
        "sl_gold_code": "vector<string> cavityMap(vector<string> grid) {\n    for (size_t k = 1; k < grid.size() - 1; ++k) {\n        for (size_t j = 1; j < grid[k].size() - 1; ++j) {\n            if (grid[k][j - 1] < grid[k][j] && grid[k][j] > grid[k][j + 1] &&\n                grid[k + 1][j] < grid[k][j] && grid[k - 1][j] < grid[k][j]) {\n                grid[k][j] = 'X';\n            }\n        }\n    }\n    return grid;\n}",
        "tl_gold_code": "public static  List<String> cavityMap(List<String> grid) {\n\tfor (int k = 1; k < grid.size() - 1; k++) {\n\t\tchar[] row = grid.get(k).toCharArray();\n\t\tString d = grid.get(k + 1);\n\t\tString u = grid.get(k - 1);\n\t\tfor (int j = 1; j < row.length - 1; j++) {\n\t\t\tchar left = row[j - 1];\n\t\t\tchar current = row[j];\n\t\t\tchar right = row[j + 1];\n\t\t\tchar down = d.charAt(j);\n\t\t\tchar up = u.charAt(j);\n\t\t\tif (left < current && current > right && down < current && up < current) {\n\t\t\t\trow[j] = 'X';\n\t\t\t}\n\t\t}\n\t\tgrid.set(k, new String(row));\n\t}\n\treturn grid;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 66,
        "prediction_id": 0,
        "pro_prediction": "public static long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = Math.min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}",
        "main_fun_name": "solve",
        "raw_prediction": "```java\npublic static long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = Math.min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}\n```",
        "sl_gold_code": "long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}",
        "tl_gold_code": "public static  long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = Math.min(((m-1)*n+(n-1)),((n-1)*m+(m-1)));\n    return m*n-1;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 67,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumLoss(List<Long> price) {\n        Map<Long, Integer> map = new HashMap<>();\n        for (int i = 0; i < price.size(); ++i) {\n            map.put(price.get(i), i);\n        }\n        Collections.sort(price);\n        long min = Integer.MAX_VALUE;\n        for (int i = 0; i < price.size() - 1; ++i) {\n            long currentMin = price.get(i + 1) - price.get(i);\n            if (currentMin < min && map.get(price.get(i)) > map.get(price.get(i + 1))) {\n                min = currentMin;\n            }\n        }\n        return (int) min;\n    }",
        "main_fun_name": "minimumLoss",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int minimumLoss(List<Long> price) {\n        Map<Long, Integer> map = new HashMap<>();\n        for (int i = 0; i < price.size(); ++i) {\n            map.put(price.get(i), i);\n        }\n        Collections.sort(price);\n        long min = Integer.MAX_VALUE;\n        for (int i = 0; i < price.size() - 1; ++i) {\n            long currentMin = price.get(i + 1) - price.get(i);\n            if (currentMin < min && map.get(price.get(i)) > map.get(price.get(i + 1))) {\n                min = currentMin;\n            }\n        }\n        return (int) min;\n    }\n}\n```",
        "sl_gold_code": "int minimumLoss(vector<long> price) {\n    unordered_map<long, int> map;\n    for (int i = 0; i < price.size(); ++i) {\n        map[price[i]] = i;\n    }\n    sort(price.begin(), price.end());\n    long min = numeric_limits<int>::max();\n    for (int i = 0; i < price.size() - 1; ++i) {\n        long currentMin = price[i + 1] - price[i];\n        if (currentMin < min && map[price[i]] > map[price[i + 1]]) min = currentMin;\n    }\n    return static_cast<int>(min);\n}",
        "tl_gold_code": "public static  int minimumLoss(List<Long> price) {\n    HashMap<Long, Integer> map = new HashMap<>();\n    for (int i = 0; i < price.size(); i++) {\n        map.put(price.get(i),i);\n    }\n    Collections.sort(price);\n    long min = Integer.MAX_VALUE;\n    for (int i = 0; i < price.size()-1; i++) {\n        long currentMin = price.get(i+1)-price.get(i);\n        if(currentMin < min && map.get(price.get(i))>map.get(price.get(i+1))) min = currentMin; \n    }\n    return (int)min;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 68,
        "prediction_id": 0,
        "pro_prediction": "public static String dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    boolean leap_year = true;\n    if ((year % 4 != 0) || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leap_year = false;\n    }\n    return leap_year ? \"12.09.\" + Integer.toString(year) : \"13.09.\" + Integer.toString(year);\n}",
        "main_fun_name": "dayOfProgrammer",
        "raw_prediction": "```java\npublic String dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    boolean leap_year = true;\n    if ((year % 4 != 0) || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leap_year = false;\n    }\n    return leap_year ? \"12.09.\" + Integer.toString(year) : \"13.09.\" + Integer.toString(year);\n}\n```",
        "sl_gold_code": "string dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    bool leap_year = true;\n    if ((year % 4 != 0) || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leap_year = false;\n    }\n    return leap_year ? \"12.09.\" + to_string(year) : \"13.09.\" + to_string(year);\n}",
        "tl_gold_code": "public static  String dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    boolean leapYear = true;\n    if (year % 4 != 0 || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leapYear = false;\n    }\n    return (leapYear ? \"12\" : \"13\") + \".09.\" + year;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 69,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> acmTeam(List<String> topic) {\n        int teamLen = topic.size();\n        int topicLen = topic.get(0).length();\n        int maxKnown = 0;\n        int maxTeams = 0;\n        for (int i = 0; i < teamLen; ++i) {\n            String t1 = topic.get(i);\n            for (int j = i + 1; j < teamLen; ++j) {\n                int know = 0;\n                String t2 = topic.get(j);\n                for (int k = 0; k < topicLen; ++k) {\n                    if (t1.charAt(k) == '1' || t2.charAt(k) == '1')\n                        ++know;\n                }\n                if (know == maxKnown)\n                    ++maxTeams;\n                else if (know > maxKnown) {\n                    maxKnown = know;\n                    maxTeams = 1;\n                }\n            }\n        }\n        List<Integer> result = new ArrayList<>();\n        result.add(maxKnown);\n        result.add(maxTeams);\n        return result;\n    }",
        "main_fun_name": "acmTeam",
        "raw_prediction": "```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static List<Integer> acmTeam(List<String> topic) {\n        int teamLen = topic.size();\n        int topicLen = topic.get(0).length();\n        int maxKnown = 0;\n        int maxTeams = 0;\n        for (int i = 0; i < teamLen; ++i) {\n            String t1 = topic.get(i);\n            for (int j = i + 1; j < teamLen; ++j) {\n                int know = 0;\n                String t2 = topic.get(j);\n                for (int k = 0; k < topicLen; ++k) {\n                    if (t1.charAt(k) == '1' || t2.charAt(k) == '1')\n                        ++know;\n                }\n                if (know == maxKnown)\n                    ++maxTeams;\n                else if (know > maxKnown) {\n                    maxKnown = know;\n                    maxTeams = 1;\n                }\n            }\n        }\n        List<Integer> result = new ArrayList<>();\n        result.add(maxKnown);\n        result.add(maxTeams);\n        return result;\n    }\n}\n```",
        "sl_gold_code": "vector<int> acmTeam(const vector<string>& topic) {\n    int teamLen = topic.size();\n    int topicLen = topic[0].size();\n    int maxKnown = 0;\n    int maxTeams = 0;\n    for (int i = 0; i < teamLen; ++i) {\n        const string& t1 = topic[i];\n        for (int j = i + 1; j < teamLen; ++j) {\n            int know = 0;\n            const string& t2 = topic[j];\n            for (int k = 0; k < topicLen; ++k) {\n                if (t1[k] == '1' || t2[k] == '1')\n                    ++know;\n            }\n            if (know == maxKnown)\n                ++maxTeams;\n            else if (know > maxKnown) {\n                maxKnown = know;\n                maxTeams = 1;\n            }\n        }\n    }\n    return {maxKnown, maxTeams};\n}",
        "tl_gold_code": "public static  List<Integer> acmTeam(List<String> topic) {\n\tint teamLen = topic.size();\n\tint topicLen = topic.get(0).length();\n\tint maxKnown = 0;\n\tint maxTeams = 0;\n\tfor (int i = 0; i < teamLen; i++) {\n\t\tString t1 = topic.get(i);\n\t\tfor (int j = i + 1; j < teamLen; j++) {\n\t\t\tint know = 0;\n\t\t\tString t2 = topic.get(j);\n\t\t\tfor (int k = 0; k < topicLen; k++) {\n\t\t\t\tif (t1.charAt(k) == '1' || t2.charAt(k) == '1')\n\t\t\t\t\tknow++;\n\t\t\t}\n\t\t\tif (know == maxKnown)\n\t\t\t\tmaxTeams++;\n\t\t\telse if (know > maxKnown) {\n\t\t\t\tmaxKnown = know;\n\t\t\t\tmaxTeams = 1;\n\t\t\t}\n\t\t}\n\t}\n\tList<Integer> result = new ArrayList<>();\n\tresult.add(maxKnown);\n\tresult.add(maxTeams);\n\treturn result;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 70,
        "prediction_id": 0,
        "pro_prediction": "public static String timeInWords(int h, int m) {\n    String[] hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                                 \"ten\", \"eleven\", \"twelve\"};\n    String[] minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                                    \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                                    \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                                    \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                                    \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[h % 12];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (m > 0 && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}",
        "main_fun_name": "timeInWords",
        "raw_prediction": "```java\npublic String timeInWords(int h, int m) {\n    String[] hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                                 \"ten\", \"eleven\", \"twelve\"};\n    String[] minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                                    \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                                    \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                                    \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                                    \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[h % 12];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (m > 0 && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}\n```",
        "sl_gold_code": "string timeInWords(int h, int m) {\n    vector<string> hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                                     \"ten\", \"eleven\", \"twelve\"};\n    vector<string> minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                                        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                                        \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                                        \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                                        \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[h % 12];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (m > 0 && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}",
        "tl_gold_code": "public static  String timeInWords(int h, int m){\n    String[] hour = {\"one\", \"two\", \"three\", \"four\",\n                     \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"};\n    String[] minutes = {\"one\", \"two\",\n                        \"three\", \"four\", \"five\",\n                        \"six\", \"seven\", \"eight\",\n                        \"nine\", \"ten\", \"eleven\",\n                        \"twelve\", \"thirteen\", \"fourteen\",\n                        \"fifteen\", \"sixteen\", \"seventeen\",\n                        \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"};\n    if (m == 0){\n        return hour[h - 1] + \" o' clock\";\n    }\n    else if (m == 15){\n        return \"quarter past \" + hour[h - 1];\n    }\n    else if (m == 30){\n        return \"half past \" + hour[h - 1];\n    }\n    else if (m == 45){\n        return \"quarter to \" + hour[h];\n    }\n    else if (m == 1){\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    }\n    else if (0 < m & m < 30){\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    }\n    else{\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h];\n    }\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 71,
        "prediction_id": 0,
        "pro_prediction": "public static int collectTheCoins(int[] coins, int[][] edges) {\n        int n = coins.length;\n        List<List<Integer>> g = new ArrayList<>();\n        int[] deg = new int[n];\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n            deg[x]++;\n            deg[y]++;\n        }\n        int leftEdges = n - 1;\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1 && coins[i] == 0) {\n                q.offerLast(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            leftEdges--;\n            int x = q.pollLast();\n            for (int y : g.get(x)) {\n                if (--deg[y] == 1 && coins[y] == 0) {\n                    q.offerLast(y);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1 && coins[i] != 0) {\n                q.offerLast(i);\n            }\n        }\n        leftEdges -= q.size();\n        for (int x : q) {\n            for (int y : g.get(x)) {\n                if (--deg[y] == 1) {\n                    leftEdges--;\n                }\n            }\n        }\n        return Math.max(leftEdges * 2, 0);\n    }",
        "main_fun_name": "collectTheCoins",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int collectTheCoins(int[] coins, int[][] edges) {\n        int n = coins.length;\n        List<List<Integer>> g = new ArrayList<>();\n        int[] deg = new int[n];\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n            deg[x]++;\n            deg[y]++;\n        }\n        int leftEdges = n - 1;\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1 && coins[i] == 0) {\n                q.offerLast(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            leftEdges--;\n            int x = q.pollLast();\n            for (int y : g.get(x)) {\n                if (--deg[y] == 1 && coins[y] == 0) {\n                    q.offerLast(y);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 1 && coins[i] != 0) {\n                q.offerLast(i);\n            }\n        }\n        leftEdges -= q.size();\n        for (int x : q) {\n            for (int y : g.get(x)) {\n                if (--deg[y] == 1) {\n                    leftEdges--;\n                }\n            }\n        }\n        return Math.max(leftEdges * 2, 0);\n    }\n}\n```",
        "sl_gold_code": "int collectTheCoins(vector<int> &coins, vector<vector<int>> &edges) {\n    int n = coins.size();\n    vector<vector<int>> g(n);\n    vector<int> deg(n);\n    for (auto &e: edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x); \n        deg[x]++;\n        deg[y]++; \n    }\n    int left_edges = n - 1; \n    vector<int> q;\n    for (int i = 0; i < n; i++)\n        if (deg[i] == 1 && coins[i] == 0) \n            q.push_back(i);\n    while (!q.empty()) {\n        left_edges--; \n        int x = q.back(); q.pop_back();\n        for (int y: g[x])\n            if (--deg[y] == 1 && coins[y] == 0) \n                q.push_back(y);\n    }\n    for (int i = 0; i < n; i++)\n        if (deg[i] == 1 && coins[i]) \n            q.push_back(i);\n    left_edges -= q.size(); \n    for (int x: q) \n        for (int y: g[x])\n            if (--deg[y] == 1) \n                left_edges--; \n    return max(left_edges * 2, 0);\n}",
        "tl_gold_code": "public static int collectTheCoins(int[] coins, int[][] edges) {\n    int n = coins.length;\n    List<Integer> g[] = new ArrayList[n];\n    Arrays.setAll(g, e -> new ArrayList<>());\n    var deg = new int[n];\n    for (var e : edges) {\n        int x = e[0], y = e[1];\n        g[x].add(y);\n        g[y].add(x); \n        deg[x]++;\n        deg[y]++; \n    }\n    int leftEdges = n - 1; \n    var q = new ArrayDeque<Integer>();\n    for (int i = 0; i < n; i++) {\n        if (deg[i] == 1 && coins[i] == 0) { \n            q.add(i);\n        }\n    }\n    while (!q.isEmpty()) {\n        leftEdges--; \n        for (int y : g[q.poll()]) {\n            if (--deg[y] == 1 && coins[y] == 0) { \n                q.add(y);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (deg[i] == 1 && coins[i] == 1) { \n            q.add(i);\n        }\n    }\n    leftEdges -= q.size(); \n    for (int x : q) { \n        for (int y : g[x]) {\n            if (--deg[y] == 1) { \n                leftEdges--; \n            }\n        }\n    }\n    return Math.max(leftEdges * 2, 0);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 72,
        "prediction_id": 0,
        "pro_prediction": "public static List<List<Integer>> matrixRotation(List<List<Integer>> matrix, int r) {\n        int l = 0;\n        int br = matrix.size();\n        int bc = matrix.get(0).size();\n        while (l < Math.min(br, bc) / 2) {\n            int rr = r % (2 * (br + bc - 4 * l - 2));\n            while (rr-- > 0) {\n                int buf = matrix.get(l).get(l);\n                for (int j = l; j < bc - l - 1; ++j) {\n                    matrix.get(l).set(j, matrix.get(l).get(j + 1));\n                }\n                for (int i = l; i < br - l - 1; ++i) {\n                    matrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1));\n                }\n                for (int j = bc - l - 1; j > l; --j) {\n                    matrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1));\n                }\n                for (int i = br - l - 1; i > l + 1; --i) {\n                    matrix.set(i, new ArrayList<>(matrix.get(i)));\n                    matrix.get(i).set(l, matrix.get(i - 1).get(l));\n                }\n                matrix.get(l + 1).set(l, buf);\n            }\n            ++l;\n        }\n        return matrix;\n    }",
        "main_fun_name": "matrixRotation",
        "raw_prediction": "```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static List<List<Integer>> matrixRotation(List<List<Integer>> matrix, int r) {\n        int l = 0;\n        int br = matrix.size();\n        int bc = matrix.get(0).size();\n        while (l < Math.min(br, bc) / 2) {\n            int rr = r % (2 * (br + bc - 4 * l - 2));\n            while (rr-- > 0) {\n                int buf = matrix.get(l).get(l);\n                for (int j = l; j < bc - l - 1; ++j) {\n                    matrix.get(l).set(j, matrix.get(l).get(j + 1));\n                }\n                for (int i = l; i < br - l - 1; ++i) {\n                    matrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1));\n                }\n                for (int j = bc - l - 1; j > l; --j) {\n                    matrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1));\n                }\n                for (int i = br - l - 1; i > l + 1; --i) {\n                    matrix.set(i, new ArrayList<>(matrix.get(i)));\n                    matrix.get(i).set(l, matrix.get(i - 1).get(l));\n                }\n                matrix.get(l + 1).set(l, buf);\n            }\n            ++l;\n        }\n        return matrix;\n    }\n}\n```",
        "sl_gold_code": "vector<vector<int>> matrixRotation(vector<vector<int>>& matrix, int r) {\n    int l = 0;\n    int br = matrix.size();\n    int bc = matrix[0].size();\n    while (l < min(br, bc) / 2) {\n        int rr = r % (2 * (br + bc - 4 * l - 2));\n        while (rr--) {\n            int buf = matrix[l][l];\n            for (int j = l; j < bc - l - 1; ++j) {\n                matrix[l][j] = matrix[l][j + 1];\n            }\n            for (int i = l; i < br - l - 1; ++i) {\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1];\n            }\n            for (int j = bc - l - 1; j > l; --j) {\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1];\n            }\n            for (int i = br - l - 1; i > l + 1; --i) {\n                matrix[i][l] = matrix[i - 1][l];\n            }\n            matrix[l + 1][l] = buf;\n        }\n        ++l;\n    }\n    return matrix;\n}",
        "tl_gold_code": "public static List<List<Integer>> matrixRotation(List<List<Integer>> matrix, int r) {\n\tint l = 0;\n\tint br = matrix.size();\n\tint bc = matrix.get(0).size();\n\twhile (l < Math.min(br, bc) / 2) {\n\t\tint rr = r % (2 * (br + bc - 4 * l - 2));\n\t\twhile (rr-- > 0) {\n\t\t\tint buf = matrix.get(l).get(l);\n\t\t\tfor (int j = l; j < bc - l - 1; ++j) {\n\t\t\t\tmatrix.get(l).set(j, matrix.get(l).get(j + 1));\n\t\t\t}\n\t\t\tfor (int i = l; i < br - l - 1; ++i) {\n\t\t\t\tmatrix.get(i).set(bc - l - 1, matrix.get(i + 1).get(bc - l - 1));\n\t\t\t}\n\t\t\tfor (int j = bc - l - 1; j > l; --j) {\n\t\t\t\tmatrix.get(br - l - 1).set(j, matrix.get(br - l - 1).get(j - 1));\n\t\t\t}\n\t\t\tfor (int i = br - l - 1; i > l + 1; --i) {\n\t\t\t\tmatrix.get(i).set(l, matrix.get(i - 1).get(l));\n\t\t\t}\n\t\t\tmatrix.get(l + 1).set(l, buf);\n\t\t}\n\t\t++l;\n\t}\n\treturn matrix;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 73,
        "prediction_id": 0,
        "pro_prediction": "public static int divisorSubstrings(int num, int k) {\n    String s = Integer.toString(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = Integer.parseInt(s.substring(i, i + k));\n        if (tmp != 0 && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}",
        "main_fun_name": "divisorSubstrings",
        "raw_prediction": "```java\npublic int divisorSubstrings(int num, int k) {\n    String s = Integer.toString(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = Integer.parseInt(s.substring(i, i + k));\n        if (tmp != 0 && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}\n```",
        "sl_gold_code": "int divisorSubstrings(int num, int k) {\n    string s = to_string(num);\n    int n = s.size();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = stoi(s.substr(i, k));\n        if (tmp && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}",
        "tl_gold_code": "public static  int divisorSubstrings(int num, int k) {\n    String s = Integer.toString(num);\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = Integer.parseInt(s.substring(i, i + k));\n        if (tmp != 0 && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 74,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> solve(List<Integer> a) {\n        List<Integer> result = new ArrayList<>();\n        List<Integer> cum = new ArrayList<>(a.size());\n        for (int i = 0; i < a.size(); i++) {\n            cum.add(0);\n        }\n        cum.set(0, a.get(0));\n        for (int i = 1; i < a.size(); i++) {\n            cum.set(i, cum.get(i - 1) + a.get(i));\n        }\n        int total = cum.get(cum.size() - 1);\n        for (int i = 0; i < cum.size(); i++) {\n            if (total % cum.get(i) == 0) {\n                int j = i + 1;\n                int segment_sum = 0;\n                while (j < a.size() && segment_sum < cum.get(i)) {\n                    segment_sum += a.get(j);\n                    if (segment_sum == cum.get(i)) {\n                        segment_sum = 0;\n                    }\n                    j++;\n                }\n                if (segment_sum == 0 && (j == a.size() || cum.get(i) == total)) {\n                    result.add(cum.get(i));\n                }\n            }\n        }\n        return result;\n    }",
        "main_fun_name": "solve",
        "raw_prediction": "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<Integer> solve(List<Integer> a) {\n        List<Integer> result = new ArrayList<>();\n        List<Integer> cum = new ArrayList<>(a.size());\n        for (int i = 0; i < a.size(); i++) {\n            cum.add(0);\n        }\n        cum.set(0, a.get(0));\n        for (int i = 1; i < a.size(); i++) {\n            cum.set(i, cum.get(i - 1) + a.get(i));\n        }\n        int total = cum.get(cum.size() - 1);\n        for (int i = 0; i < cum.size(); i++) {\n            if (total % cum.get(i) == 0) {\n                int j = i + 1;\n                int segment_sum = 0;\n                while (j < a.size() && segment_sum < cum.get(i)) {\n                    segment_sum += a.get(j);\n                    if (segment_sum == cum.get(i)) {\n                        segment_sum = 0;\n                    }\n                    j++;\n                }\n                if (segment_sum == 0 && (j == a.size() || cum.get(i) == total)) {\n                    result.add(cum.get(i));\n                }\n            }\n        }\n        return result;\n    }\n}\n```",
        "sl_gold_code": "vector<int> solve(const vector<int>& a) {\n    vector<int> result;\n    vector<int> cum(a.size(), 0);\n    cum[0] = a[0];\n    for (size_t i = 1; i < a.size(); i++) {\n        cum[i] = cum[i - 1] + a[i];\n    }\n    int total = cum.back();\n    for (size_t i = 0; i < cum.size(); i++) {\n        if (total % cum[i] == 0) {\n            size_t j = i + 1;\n            int segment_sum = 0;\n            while (j < a.size() && segment_sum < cum[i]) {\n                segment_sum += a[j];\n                if (segment_sum == cum[i]) {\n                    segment_sum = 0;\n                }\n                j++;\n            }\n            if (segment_sum == 0 && (j == a.size() || cum[i] == total)) {\n                result.push_back(cum[i]);\n            }\n        }\n    }\n    return result;\n}",
        "tl_gold_code": "public static  List<Integer> solve(List<Integer> a) {\n    List<Integer> result = new ArrayList<>();\n    int[] cum = new int[a.size()];\n    cum[0] = a.get(0);\n    for (int i = 1; i < a.size(); i++) {\n        cum[i] = cum[i-1] + a.get(i);\n    }\n    for (int i = 0; i < cum.length+1/2; i++) {\n        if(cum[cum.length-1]%cum[i] == 0) {\n            int temp = 0;\n            for (int j = i+1; j < cum.length; j++) {\n                temp += a.get(j);\n                if (temp > cum[i]) break;\n                if (temp%cum[i] == 0) temp = 0; \n            }\n            if (temp == 0) result.add(cum[i]);\n        }\n    }\n    return result;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 75,
        "prediction_id": 0,
        "pro_prediction": "public static int maximumToys(List<Integer> prices, int k) {\n    Collections.sort(prices);\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            ++toys;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}",
        "main_fun_name": "maximumToys",
        "raw_prediction": "```java\npublic int maximumToys(List<Integer> prices, int k) {\n    Collections.sort(prices);\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            ++toys;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}\n```",
        "sl_gold_code": "int maximumToys(vector<int>& prices, int k) {\n    sort(prices.begin(), prices.end());\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            ++toys;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}",
        "tl_gold_code": "public static  int maximumToys(List<Integer> prices, int k) {\n    Collections.sort(prices);\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            toys++;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 76,
        "prediction_id": 0,
        "pro_prediction": "public static int sumOfSquares(int[] nums) {\n    int ans = 0, n = nums.length;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}",
        "main_fun_name": "sumOfSquares",
        "raw_prediction": "```java\npublic int sumOfSquares(int[] nums) {\n    int ans = 0, n = nums.length;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int sumOfSquares(vector<int> &nums) {\n    int ans = 0, n = nums.size();\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int sumOfSquares(int[] nums) {\n    int ans = 0, n = nums.length;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 77,
        "prediction_id": 0,
        "pro_prediction": "public static boolean checkArray(int[] nums, int k) {\n    int n = nums.length, sum_d = 0;\n    int[] d = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        int x = nums[i];\n        x += sum_d;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sum_d -= x;\n        d[i + k] += x;\n    }\n    return true;\n}",
        "main_fun_name": "checkArray",
        "raw_prediction": "```java\npublic static boolean checkArray(int[] nums, int k) {\n    int n = nums.length, sum_d = 0;\n    int[] d = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        int x = nums[i];\n        x += sum_d;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sum_d -= x;\n        d[i + k] += x;\n    }\n    return true;\n}\n```",
        "sl_gold_code": "bool checkArray(vector<int> &nums, int k) {\n    int n = nums.size(), sum_d = 0;\n    vector<int> d(n + 1);\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        int x = nums[i];\n        x += sum_d;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sum_d -= x;\n        d[i + k] += x;\n    }\n    return true;\n}",
        "tl_gold_code": "public static boolean checkArray(int[] nums, int k) {\n    int n = nums.length, sumD = 0;\n    var d = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        sumD += d[i];\n        int x = nums[i];\n        x += sumD;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sumD -= x;\n        d[i + k] += x;\n    }\n    return true;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 78,
        "prediction_id": 0,
        "pro_prediction": "public static int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    if (n == 1) return 1;\n    int[][] dp = new int[n][2];\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n    }\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][1]+1);\n        ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}",
        "main_fun_name": "maxNonDecreasingLength",
        "raw_prediction": "```java\npublic int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    if (n == 1) return 1;\n    int[][] dp = new int[n][2];\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n    }\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][1]+1);\n        ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}\n```",
        "sl_gold_code": "int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size();\n    if (n == 1) return 1;\n    vector<vector<int>> dp(n, vector<int>(2, 1));\n    int ans = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][1]+1);\n        ans = max(ans, max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    if (n == 1) return 1;\n    int[][] dp = new int[n][2];\n    dp[0][0] = dp[0][1] = 1;\n    int ans = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = Math.max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = Math.max(dp[i][1], dp[i-1][1]+1);\n        ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 79,
        "prediction_id": 0,
        "pro_prediction": "public static int maximumJumps(int[] nums, int target) {\n    int[] dp = new int[nums.length];\n    dp[0] = 0;\n    for(int i = 1; i < nums.length; ++i) {\n        int res = Integer.MIN_VALUE;\n        for(int j = 0; j < i; ++j) {\n            if(Math.abs(nums[i] - nums[j]) <= target)\n                res = Math.max(res, dp[j] + 1);\n            dp[i] = res;\n        }\n    }\n    return dp[dp.length - 1] < 0 ? -1 : dp[dp.length - 1];\n}",
        "main_fun_name": "maximumJumps",
        "raw_prediction": "```java\npublic int maximumJumps(int[] nums, int target) {\n    int[] dp = new int[nums.length];\n    dp[0] = 0;\n    for(int i = 1; i < nums.length; ++i) {\n        int res = Integer.MIN_VALUE;\n        for(int j = 0; j < i; ++j) {\n            if(Math.abs(nums[i] - nums[j]) <= target)\n                res = Math.max(res, dp[j] + 1);\n            dp[i] = res;\n        }\n    }\n    return dp[dp.length - 1] < 0 ? -1 : dp[dp.length - 1];\n}\n```",
        "sl_gold_code": "int maximumJumps(vector<int>& nums, int target) {\n    vector<int> dp(nums.size());\n    dp[0] = 0;\n    for(int i = 1; i < nums.size(); ++i)\n    {\n        int res = INT_MIN;\n        for(int j = 0; j < i; ++j)\n        {\n            if(abs(nums[i] - nums[j]) <= target)\n                res = max(res, dp[j] + 1);\n            dp[i] = res;\n        }\n    }\n    return dp.back() < 0 ? -1 : dp.back();\n}",
        "tl_gold_code": "public static int maximumJumps(int[] nums, int target) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, -1);\n    dp[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (Math.abs(nums[i] - nums[j]) <= target && dp[j] != -1) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return dp[n - 1];\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 80,
        "prediction_id": 0,
        "pro_prediction": "public static int theMaximumAchievableX(int num, int t){\n    return num+t*2;\n}",
        "main_fun_name": "theMaximumAchievableX",
        "raw_prediction": "```java\npublic int theMaximumAchievableX(int num, int t){\n    return num+t*2;\n}\n```",
        "sl_gold_code": "int theMaximumAchievableX(int num, int t){\n    return num+t*2;\n}",
        "tl_gold_code": "public static int theMaximumAchievableX(int num, int t) {\n    return num + (t << 1);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 81,
        "prediction_id": 0,
        "pro_prediction": "public static long[] countBlackBlocks(int m, int n, int[][] coordinates) {\n        long[] ans = new long[5];\n        long sum = (long)(m-1) * (n-1);\n        Set<Long> st = new HashSet<>();\n        int num = coordinates.length;\n        for(int i = 0; i < num; i++)\n            st.insert((long)coordinates[i][0] * n + coordinates[i][1]);\n        int[][] arr = new int[4][3];\n        arr[0] = new int[]{0, -1, -1, 0};\n        arr[1] = new int[]{0, 1, -1, 0};\n        arr[2] = new int[]{0, -1, 1, -1};\n        arr[3] = new int[]{0, 1, 1, 1};\n        for(int i = 0; i < num; i++) {\n            long x = coordinates[i][0], y = coordinates[i][1];\n            for(int[] a : arr) {\n                int cnt = 1;\n                for(int j = 0; j < 2; j++) {\n                    int dx = a[j*2], dy = a[j*2+1];\n                    long nx = x + dx, ny = y + dy;\n                    if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                        cnt = 0;\n                        break;\n                    }\n                    if(st.contains(nx * n + ny)) cnt++;\n                }\n                ans[cnt]++;\n            }            \n        }\n        for(int i = 2; i <= 4; i++) ans[i] /= i;\n        ans[0] = sum - ans[1] - ans[2] - ans[3] - ans[4];\n        return ans;\n    }",
        "main_fun_name": "countBlackBlocks",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static long[] countBlackBlocks(int m, int n, int[][] coordinates) {\n        long[] ans = new long[5];\n        long sum = (long)(m-1) * (n-1);\n        Set<Long> st = new HashSet<>();\n        int num = coordinates.length;\n        for(int i = 0; i < num; i++)\n            st.insert((long)coordinates[i][0] * n + coordinates[i][1]);\n        int[][] arr = new int[4][3];\n        arr[0] = new int[]{0, -1, -1, 0};\n        arr[1] = new int[]{0, 1, -1, 0};\n        arr[2] = new int[]{0, -1, 1, -1};\n        arr[3] = new int[]{0, 1, 1, 1};\n        for(int i = 0; i < num; i++) {\n            long x = coordinates[i][0], y = coordinates[i][1];\n            for(int[] a : arr) {\n                int cnt = 1;\n                for(int j = 0; j < 2; j++) {\n                    int dx = a[j*2], dy = a[j*2+1];\n                    long nx = x + dx, ny = y + dy;\n                    if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                        cnt = 0;\n                        break;\n                    }\n                    if(st.contains(nx * n + ny)) cnt++;\n                }\n                ans[cnt]++;\n            }            \n        }\n        for(int i = 2; i <= 4; i++) ans[i] /= i;\n        ans[0] = sum - ans[1] - ans[2] - ans[3] - ans[4];\n        return ans;\n    }\n}\n```",
        "sl_gold_code": "vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& coordinates) {\n    vector<long long> ans(5);\n    long long sum = (long long)(m-1) * (n-1);\n    unordered_set<long long> st;\n    int num = coordinates.size();\n    for(int i = 0; i < num; i++)\n        st.insert((long long)coordinates[i][0] * n + coordinates[i][1]);\n    vector<vector<pair<int, int>>> arr(4);\n    arr[0] = {{0, -1}, {-1, -1}, {-1, 0}};\n    arr[1] = {{0, 1}, {-1, 0}, {-1, 1}};\n    arr[2] = {{0, -1}, {1, 0}, {1, -1}};\n    arr[3] = {{0, 1}, {1, 0}, {1, 1}};\n    for(int i = 0; i < num; i++) {\n        long long x = coordinates[i][0], y = coordinates[i][1];\n        for(auto &a : arr) {\n            int cnt = 1;\n            for(auto& [dx, dy] : a) {\n                long long nx = x + dx, ny = y + dy;\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if(st.count(nx * n + ny)) cnt++;\n            }\n            ans[cnt]++;\n        }            \n    }\n    for(int i = 2; i <= 4; i++) ans[i] /= i;\n    ans[0] = sum - ans[1] - ans[2] - ans[3] - ans[4];\n    return ans;\n}",
        "tl_gold_code": "public static long[] countBlackBlocks(int m, int n, int[][] coordinates) {\n    List<Long> ansList = new ArrayList<>(Collections.nCopies(5, 0L));\n    long sum = (long) (m - 1) * (n - 1);\n    Set<Long> st = new HashSet<>();\n    int num = coordinates.length;\n    for (int i = 0; i < num; i++)\n        st.add((long) coordinates[i][0] * n + coordinates[i][1]);\n    int[][][] arr = {\n        {{0, -1}, {-1, -1}, {-1, 0}},\n        {{0, 1}, {-1, 0}, {-1, 1}},\n        {{0, -1}, {1, 0}, {1, -1}},\n        {{0, 1}, {1, 0}, {1, 1}}\n    };\n    for (int i = 0; i < num; i++) {\n        long x = coordinates[i][0], y = coordinates[i][1];\n        for (int[][] a : arr) {\n            int cnt = 1;\n            for (int[] direction : a) {\n                long nx = x + direction[0], ny = y + direction[1];\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if (st.contains(nx * n + ny)) cnt++;\n            }\n            ansList.set(cnt, ansList.get(cnt) + 1);\n        }\n    }\n    for (int i = 2; i <= 4; i++) ansList.set(i, ansList.get(i) / i);\n    ansList.set(0, sum - ansList.get(1) - ansList.get(2) - ansList.get(3) - ansList.get(4));\n    long[] ans = ansList.stream().mapToLong(Long::longValue).toArray();\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 82,
        "prediction_id": 0,
        "pro_prediction": "public static int minimumBeautifulSubstrings(String s) {\n        if (s.charAt(0) == '0') return -1;\n        Map<String, Integer> s1 = new HashMap<>();\n        int n = s.length();\n        s1.put(\"1\", 1);\n        s1.put(\"101\", 1);\n        s1.put(\"11001\", 1);\n        s1.put(\"1111101\", 1);\n        s1.put(\"1001110001\", 1);\n        s1.put(\"110000110101\", 1);\n        s1.put(\"11110100001001\", 1);\n        String s2 = \"\";\n        int[] f = new int[n + 10];\n        Arrays.fill(f, 1000000000);\n        f[0] = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                s2 = \"\";\n                for (int k = i; k <= j; k++) {\n                    s2 += s.charAt(k);\n                }\n                if (s1.containsKey(s2)) {\n                    f[j + 1] = Math.min(f[j + 1], f[i] + 1);\n                }\n            }\n        }\n        if (f[n] == 1000000000) return -1;\n        return f[n];\n    }",
        "main_fun_name": "minimumBeautifulSubstrings",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int minimumBeautifulSubstrings(String s) {\n        if (s.charAt(0) == '0') return -1;\n        Map<String, Integer> s1 = new HashMap<>();\n        int n = s.length();\n        s1.put(\"1\", 1);\n        s1.put(\"101\", 1);\n        s1.put(\"11001\", 1);\n        s1.put(\"1111101\", 1);\n        s1.put(\"1001110001\", 1);\n        s1.put(\"110000110101\", 1);\n        s1.put(\"11110100001001\", 1);\n        String s2 = \"\";\n        int[] f = new int[n + 10];\n        Arrays.fill(f, 1000000000);\n        f[0] = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                s2 = \"\";\n                for (int k = i; k <= j; k++) {\n                    s2 += s.charAt(k);\n                }\n                if (s1.containsKey(s2)) {\n                    f[j + 1] = Math.min(f[j + 1], f[i] + 1);\n                }\n            }\n        }\n        if (f[n] == 1000000000) return -1;\n        return f[n];\n    }\n}\n```",
        "sl_gold_code": "int minimumBeautifulSubstrings(string s) {\n    if(s[0]==0) return -1;\n    unordered_map<string,int>s1;\n    int n = s.size();\n    s1[\"1\"]++;\n    s1[\"101\"]++;\n    s1[\"11001\"]++;\n    s1[\"1111101\"]++;\n    s1[\"1001110001\"]++;\n    s1[\"110000110101\"]++;\n    s1[\"11110100001001\"]++;\n    string s2=\"\";\n    vector<int>f(n+10,1e9);\n    f[0]=0;\n    for(int i =0;i<n;i++)\n        for(int j =i;j<n;j++)\n        {\n            s2=\"\";\n            for(int k=i;k<=j;k++)\n                s2+=s[k];\n            if(s1.find(s2)!=s1.end()) f[j+1]=min(f[j+1],f[i]+1);\n        }\n    if(f[n]==1e9) return -1;\n    return f[n];\n}",
        "tl_gold_code": "public static  int minimumBeautifulSubstrings(String s) {\n    final String[] fivePowersBinary = {\n        \"1\", \"101\", \"11001\", \"1111101\",\n        \"1001110001\", \"110000110101\", \"11110100001001\"\n    };\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[n] = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i] = 16;\n        if (s.charAt(i) == '0') continue;\n        for (String bin : fivePowersBinary) {\n            if (i + bin.length() > n) break;\n            if (s.substring(i, i + bin.length()).equals(bin)) {\n                dp[i] = Math.min(dp[i], dp[i + bin.length()] + 1);\n            }\n        }\n    }\n    return dp[0] > n ? -1 : dp[0];\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 83,
        "prediction_id": 0,
        "pro_prediction": "public static int gcdAndLcm(int x, int y) {\n        int n = x * y;\n        int ans = 0;\n        for (int i = x; i <= y; ++i) {\n            if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n\npublic static int gcd(int x, int y) {\n        if (x < y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        while (y != 0) {\n            int r = x % y;\n            x = y;\n            y = r;\n        }\n        return x;\n    }\n\npublic static int lcm(int x, int y) {\n        return x / gcd(x, y) * y;\n    }",
        "main_fun_name": "gcdAndLcm",
        "raw_prediction": "```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(gcdAndLcm(10, 20));\n    }\n\n    public static int gcdAndLcm(int x, int y) {\n        int n = x * y;\n        int ans = 0;\n        for (int i = x; i <= y; ++i) {\n            if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n\n    public static int gcd(int x, int y) {\n        if (x < y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n        while (y != 0) {\n            int r = x % y;\n            x = y;\n            y = r;\n        }\n        return x;\n    }\n\n    public static int lcm(int x, int y) {\n        return x / gcd(x, y) * y;\n    }\n}\n```",
        "sl_gold_code": "int gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; ++i) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans++;\n        }\n    }\n    return ans;\n}\nint gcd(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    while (y != 0) {\n        int r = x % y;\n        x = y;\n        y = r;\n    }\n    return x;\n}\nint lcm(int x, int y) {\n    return x / gcd(x, y) * y;\n}",
        "tl_gold_code": "public static int gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; i++) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans++;\n        }\n    }\n    return ans;\n}\npublic static int gcd(int x, int y) {\n    if (x < y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n    int r = x % y;\n    while (r != 0) {\n        x = y;\n        y = r;\n        r = x % y;\n    }\n    return y;\n}\npublic static int lcm(int x, int y) {\n    if (x < y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n    int m = x;\n    while (x % y != 0) {\n        x += m;\n    }\n    return x;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 84,
        "prediction_id": 0,
        "pro_prediction": "public static int findFirstPairExceedingSum(List<List<Integer>> pairs) {\n    int maxSum = 0;\n    int dayIndex = 0;\n    for (int i = 0; i < pairs.size(); ++i) {\n        int a = pairs.get(i).get(0);\n        int b = pairs.get(i).get(1);\n        int sum = a + b;\n        if (sum > 8 && sum > maxSum) {\n            maxSum = sum;\n            dayIndex = i + 1;\n        }\n    }\n    return dayIndex;\n}",
        "main_fun_name": "findFirstPairExceedingSum",
        "raw_prediction": "```java\npublic int findFirstPairExceedingSum(List<List<Integer>> pairs) {\n    int maxSum = 0;\n    int dayIndex = 0;\n    for (int i = 0; i < pairs.size(); ++i) {\n        int a = pairs.get(i).get(0);\n        int b = pairs.get(i).get(1);\n        int sum = a + b;\n        if (sum > 8 && sum > maxSum) {\n            maxSum = sum;\n            dayIndex = i + 1;\n        }\n    }\n    return dayIndex;\n}\n```",
        "sl_gold_code": "int findFirstPairExceedingSum(vector<vector<int>>& pairs) {\n      int maxSum = 0;\n      int dayIndex = 0;\n      for (int i = 0; i < pairs.size(); ++i) {\n          int a = pairs[i][0];\n          int b = pairs[i][1];\n          int sum = a + b;\n          if (sum > 8 && sum > maxSum) {\n              maxSum = sum;\n              dayIndex = i + 1;\n          }\n      }\n      return dayIndex;\n  }",
        "tl_gold_code": "public static int findFirstPairExceedingSum(List<List<Integer>> pairs) {\n\tint maxSum = 0;\n\tint dayIndex = 0;\n\tfor (int i = 0; i < pairs.size(); i++) {\n\t\tList<Integer> pair = pairs.get(i);\n\t\tint a = pair.get(0);\n\t\tint b = pair.get(1);\n\t\tint sum = a + b;\n\t\tif (sum > 8 && sum > maxSum) {\n\t\t\tmaxSum = sum;\n\t\t\tdayIndex = i + 1;\n\t\t}\n\t}\n\treturn dayIndex;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 85,
        "prediction_id": 0,
        "pro_prediction": "public static int maximumValue(String[] strs) {\n    int res = 0;\n    for (String s : strs) {\n        boolean isDigits = true;\n        for (char c : s.toCharArray()) {\n            isDigits &= Character.isDigit(c);\n        }\n        res = Math.max(res, isDigits ? Integer.parseInt(s) : s.length());\n    }\n    return res;\n}",
        "main_fun_name": "maximumValue",
        "raw_prediction": "```java\npublic int maximumValue(String[] strs) {\n    int res = 0;\n    for (String s : strs) {\n        boolean isDigits = true;\n        for (char c : s.toCharArray()) {\n            isDigits &= Character.isDigit(c);\n        }\n        res = Math.max(res, isDigits ? Integer.parseInt(s) : s.length());\n    }\n    return res;\n}\n```",
        "sl_gold_code": "int maximumValue(vector<string>& strs) {\n    int res = 0;\n    for (auto& s : strs) {\n        bool isDigits = true;\n        for (char& c : s) {\n            isDigits &= isdigit(c);\n        }\n        res = max(res, isDigits ? stoi(s) : (int)s.size());\n    }\n    return res;\n}",
        "tl_gold_code": "public static int maximumValue(String[] strs) {\n    int res = 0;\n    for (String s : strs) {\n        boolean isDigits = true;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            isDigits &= Character.isDigit(s.charAt(i));\n        }\n        res = Math.max(res, isDigits ? Integer.parseInt(s) : n);\n    }\n    return res;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 86,
        "prediction_id": 0,
        "pro_prediction": "public static int countBeautifulPairs(int[] nums) {\n    int ans = 0;\n    int[] cnt = new int[10];\n    for (int x : nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] > 0 && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}\n\npublic static int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}",
        "main_fun_name": "countBeautifulPairs",
        "raw_prediction": "```java\npublic int countBeautifulPairs(int[] nums) {\n    int ans = 0;\n    int[] cnt = new int[10];\n    for (int x : nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] > 0 && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}\n\n// gcd function implementation\nprivate int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n```\nNote: The `gcd` function (greatest common divisor) is used in the original C++ code but not provided in the snippet. I have included a basic implementation of the `gcd` function in the Java translation.",
        "sl_gold_code": "int countBeautifulPairs(vector<int> &nums) {\n    int ans = 0, cnt[10]{};\n    for (int x: nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int countBeautifulPairs(int[] nums) {\n    int ans = 0;\n    var cnt = new int[10];\n    for (int x : nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] > 0 && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}\nprivate static int gcd(int a, int b) {\n    while (a != 0) {\n        int tmp = a;\n        a = b % a;\n        b = tmp;\n    }\n    return b;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 87,
        "prediction_id": 0,
        "pro_prediction": "public static int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        int nq = queries.length;\n        Integer[] id = new Integer[nq];\n        int[] cnt = new int[n + 1];\n        Arrays.fill(cnt, 0);\n        for (int i = 0; i < nq; i++) {\n            id[i] = i;\n        }\n        Arrays.sort(id, (i, j) -> queries[i] - queries[j]);\n        Arrays.sort(logs, (a, b) -> a[1] - b[1]);\n        int[] ans = new int[nq];\n        int outOfRange = n;\n        int left = 0, right = 0;\n        for (int i : id) {\n            while (right < logs.length && logs[right][1] <= queries[i]) {\n                if (++cnt[logs[right][0]] == 1) {\n                    outOfRange--;\n                }\n                right++;\n            }\n            while (left < logs.length && logs[left][1] < queries[i] - x) {\n                if (--cnt[logs[left][0]] == 0) {\n                    outOfRange++;\n                }\n                left++;\n            }\n            ans[i] = outOfRange;\n        }\n        return ans;\n    }",
        "main_fun_name": "countServers",
        "raw_prediction": "Here's the Java translation of the provided C++ code:\n\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        int nq = queries.length;\n        Integer[] id = new Integer[nq];\n        int[] cnt = new int[n + 1];\n        Arrays.fill(cnt, 0);\n        for (int i = 0; i < nq; i++) {\n            id[i] = i;\n        }\n        Arrays.sort(id, (i, j) -> queries[i] - queries[j]);\n        Arrays.sort(logs, (a, b) -> a[1] - b[1]);\n        int[] ans = new int[nq];\n        int outOfRange = n;\n        int left = 0, right = 0;\n        for (int i : id) {\n            while (right < logs.length && logs[right][1] <= queries[i]) {\n                if (++cnt[logs[right][0]] == 1) {\n                    outOfRange--;\n                }\n                right++;\n            }\n            while (left < logs.length && logs[left][1] < queries[i] - x) {\n                if (--cnt[logs[left][0]] == 0) {\n                    outOfRange++;\n                }\n                left++;\n            }\n            ans[i] = outOfRange;\n        }\n        return ans;\n    }\n}\n```\nNote: The Java code uses Integer array for `id` instead of int array because Java's lambda expressions with primitive arrays can be cumbersome. The rest of the code closely follows the logic in the original C++ code.",
        "sl_gold_code": "vector<int> countServers(int n, vector<vector<int>> &logs, int x, vector<int> &queries) {\n    int nq = queries.size(), id[nq], cnt[n + 1];\n    memset(cnt, 0, sizeof(cnt));\n    iota(id, id + nq, 0);\n    sort(id, id + nq, [&](int i, int j) {\n        return queries[i] < queries[j];\n    });\n    sort(logs.begin(), logs.end(), [](const auto &a, const auto &b) {\n        return a[1] < b[1];\n    });\n    vector<int> ans(nq);\n    int out_of_range = n, left = 0, right = 0;\n    for (int i: id) {\n        while (right < logs.size() && logs[right][1] <= queries[i])\n            if (cnt[logs[right++][0]]++ == 0)\n                out_of_range--;\n        while (left < logs.size() && logs[left][1] < queries[i] - x)\n            if (--cnt[logs[left++][0]] == 0)\n                out_of_range++;\n        ans[i] = out_of_range;\n    }\n    return ans;\n}",
        "tl_gold_code": "public static int[] countServers(int n, int[][] logs, int x, int[] queries) {\n    int nq = queries.length;\n    var id = new Integer[nq];\n    for (int i = 0; i < nq; i++) id[i] = i;\n    Arrays.sort(id, (i, j) -> queries[i] - queries[j]);\n    Arrays.sort(logs, (a, b) -> a[1] - b[1]);\n    int[] ans = new int[nq], cnt = new int[n + 1];\n    int outOfRange = n, left = 0, right = 0;\n    for (int i : id) {\n        while (right < logs.length && logs[right][1] <= queries[i])\n            if (cnt[logs[right++][0]]++ == 0)\n                outOfRange--;\n        while (left < logs.length && logs[left][1] < queries[i] - x)\n            if (--cnt[logs[left++][0]] == 0)\n                outOfRange++;\n        ans[i] = outOfRange;\n    }\n    return ans;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 88,
        "prediction_id": 0,
        "pro_prediction": "public static boolean isPossible(int n, List<List<Integer>> edges) {\n    Set<Integer>[] g = new HashSet[n + 1];\n    for (int i = 0; i <= n; ++i) {\n        g[i] = new HashSet<>();\n    }\n    for (List<Integer> e : edges) {\n        int x = e.get(0), y = e.get(1);\n        g[x].add(y);\n        g[y].add(x);\n    }\n    List<Integer> odd = new ArrayList<>();\n    for (int i = 1; i <= n; ++i) {\n        if (g[i].size() % 2 != 0) {\n            odd.add(i);\n        }\n    }\n    int m = odd.size();\n    if (m == 0) {\n        return true;\n    }\n    if (m == 2) {\n        int x = odd.get(0), y = odd.get(1);\n        if (!g[x].contains(y)) {\n            return true;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (i != x && i != y && !g[i].contains(x) && !g[i].contains(y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (m == 4) {\n        int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3);\n        return !g[a].contains(b) && !g[c].contains(d) ||\n                !g[a].contains(c) && !g[b].contains(d) ||\n                !g[a].contains(d) && !g[b].contains(c);\n    }\n    return false;\n}",
        "main_fun_name": "isPossible",
        "raw_prediction": "```java\npublic boolean isPossible(int n, List<List<Integer>> edges) {\n    Set<Integer>[] g = new HashSet[n + 1];\n    for (int i = 0; i <= n; ++i) {\n        g[i] = new HashSet<>();\n    }\n    for (List<Integer> e : edges) {\n        int x = e.get(0), y = e.get(1);\n        g[x].add(y);\n        g[y].add(x);\n    }\n    List<Integer> odd = new ArrayList<>();\n    for (int i = 1; i <= n; ++i) {\n        if (g[i].size() % 2 != 0) {\n            odd.add(i);\n        }\n    }\n    int m = odd.size();\n    if (m == 0) {\n        return true;\n    }\n    if (m == 2) {\n        int x = odd.get(0), y = odd.get(1);\n        if (!g[x].contains(y)) {\n            return true;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (i != x && i != y && !g[i].contains(x) && !g[i].contains(y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (m == 4) {\n        int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3);\n        return !g[a].contains(b) && !g[c].contains(d) ||\n                !g[a].contains(c) && !g[b].contains(d) ||\n                !g[a].contains(d) && !g[b].contains(c);\n    }\n    return false;\n}\n```",
        "sl_gold_code": "bool isPossible(int n, vector<vector<int>> &edges) {\n    unordered_set<int> g[n + 1];\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].insert(y);\n        g[y].insert(x);\n    }\n    vector<int> odd;\n    for (int i = 1; i <= n; ++i)\n        if (g[i].size() % 2) odd.push_back(i);\n    int m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd[0], y = odd[1];\n        if (!g[x].count(y)) return true;\n        for (int i = 1; i <= n; ++i)\n            if (i != x && i != y && !g[i].count(x) && !g[i].count(y))\n                return true;\n        return false;\n    }\n    if (m == 4) {\n        int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\n        return !g[a].count(b) && !g[c].count(d) ||\n                !g[a].count(c) && !g[b].count(d) ||\n                !g[a].count(d) && !g[b].count(c);\n    }\n    return false;\n}",
        "tl_gold_code": "public static boolean isPossible(int n, List<List<Integer>> edges) {\n    var g = new Set[n + 1];\n    Arrays.setAll(g, e -> new HashSet<Integer>());\n    for (var e : edges) {\n        int x = e.get(0), y = e.get(1);\n        g[x].add(y);\n        g[y].add(x);\n    }\n    var odd = new ArrayList<Integer>();\n    for (var i = 1; i <= n; ++i)\n        if (g[i].size() % 2 > 0) odd.add(i);\n    var m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd.get(0), y = odd.get(1);\n        if (!g[x].contains(y)) return true;\n        for (var i = 1; i <= n; ++i)\n            if (i != x && i != y && !g[i].contains(x) && !g[i].contains(y))\n                return true;\n        return false;\n    }\n    if (m == 4) {\n        int a = odd.get(0), b = odd.get(1), c = odd.get(2), d = odd.get(3);\n        return !g[a].contains(b) && !g[c].contains(d) ||\n                !g[a].contains(c) && !g[b].contains(d) ||\n                !g[a].contains(d) && !g[b].contains(c);\n    }\n    return false;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 89,
        "prediction_id": 0,
        "pro_prediction": "public static int minExtraChar(String s, String[] dictionary) {\n        Set<String> set = new HashSet<>(Arrays.asList(dictionary));\n        int n = s.length();\n        int[] f = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            f[i + 1] = f[i] + 1;\n            for (int j = 0; j <= i; j++) {\n                if (set.contains(s.substring(j, i - j + 1))) {\n                    f[i + 1] = Math.min(f[i + 1], f[j]);\n                }\n            }\n        }\n        return f[n];\n    }",
        "main_fun_name": "minExtraChar",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int minExtraChar(String s, String[] dictionary) {\n        Set<String> set = new HashSet<>(Arrays.asList(dictionary));\n        int n = s.length();\n        int[] f = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            f[i + 1] = f[i] + 1;\n            for (int j = 0; j <= i; j++) {\n                if (set.contains(s.substring(j, i - j + 1))) {\n                    f[i + 1] = Math.min(f[i + 1], f[j]);\n                }\n            }\n        }\n        return f[n];\n    }\n}\n```",
        "sl_gold_code": "int minExtraChar(string s, vector<string> &dictionary) {\n    unordered_set<string> set(dictionary.begin(), dictionary.end());\n    int n = s.size();\n    vector<int> f(n + 1);\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j < i+1; j++) {\n            if (set.count(s.substr(j, i - j + 1))) {\n                f[i + 1] = min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}",
        "tl_gold_code": "public static int minExtraChar(String s, String[] dictionary) {\n    var set = new HashSet<String>(dictionary.length);\n    for (var str : dictionary) set.add(str);\n    int n = s.length();\n    var f = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j < i+1; j++) {\n            if (set.contains(s.substring(j, i + 1))) {\n                f[i + 1] = Math.min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 90,
        "prediction_id": 0,
        "pro_prediction": "public static int maximumPoints(int[][] edges, int[] coins, int k) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < coins.length; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        return dfs(0, -1, g, coins, k)[0];\n    }\n\npublic static int[] dfs(int x, int fa, List<List<Integer>> g, int[] coins, int k) {\n        int[] res1 = new int[14];\n        int[] res2 = new int[14];\n        for (int y : g.get(x)) {\n            if (y == fa) continue;\n            int[] r = dfs(y, x, g, coins, k);\n            for (int j = 0; j < 14; j++) {\n                res1[j] += r[j];\n                if (j < 13) {\n                    res2[j] += r[j + 1];\n                }\n            }\n        }\n        for (int j = 0; j < 14; j++) {\n            res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n        }\n        return res1;\n    }",
        "main_fun_name": "maximumPoints",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int maximumPoints(int[][] edges, int[] coins, int k) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < coins.length; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        return dfs(0, -1, g, coins, k)[0];\n    }\n\n    public static int[] dfs(int x, int fa, List<List<Integer>> g, int[] coins, int k) {\n        int[] res1 = new int[14];\n        int[] res2 = new int[14];\n        for (int y : g.get(x)) {\n            if (y == fa) continue;\n            int[] r = dfs(y, x, g, coins, k);\n            for (int j = 0; j < 14; j++) {\n                res1[j] += r[j];\n                if (j < 13) {\n                    res2[j] += r[j + 1];\n                }\n            }\n        }\n        for (int j = 0; j < 14; j++) {\n            res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n        }\n        return res1;\n    }\n}\n```",
        "sl_gold_code": "int maximumPoints(vector<vector<int>> &edges, vector<int> &coins, int k) {\n    vector<vector<int>> g(coins.size());\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\narray<int, 14> dfs(int x, int fa, const vector<vector<int>> &g, const vector<int> &coins, int k) {\n    array<int, 14> res1{}, res2{};\n    for (int y : g[x]) {\n        if (y == fa) continue;\n        auto r = dfs(y, x, g, coins, k);\n        for (int j = 0; j < 14; j++) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (int j = 0; j < 14; j++) {\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}",
        "tl_gold_code": "public static int maximumPoints(int[][] edges, int[] coins, int k) {\n    List<Integer>[] g = new ArrayList[coins.length];\n    Arrays.setAll(g, e -> new ArrayList<>());\n    for (int[] e : edges) {\n        int x = e[0], y = e[1];\n        g[x].add(y);\n        g[y].add(x);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\nprivate static int[] dfs(int x, int fa, List<Integer>[] g, int[] coins, int k) {\n    int[] res1 = new int[14];\n    int[] res2 = new int[14];\n    for (int y : g[x]) {\n        if (y == fa) continue;\n        int[] r = dfs(y, x, g, coins, k);\n        for (int j = 0; j < r.length; j++) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (int j = 0; j < res1.length; j++) {\n        res1[j] = Math.max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 91,
        "prediction_id": 0,
        "pro_prediction": "public static int countCompleteComponents(int n, int[][] edges) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        int[] vis = new int[n];\n        int ans = 0, v, e;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == 0) {\n                v = 0;\n                e = 0;\n                dfs(i, vis, g, v, e);\n                ans += e == v * (v - 1) ? 1 : 0;\n            }\n        }\n        return ans;\n    }\n\npublic static void dfs(int x, int[] vis, List<List<Integer>> g, int[] v, int[] e) {\n        vis[x] = 1;\n        v[0]++;\n        e[0] += g.get(x).size();\n        for (int y : g.get(x)) {\n            if (vis[y] == 0) {\n                dfs(y, vis, g, v, e);\n            }\n        }\n    }",
        "main_fun_name": "countCompleteComponents",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static int countCompleteComponents(int n, int[][] edges) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<>());\n        }\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        int[] vis = new int[n];\n        int ans = 0, v, e;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == 0) {\n                v = 0;\n                e = 0;\n                dfs(i, vis, g, v, e);\n                ans += e == v * (v - 1) ? 1 : 0;\n            }\n        }\n        return ans;\n    }\n\n    public static void dfs(int x, int[] vis, List<List<Integer>> g, int[] v, int[] e) {\n        vis[x] = 1;\n        v[0]++;\n        e[0] += g.get(x).size();\n        for (int y : g.get(x)) {\n            if (vis[y] == 0) {\n                dfs(y, vis, g, v, e);\n            }\n        }\n    }\n}\n```",
        "sl_gold_code": "int countCompleteComponents(int n, vector<vector<int>> &edges) {\n    vector<vector<int>> g(n);\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> vis(n, 0);\n    int ans = 0, v, e;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            v = 0;\n            e = 0;\n            dfs(i, vis, g, v, e);\n            ans += e == v * (v - 1);\n        }\n    }\n    return ans;\n}\nvoid dfs(int x, vector<int> &vis, vector<vector<int>> &g, int &v, int &e) {\n    vis[x] = 1;\n    v++;\n    e += g[x].size();\n    for (int y : g[x])\n        if (!vis[y])\n            dfs(y, vis, g, v, e);\n}",
        "tl_gold_code": "public static int countCompleteComponents(int n, int[][] edges) {\n    List<Integer>[] list = new ArrayList[n];\n    for (int i = 0; i < list.length; i++) {\n        list[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < edges.length; i++) {\n        list[edges[i][0]].add(edges[i][1]);\n        list[edges[i][1]].add(edges[i][0]);\n    }\n    int ans = 0;\n    boolean[] visited = new boolean[n];\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            int[] v = new int[1];\n            int[] e = new int[1];\n            dfs(list, visited, v, e, i);\n            if (v[0] * (v[0] - 1) == e[0]) {\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\npublic static void dfs(List<Integer>[] list, boolean[] visited, int[] v, int[] e, int current) {\n    if (!visited[current]) {\n        visited[current] = true;\n        v[0]++;\n        e[0] += list[current].size();\n        for (int n: list[current]) {\n            dfs(list, visited, v, e, n);\n        }\n    }\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 92,
        "prediction_id": 0,
        "pro_prediction": "public static boolean isPossibleToCutPath(int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1; grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}\n\npublic static boolean reach(int x, int y, int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        boolean ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}",
        "main_fun_name": "isPossibleToCutPath",
        "raw_prediction": "```java\nboolean reach(int x, int y, int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        boolean ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}\n\nboolean isPossibleToCutPath(int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1; grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}\n```",
        "sl_gold_code": "bool reach(int x, int y, vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        bool ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}\nbool isPossibleToCutPath(vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1; grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}",
        "tl_gold_code": "public static boolean reach(int x,int y,int[][] grid){\n    int n=grid.length;\n    int m=grid[0].length;\n    if (x==n-1&&y==m-1){\n        return true;\n    }\n    grid[x][y]=0;\n    int x1=x;int y1=y+1;\n    if (y1<m&&grid[x1][y1]==1){\n        boolean ret=reach(x1,y1,grid);\n        if (ret){\n            return ret;\n        }\n    }\n    int x2=x+1;int y2=y;\n    if (x2<n&&grid[x2][y2]==1){\n        return reach(x2,y2,grid);\n    }\n    return false;\n}\npublic static boolean isPossibleToCutPath(int[][] grid) {\n    int n=grid.length;\n    int m=grid[0].length;\n    List<Integer> queue=new ArrayList<>();\n    boolean[][] rea=new boolean[n][m];\n    if (!reach(0,0,grid)){\n        return true;\n    }\n    grid[0][0]=1;grid[n-1][m-1]=1;\n    if (!reach(0,0,grid)){\n        return true;\n    }\n    return false;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 93,
        "prediction_id": 0,
        "pro_prediction": "public static boolean validPath(int n, int[][] edges, int source, int destination) {\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int x = edge[0], y = edge[1];\n            adj.get(x).add(y);\n            adj.get(y).add(x);\n        }\n        boolean[] visited = new boolean[n];\n        return dfs(source, destination, adj, visited);\n    }\n\npublic static boolean dfs(int source, int destination, List<List<Integer>> adj, boolean[] visited) {\n        if (source == destination) {\n            return true;\n        }\n        visited[source] = true;\n        for (int next : adj.get(source)) {\n            if (!visited[next] && dfs(next, destination, adj, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "main_fun_name": "validPath",
        "raw_prediction": "```java\nimport java.util.*;\n\npublic class Main {\n    public static boolean validPath(int n, int[][] edges, int source, int destination) {\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int x = edge[0], y = edge[1];\n            adj.get(x).add(y);\n            adj.get(y).add(x);\n        }\n        boolean[] visited = new boolean[n];\n        return dfs(source, destination, adj, visited);\n    }\n\n    public static boolean dfs(int source, int destination, List<List<Integer>> adj, boolean[] visited) {\n        if (source == destination) {\n            return true;\n        }\n        visited[source] = true;\n        for (int next : adj.get(source)) {\n            if (!visited[next] && dfs(next, destination, adj, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
        "sl_gold_code": "bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n    vector<list<int>> adj(n);\n    for (auto& edge : edges) {\n        int x = edge[0], y = edge[1];\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    vector<bool> visited(n, false);\n    return dfs(source, destination, adj, visited);\n}\nbool dfs(int source, int destination, vector<list<int>>& adj, vector<bool>& visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (int next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}",
        "tl_gold_code": "public static boolean validPath(int n, int[][] edges, int source, int destination) {\n    List<Integer>[] adj = new List[n];\n    for (int i = 0; i < n; i++) {\n        adj[i] = new ArrayList<Integer>();\n    }\n    for (int[] edge : edges) {\n        int x = edge[0], y = edge[1];\n        adj[x].add(y);\n        adj[y].add(x);\n    }\n    boolean[] visited = new boolean[n];\n    return dfs(source, destination, adj, visited);\n}\npublic static boolean dfs(int source, int destination, List<Integer>[] adj, boolean[] visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (int next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 94,
        "prediction_id": 0,
        "pro_prediction": "public static boolean isSubPath(ListNode head, TreeNode root) {\n    if (root == null) return false;\n    return dfs(root, head) || isSubPath(head, root.left) || isSubPath(head, root.right);\n}\n\npublic static boolean dfs(TreeNode rt, ListNode head) {\n    if (head == null) return true;\n    if (rt == null) return false;\n    if (rt.val != head.val) return false;\n    return dfs(rt.left, head.next) || dfs(rt.right, head.next);\n}",
        "main_fun_name": "isSubPath",
        "raw_prediction": "```java\npublic boolean dfs(TreeNode rt, ListNode head) {\n    if (head == null) return true;\n    if (rt == null) return false;\n    if (rt.val != head.val) return false;\n    return dfs(rt.left, head.next) || dfs(rt.right, head.next);\n}\n\npublic boolean isSubPath(ListNode head, TreeNode root) {\n    if (root == null) return false;\n    return dfs(root, head) || isSubPath(head, root.left) || isSubPath(head, root.right);\n}\n```",
        "sl_gold_code": "bool dfs(TreeNode* rt, ListNode* head) {\n    if (head == NULL) return true;\n    if (rt == NULL) return false;\n    if (rt->val != head->val) return false;\n    return dfs(rt->left, head->next) || dfs(rt->right, head->next);\n}\nbool isSubPath(ListNode* head, TreeNode* root) {\n    if (root == NULL) return false;\n    return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\n}",
        "tl_gold_code": "public static boolean isSubPath(ListNode head, TreeNode root) {\n    if(root==null) return false;\n    return dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right);\n}\npublic static boolean dfs(ListNode head,TreeNode root){\n    if(head==null) return true;\n    if(root==null) return false;\n    if(head.val!=root.val) return false;\n    return dfs(head.next,root.left)||dfs(head.next,root.right);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 95,
        "prediction_id": 0,
        "pro_prediction": "public static List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n        List<Integer> nums1 = new ArrayList<>(), nums2 = new ArrayList<>();\n        inorder(root1, nums1);\n        inorder(root2, nums2);\n        List<Integer> merged = new ArrayList<>();\n        Iterator<Integer> p1 = nums1.iterator(), p2 = nums2.iterator();\n        while (true) {\n            if (!p1.hasNext()) {\n                merged.addAll(nums2);\n                break;\n            }\n            if (!p2.hasNext()) {\n                merged.addAll(nums1);\n                break;\n            }\n            if (p1.next() < p2.next()) {\n                merged.add(p1.next());\n            } else {\n                merged.add(p2.next());\n            }\n        }\n        return merged;\n    }\n\npublic static void inorder(TreeNode node, List<Integer> res) {\n        if (node != null) {\n            inorder(node.left, res);\n            res.add(node.val);\n            inorder(node.right, res);\n        }\n    }",
        "main_fun_name": "getAllElements",
        "raw_prediction": "```java\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Main {\n    public static void inorder(TreeNode node, List<Integer> res) {\n        if (node != null) {\n            inorder(node.left, res);\n            res.add(node.val);\n            inorder(node.right, res);\n        }\n    }\n\n    public static List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n        List<Integer> nums1 = new ArrayList<>(), nums2 = new ArrayList<>();\n        inorder(root1, nums1);\n        inorder(root2, nums2);\n        List<Integer> merged = new ArrayList<>();\n        Iterator<Integer> p1 = nums1.iterator(), p2 = nums2.iterator();\n        while (true) {\n            if (!p1.hasNext()) {\n                merged.addAll(nums2);\n                break;\n            }\n            if (!p2.hasNext()) {\n                merged.addAll(nums1);\n                break;\n            }\n            if (p1.next() < p2.next()) {\n                merged.add(p1.next());\n            } else {\n                merged.add(p2.next());\n            }\n        }\n        return merged;\n    }\n}\n```",
        "sl_gold_code": "void inorder(TreeNode *node, vector<int> &res) {\n    if (node) {\n        inorder(node->left, res);\n        res.push_back(node->val);\n        inorder(node->right, res);\n    }\n}\nvector<int> getAllElements(TreeNode *root1, TreeNode *root2) {\n    vector<int> nums1, nums2;\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    vector<int> merged;\n    auto p1 = nums1.begin(), p2 = nums2.begin();\n    while (true) {\n        if (p1 == nums1.end()) {\n            merged.insert(merged.end(), p2, nums2.end());\n            break;\n        }\n        if (p2 == nums2.end()) {\n            merged.insert(merged.end(), p1, nums1.end());\n            break;\n        }\n        if (*p1 < *p2) {\n            merged.push_back(*p1++);\n        } else {\n            merged.push_back(*p2++);\n        }\n    }\n    return merged;\n}",
        "tl_gold_code": "public static void inorder(TreeNode node, List<Integer> res) {\n    if (node != null) {\n        inorder(node.left, res);\n        res.add(node.val);\n        inorder(node.right, res);\n    }\n}\npublic static List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    List<Integer> nums1 = new ArrayList<>(), nums2 = new ArrayList<>();\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    List<Integer> merged = new ArrayList<>();\n    int p1 = 0, p2 = 0;\n    while (true) {\n        if (p1 == nums1.size()) {\n            merged.addAll(nums2.subList(p2, nums2.size()));\n            break;\n        }\n        if (p2 == nums2.size()) {\n            merged.addAll(nums1.subList(p1, nums1.size()));\n            break;\n        }\n        if (nums1.get(p1) < nums2.get(p2)) {\n            merged.add(nums1.get(p1++));\n        } else {\n            merged.add(nums2.get(p2++));\n        }\n    }\n    return merged;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 96,
        "prediction_id": 0,
        "pro_prediction": "public static int maxLevelSum(TreeNode root) {\n    List<Integer> sums = new ArrayList<>();\n    dfs(root, 0, sums);\n    return IntStream.range(0, sums.size()).boxed()\n            .max(Comparator.comparing(sums::get))\n            .map(i -> i + 1)\n            .orElse(0);\n}\n\npublic static void dfs(TreeNode node, int level, List<Integer> sums) {\n    if (node == null) return;\n    if (level == sums.size()) {\n        sums.add(node.val);\n    } else {\n        sums.set(level, sums.get(level) + node.val);\n    }\n    dfs(node.left, level + 1, sums);\n    dfs(node.right, level + 1, sums);\n}",
        "main_fun_name": "maxLevelSum",
        "raw_prediction": "```java\npublic int maxLevelSum(TreeNode root) {\n    List<Integer> sums = new ArrayList<>();\n    dfs(root, 0, sums);\n    return IntStream.range(0, sums.size()).boxed()\n            .max(Comparator.comparing(sums::get))\n            .map(i -> i + 1)\n            .orElse(0);\n}\n\nprivate void dfs(TreeNode node, int level, List<Integer> sums) {\n    if (node == null) return;\n    if (level == sums.size()) {\n        sums.add(node.val);\n    } else {\n        sums.set(level, sums.get(level) + node.val);\n    }\n    dfs(node.left, level + 1, sums);\n    dfs(node.right, level + 1, sums);\n}\n```",
        "sl_gold_code": "int maxLevelSum(TreeNode* root) {\n    std::vector<int> sums;\n    dfs(root, 0, sums);\n    return (int)(std::max_element(sums.begin(), sums.end()) - sums.begin()) + 1;\n}\nvoid dfs(TreeNode* node, int level, std::vector<int>& sums) {\n    if (!node) return;\n    if (level == sums.size()) {\n        sums.push_back(node->val);\n    } else {\n        sums[level] += node->val;\n    }\n    dfs(node->left, level + 1, sums);\n    dfs(node->right, level + 1, sums);\n}",
        "tl_gold_code": "public static int maxLevelSum(TreeNode root) {\n    List<Integer> sums = new ArrayList<>();\n    dfs(root, 0, sums);\n    return sums.indexOf(Collections.max(sums)) + 1;\n}\nprivate static void dfs(TreeNode node, int level, List<Integer> sums) {\n    if (node == null) return;\n    if (level == sums.size()) {\n        sums.add(node.val);\n    } else {\n        sums.set(level, sums.get(level) + node.val);\n    }\n    dfs(node.left, level + 1, sums);\n    dfs(node.right, level + 1, sums);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 97,
        "prediction_id": 0,
        "pro_prediction": "public static int sumRootToLeaf(TreeNode root) {\n        return dfs(root, 0);\n    }\n\npublic static int dfs(TreeNode root, int val) {\n        if (root == null) {\n            return 0;\n        }\n        val = (val << 1) | root.val;\n        if (root.left == null && root.right == null) {\n            return val;\n        }\n        return dfs(root.left, val) + dfs(root.right, val);\n    }",
        "main_fun_name": "sumRootToLeaf",
        "raw_prediction": "```java\npublic class Solution {\n    public int sumRootToLeaf(TreeNode root) {\n        return dfs(root, 0);\n    }\n    \n    private int dfs(TreeNode root, int val) {\n        if (root == null) {\n            return 0;\n        }\n        val = (val << 1) | root.val;\n        if (root.left == null && root.right == null) {\n            return val;\n        }\n        return dfs(root.left, val) + dfs(root.right, val);\n    }\n}\n```\nNote: In Java, we need to define the `dfs` method as `private` since it's only meant to be used within the `Solution` class. Also, we assume that the `TreeNode` class is defined as follows:\n```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
        "sl_gold_code": "int dfs(TreeNode *root, int val) {\n    if (root == nullptr) {\n        return 0;\n    }\n    val = (val << 1) | root->val;\n    if (root->left == nullptr && root->right == nullptr) {\n        return val;\n    }\n    return dfs(root->left, val) + dfs(root->right, val);\n}\nint sumRootToLeaf(TreeNode* root) {\n    return dfs(root, 0);\n}",
        "tl_gold_code": "public static int sumRootToLeaf(TreeNode root) {\n    return dfs(root, 0);\n}\npublic static int dfs(TreeNode root, int val) {\n    if (root == null) {\n        return 0;\n    }\n    val = (val << 1) | root.val;\n    if (root.left == null && root.right == null) {\n        return val;\n    }\n    return dfs(root.left, val) + dfs(root.right, val);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 98,
        "prediction_id": 0,
        "pro_prediction": "public static boolean isCousins(TreeNode root, int x, int y) {\n        int[] xi = dfs(root, null, 0, x);\n        int[] yi = dfs(root, null, 0, y);\n        return xi[1] == yi[1] && xi[0] != yi[0];\n    }\n\npublic static int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\n        if (root == null) return new int[]{-1, -1};\n        if (root.val == t) {\n            return new int[]{fa != null ? fa.val : 1, depth};\n        }\n        int[] l = dfs(root.left, root, depth + 1, t);\n        if (l[0] != -1) return l;\n        return dfs(root.right, root, depth + 1, t);\n    }",
        "main_fun_name": "isCousins",
        "raw_prediction": "```java\nclass Solution {\n    public boolean isCousins(TreeNode root, int x, int y) {\n        int[] xi = dfs(root, null, 0, x);\n        int[] yi = dfs(root, null, 0, y);\n        return xi[1] == yi[1] && xi[0] != yi[0];\n    }\n\n    public int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\n        if (root == null) return new int[]{-1, -1};\n        if (root.val == t) {\n            return new int[]{fa != null ? fa.val : 1, depth};\n        }\n        int[] l = dfs(root.left, root, depth + 1, t);\n        if (l[0] != -1) return l;\n        return dfs(root.right, root, depth + 1, t);\n    }\n}\n```\nNote: In Java, we typically use arrays instead of vectors for returning multiple values from a function. Also, since Java is a statically typed language, we need to specify the types of the variables and return values explicitly.",
        "sl_gold_code": "vector<int> dfs(TreeNode* root, TreeNode* fa, int depth, int t){\n    if(root ==nullptr)  return vector<int>{-1, -1};\n    if(root->val == t){\n        return vector<int>{fa != nullptr ? fa->val : 1, depth};\n    }\n    vector<int> l = dfs(root->left, root, depth + 1, t);\n    if(l[0] != -1)  return l;\n    return dfs(root->right, root, depth + 1, t);\n}\nbool isCousins(TreeNode* root, int x, int y) {\n    vector<int> xi = dfs(root, nullptr, 0, x);\n    vector<int> yi = dfs(root, nullptr, 0, y);\n    return xi[1] == yi[1] && xi[0] != yi[0];\n}",
        "tl_gold_code": "public static boolean isCousins(TreeNode root, int x, int y) {\n    int[] xi = dfs(root, null, 0, x);\n    int[] yi = dfs(root, null, 0, y);\n    return xi[1] == yi[1] && xi[0] != yi[0];\n}\npublic static int[] dfs(TreeNode root, TreeNode fa, int depth, int t) {\n    if (root == null) return new int[]{-1, -1};\n    if (root.val == t) {\n        return new int[]{fa != null ? fa.val : 1, depth};\n    }\n    int[] l = dfs(root.left, root, depth + 1, t);\n    if (l[0] != -1) return l;\n    return dfs(root.right, root, depth + 1, t);\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 99,
        "prediction_id": 0,
        "pro_prediction": "public static int longestSquareStreak(int[] nums) {\n        int ans = 0;\n        Set<Integer> s = new HashSet<>();\n        for (int num : nums) {\n            s.add(num);\n        }\n        for (int x : s) {\n            int cnt = 0;\n            while (s.contains(x)) {\n                cnt += 1;\n                if (x > Math.sqrt(Integer.MAX_VALUE)) break;\n                x *= x;\n            }\n            ans = Math.max(ans, cnt);\n        }\n        return ans > 1 ? ans : -1;\n    }",
        "main_fun_name": "longestSquareStreak",
        "raw_prediction": "```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    public static int longestSquareStreak(int[] nums) {\n        int ans = 0;\n        Set<Integer> s = new HashSet<>();\n        for (int num : nums) {\n            s.add(num);\n        }\n        for (int x : s) {\n            int cnt = 0;\n            while (s.contains(x)) {\n                cnt += 1;\n                if (x > Math.sqrt(Integer.MAX_VALUE)) break;\n                x *= x;\n            }\n            ans = Math.max(ans, cnt);\n        }\n        return ans > 1 ? ans : -1;\n    }\n}\n```",
        "sl_gold_code": "int longestSquareStreak(vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> s(nums.begin(), nums.end());\n    for (int x : s) {\n        int cnt = 0;\n        while (s.find(x) != s.end()) {\n            cnt += 1;\n            if (x > std::sqrt(INT_MAX)) break;\n            x *= x;\n        }\n        ans = max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}",
        "tl_gold_code": "public static int longestSquareStreak(int[] nums) {\n    int ans = 0;\n    Set<Integer> s = new HashSet<>();\n    for (int num : nums) {\n        s.add(num);\n    }\n    for (int x : s) {\n        int cnt = 0;\n        while (s.contains(x)) {\n            cnt += 1;\n            if (x > Math.sqrt(Integer.MAX_VALUE)) break;\n            x *= x;\n        }\n        ans = Math.max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}"
    },
    {
        "task": "c++_java",
        "problem_id": 100,
        "prediction_id": 0,
        "pro_prediction": "public static int appendCharacters(String s, String t) {\n    int j = 0, m = t.length();\n    for (char c : s.toCharArray()) {\n        if (c == t.charAt(j)) {\n            j += 1;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}",
        "main_fun_name": "appendCharacters",
        "raw_prediction": "```java\npublic static int appendCharacters(String s, String t) {\n    int j = 0, m = t.length();\n    for (char c : s.toCharArray()) {\n        if (c == t.charAt(j)) {\n            j += 1;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}\n```",
        "sl_gold_code": "int appendCharacters(string s, string t) {\n    int j = 0, m = t.size();\n    for (char c : s) {\n        if (c == t[j]) {\n            j += 1;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}",
        "tl_gold_code": "public static int appendCharacters(String s, String t) {\n    int j = 0, m = t.length();\n    for (char c : s.toCharArray()) {\n        if (c == t.charAt(j)) {\n            j++;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}"
    }
]