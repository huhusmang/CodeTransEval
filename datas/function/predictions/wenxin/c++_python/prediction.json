[
    {
        "task": "c++_python",
        "problem_id": 1,
        "prediction_id": 0,
        "pro_prediction": "def findKOr(nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt1 = sum((x >> i) & 1 for x in nums)\n        if cnt1 >= k:\n            ans |= 1 << i\n    return ans",
        "main_fun_name": "findKOr",
        "raw_prediction": "```python\ndef findKOr(nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt1 = sum((x >> i) & 1 for x in nums)\n        if cnt1 >= k:\n            ans |= 1 << i\n    return ans\n```",
        "sl_gold_code": "int findKOr(vector<int>& nums, int k) {\n    int ans = 0;\n    for (int i = 0; i < 31; i++) {\n        int cnt1 = 0;\n        for (int x : nums) {\n            cnt1 += (x >> i) & 1;\n        }\n        if (cnt1 >= k) {\n            ans |= 1 << i;\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def findKOr(nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt1 = 0\n        for x in nums:\n            cnt1 += x >> i & 1\n        if cnt1 >= k:\n            ans |= 1 << i\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 2,
        "prediction_id": 0,
        "pro_prediction": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    s1 = 0\n    zero1 = False\n    for x in nums1:\n        if x == 0:\n            zero1 = True\n            s1 += 1\n        else:\n            s1 += x\n\n    s2 = 0\n    zero2 = False\n    for x in nums2:\n        if x == 0:\n            zero2 = True\n            s2 += 1\n        else:\n            s2 += x\n\n    if (not zero1 and s1 < s2) or (not zero2 and s2 < s1):\n        return -1\n\n    return max(s1, s2)",
        "main_fun_name": "minSum",
        "raw_prediction": "```python\nfrom typing import List\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    s1 = 0\n    zero1 = False\n    for x in nums1:\n        if x == 0:\n            zero1 = True\n            s1 += 1\n        else:\n            s1 += x\n\n    s2 = 0\n    zero2 = False\n    for x in nums2:\n        if x == 0:\n            zero2 = True\n            s2 += 1\n        else:\n            s2 += x\n\n    if (not zero1 and s1 < s2) or (not zero2 and s2 < s1):\n        return -1\n\n    return max(s1, s2)\n```",
        "sl_gold_code": "long long minSum(vector<int>& nums1, vector<int>& nums2) {\n    long long s1 = 0;\n    bool zero1 = false;\n    for (int x : nums1) {\n        if (x == 0) {\n            zero1 = true;\n            s1++;\n        } else {\n            s1 += x;\n        }\n    }\n    long long s2 = 0;\n    bool zero2 = false;\n    for (int x : nums2) {\n        if (x == 0) {\n            zero2 = true;\n            s2++;\n        } else {\n            s2 += x;\n        }\n    }\n    if (!zero1 && s1 < s2 || !zero2 && s2 < s1) {\n        return -1;\n    }\n    return max(s1, s2);\n}",
        "tl_gold_code": "def minSum(nums1, nums2):\n    s1 = 0\n    zero1 = False\n    for x in nums1:\n        if x == 0:\n            zero1 = True\n            s1 += 1\n        else:\n            s1 += x\n    s2 = 0\n    zero2 = False\n    for x in nums2:\n        if x == 0:\n            zero2 = True\n            s2 += 1\n        else:\n            s2 += x\n    if (not zero1 and s1 < s2) or (not zero2 and s2 < s1):\n        return -1\n    return max(s1, s2)"
    },
    {
        "task": "c++_python",
        "problem_id": 3,
        "prediction_id": 0,
        "pro_prediction": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    f = [float('-inf')] * (target + 1)\n    f[0] = 0\n    s = 0\n    for x in nums:\n        s = min(s + x, target)\n        for j in range(s, x - 1, -1):\n            f[j] = max(f[j], f[j - x] + 1)\n    return f[target] if f[target] > 0 else -1",
        "main_fun_name": "lengthOfLongestSubsequence",
        "raw_prediction": "```python\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    f = [float('-inf')] * (target + 1)\n    f[0] = 0\n    s = 0\n    for x in nums:\n        s = min(s + x, target)\n        for j in range(s, x - 1, -1):\n            f[j] = max(f[j], f[j - x] + 1)\n    return f[target] if f[target] > 0 else -1\n```",
        "sl_gold_code": "int lengthOfLongestSubsequence(vector<int> &nums, int target) {\n    vector<int> f(target + 1, INT_MIN);\n    f[0] = 0;\n    int s = 0;\n    for (int x : nums) {\n        s = min(s + x, target);\n        for (int j = s; j >= x; j--) {\n            f[j] = max(f[j], f[j - x] + 1);\n        }\n    }\n    return f[target] > 0 ? f[target] : -1;\n}",
        "tl_gold_code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    f = [0] + [-inf] * target\n    s = 0\n    for x in nums:\n        s = min(s + x, target)\n        for j in range(s, x - 1, -1):\n            if f[j] < f[j - x] + 1:\n                f[j] = f[j - x] + 1\n    return f[-1] if f[-1] > 0 else -1"
    },
    {
        "task": "c++_python",
        "problem_id": 4,
        "prediction_id": 0,
        "pro_prediction": "def minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0, len(s), 2):\n        ans += s[i] != s[i + 1]\n    return ans",
        "main_fun_name": "minChanges",
        "raw_prediction": "```python\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0, len(s), 2):\n        ans += s[i] != s[i + 1]\n    return ans\n```",
        "sl_gold_code": "int minChanges(string s) {\n    int ans = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        ans += s[i] != s[i + 1];\n    }\n    return ans;\n}",
        "tl_gold_code": "def minChanges(s):\n    ans = 0\n    for i in range(0, len(s), 2):\n        ans += int(s[i] != s[i + 1])\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 5,
        "prediction_id": 0,
        "pro_prediction": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    k = min(cnt.values())\n    while True:\n        k -= 1\n        ans = sum(math.ceil(c / (k + 1)) for c in cnt.values())\n        if ans:\n            return ans",
        "main_fun_name": "minGroupsForValidAssignment",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import Counter\nimport math\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    k = min(cnt.values())\n    while True:\n        k -= 1\n        ans = sum(math.ceil(c / (k + 1)) for c in cnt.values())\n        if ans:\n            return ans\n```",
        "sl_gold_code": "int minGroupsForValidAssignment(vector<int>& nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int k = min_element(cnt.begin(), cnt.end(), [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    })->second;\n    for (; ; k--) {\n        int ans = 0;\n        for (auto &[_, c] : cnt) {\n            if (c / k < c % k) {\n                ans = 0;\n                break;\n            }\n            ans += (c + k) / (k + 1);\n        }\n        if (ans) {\n            return ans;\n        }\n    }\n}",
        "tl_gold_code": "def minGroupsForValidAssignment(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    k = len(nums)\n    for c in cnt.values():\n        k = min(k, c)\n    while True:\n        ans = 0\n        for c in cnt.values():\n            if c // k < c % k:\n                ans = 0\n                break\n            ans += (c + k) // (k + 1)\n        if ans > 0:\n            return ans\n        k -= 1"
    },
    {
        "task": "c++_python",
        "problem_id": 6,
        "prediction_id": 0,
        "pro_prediction": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    suf = [0] * n\n    suf[n - 1] = nums[n - 1]\n    for i in range(n - 2, 0, -1):\n        suf[i] = min(suf[i + 1], nums[i])\n    ans = float('inf')\n    pre = nums[0]\n    for j in range(1, n - 1):\n        if pre < nums[j] and nums[j] > suf[j + 1]:\n            ans = min(ans, pre + nums[j] + suf[j + 1])\n        pre = min(pre, nums[j])\n    return -1 if ans == float('inf') else ans",
        "main_fun_name": "minimumSum",
        "raw_prediction": "```python\ndef minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    suf = [0] * n\n    suf[n - 1] = nums[n - 1]\n    for i in range(n - 2, 0, -1):\n        suf[i] = min(suf[i + 1], nums[i])\n    ans = float('inf')\n    pre = nums[0]\n    for j in range(1, n - 1):\n        if pre < nums[j] and nums[j] > suf[j + 1]:\n            ans = min(ans, pre + nums[j] + suf[j + 1])\n        pre = min(pre, nums[j])\n    return -1 if ans == float('inf') else ans\n```",
        "sl_gold_code": "int minimumSum(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> suf(n);\n    suf[n - 1] = nums[n - 1];\n    for (int i = n - 2; i > 1; i--) {\n        suf[i] = min(suf[i + 1], nums[i]);\n    }\n    int ans = INT_MAX;\n    int pre = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        if (pre < nums[j] && nums[j] > suf[j + 1]) {\n            ans = min(ans, pre + nums[j] + suf[j + 1]);\n        }\n        pre = min(pre, nums[j]);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}",
        "tl_gold_code": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    suf = [0] * n\n    suf[-1] = nums[-1]\n    for i in range(n - 2, 1, -1):\n        suf[i] = min(suf[i + 1], nums[i])\n    ans = inf\n    pre = nums[0]\n    for j in range(1, n - 1):\n        if pre < nums[j] > suf[j + 1]:\n            ans = min(ans, pre + nums[j] + suf[j + 1])\n        pre = min(pre, nums[j])\n    return ans if ans < inf else -1"
    },
    {
        "task": "c++_python",
        "problem_id": 7,
        "prediction_id": 0,
        "pro_prediction": "def constructProductMatrix(grid):\n    MOD = 12345\n    n = len(grid)\n    m = len(grid[0])\n    p = [[0] * m for _ in range(n)]\n    suf = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            p[i][j] = suf\n            suf = suf * grid[i][j] % MOD\n    pre = 1\n    for i in range(n):\n        for j in range(m):\n            p[i][j] = p[i][j] * pre % MOD\n            pre = pre * grid[i][j] % MOD\n    return p",
        "main_fun_name": "constructProductMatrix",
        "raw_prediction": "```python\ndef constructProductMatrix(grid):\n    MOD = 12345\n    n = len(grid)\n    m = len(grid[0])\n    p = [[0] * m for _ in range(n)]\n    suf = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            p[i][j] = suf\n            suf = suf * grid[i][j] % MOD\n    pre = 1\n    for i in range(n):\n        for j in range(m):\n            p[i][j] = p[i][j] * pre % MOD\n            pre = pre * grid[i][j] % MOD\n    return p\n```",
        "sl_gold_code": "vector<vector<int>> constructProductMatrix(vector<vector<int>> &grid) {\n    const int MOD = 12345;\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<int>> p(n, vector<int>(m));\n    long long suf = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            p[i][j] = suf;\n            suf = suf * grid[i][j] % MOD;\n        }\n    }\n    long long pre = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            p[i][j] = p[i][j] * pre % MOD;\n            pre = pre * grid[i][j] % MOD;\n        }\n    }\n    return p;\n}",
        "tl_gold_code": "def constructProductMatrix(grid: List[List[int]]) -> List[List[int]]:\n    MOD = 12345\n    n, m = len(grid), len(grid[0])\n    p = [[0] * m for _ in range(n)]\n    suf = 1  \n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            p[i][j] = suf  \n            suf = suf * grid[i][j] % MOD\n    pre = 1  \n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            p[i][j] = p[i][j] * pre % MOD  \n            pre = pre * x % MOD\n    return p"
    },
    {
        "task": "c++_python",
        "problem_id": 8,
        "prediction_id": 0,
        "pro_prediction": "def maximumOddBinaryNumber(s: str) -> str:\n    cnt1 = s.count('1')\n    return '1' * (cnt1 - 1) + '0' * (len(s) - cnt1) + '1'",
        "main_fun_name": "maximumOddBinaryNumber",
        "raw_prediction": "```python\ndef maximumOddBinaryNumber(s: str) -> str:\n    cnt1 = s.count('1')\n    return '1' * (cnt1 - 1) + '0' * (len(s) - cnt1) + '1'\n```",
        "sl_gold_code": "string maximumOddBinaryNumber(string s) {\n    int cnt1 = count(s.begin(), s.end(), '1');\n    return string(cnt1 - 1, '1') + string(s.length() - cnt1, '0') + '1';\n}",
        "tl_gold_code": "def maximumOddBinaryNumber(s: str) -> str:\n    cnt1 = s.count('1')\n    return '1' * (cnt1 - 1) + '0' * (len(s) - cnt1) + '1'"
    },
    {
        "task": "c++_python",
        "problem_id": 9,
        "prediction_id": 0,
        "pro_prediction": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    if s.count('1') < k:\n        return \"\"\n    ans = s\n    cnt1 = 0\n    left = 0\n    for right in range(len(s)):\n        cnt1 += int(s[right])\n        while cnt1 > k or s[left] == '0':\n            cnt1 -= int(s[left])\n            left += 1\n        if cnt1 == k:\n            t = s[left:right + 1]\n            if len(t) < len(ans) or len(t) == len(ans) and t < ans:\n                ans = t\n    return ans",
        "main_fun_name": "shortestBeautifulSubstring",
        "raw_prediction": "```python\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    if s.count('1') < k:\n        return \"\"\n    ans = s\n    cnt1 = 0\n    left = 0\n    for right in range(len(s)):\n        cnt1 += int(s[right])\n        while cnt1 > k or s[left] == '0':\n            cnt1 -= int(s[left])\n            left += 1\n        if cnt1 == k:\n            t = s[left:right + 1]\n            if len(t) < len(ans) or len(t) == len(ans) and t < ans:\n                ans = t\n    return ans\n```",
        "sl_gold_code": "string shortestBeautifulSubstring(string s, int k) {\n    if (count(s.begin(), s.end(), '1') < k) {\n        return \"\";\n    }\n    string ans = s;\n    int cnt1 = 0, left = 0;\n    for (int right = 0; right < s.length(); right++) {\n        cnt1 += s[right] - '0';\n        while (cnt1 > k || s[left] == '0') {\n            cnt1 -= s[left++] - '0';\n        }\n        if (cnt1 == k) {\n            string t = s.substr(left, right - left + 1);\n            if (t.length() < ans.length() || t.length() == ans.length() && t < ans) {\n                ans = move(t);\n            }\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    if s.count('1') < k:\n        return ''\n    ans = s\n    cnt1 = left = 0\n    for right, c in enumerate(s):\n        cnt1 += int(c)\n        while cnt1 > k or s[left] == '0':\n            cnt1 -= int(s[left])\n            left += 1\n        if cnt1 == k:\n            t = s[left: right + 1]\n            if len(t) < len(ans) or len(t) == len(ans) and t < ans:\n                ans = t\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 10,
        "prediction_id": 0,
        "pro_prediction": "def addMinimum(s: str) -> int:\n    t = 1\n    for i in range(1, len(s)):\n        t += s[i - 1] >= s[i]\n    return t * 3 - len(s)",
        "main_fun_name": "addMinimum",
        "raw_prediction": "```python\ndef addMinimum(s: str) -> int:\n    t = 1\n    for i in range(1, len(s)):\n        t += s[i - 1] >= s[i]\n    return t * 3 - len(s)\n```",
        "sl_gold_code": "int addMinimum(string s) {\n    int t = 1;\n    for (int i = 1; i < s.length(); ++i)\n        t += s[i - 1] >= s[i];\n    return t * 3 - s.length();\n}",
        "tl_gold_code": "def addMinimum(s):\n    t = 1\n    for i in range(1, len(s)):\n        t += s[i - 1] >= s[i]\n    return t * 3 - len(s)"
    },
    {
        "task": "c++_python",
        "problem_id": 11,
        "prediction_id": 0,
        "pro_prediction": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    usageLimits.sort()\n    remain = 0\n    require = 1\n    for num in usageLimits:\n        remain += num\n        if remain >= require:\n            remain -= require\n            require += 1\n    return require - 1",
        "main_fun_name": "maxIncreasingGroups",
        "raw_prediction": "```python\nfrom typing import List\n\ndef maxIncreasingGroups(usageLimits: List[int]) -> int:\n    usageLimits.sort()\n    remain = 0\n    require = 1\n    for num in usageLimits:\n        remain += num\n        if remain >= require:\n            remain -= require\n            require += 1\n    return require - 1\n```",
        "sl_gold_code": "int maxIncreasingGroups(vector<int>& usageLimits) {\n    sort(usageLimits.begin(), usageLimits.end());\n    long long remain = 0;\n    int require = 1;\n    for (int num : usageLimits) {\n        remain += num;\n        if (remain >= require) {\n            remain -= require;\n            require++;\n        }\n    }\n    return require - 1;\n}",
        "tl_gold_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    ul = sorted(usageLimits)\n    remain = 0\n    require = 1\n    for num in ul:\n        remain += num\n        if remain >= require:\n            remain -= require \n            require += 1 \n    return require - 1"
    },
    {
        "task": "c++_python",
        "problem_id": 12,
        "prediction_id": 0,
        "pro_prediction": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    a = []\n    k = 0\n    for s in words:\n        if s[0] != 'p':\n            a.append(int(s))\n            k = 0\n        else:\n            ans.append(-1 if k + 1 > len(a) else a[len(a) - k - 1])\n            k += 1\n    return ans",
        "main_fun_name": "lastVisitedIntegers",
        "raw_prediction": "```python\nfrom typing import List\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    a = []\n    k = 0\n    for s in words:\n        if s[0] != 'p':\n            a.append(int(s))\n            k = 0\n        else:\n            ans.append(-1 if k + 1 > len(a) else a[len(a) - k - 1])\n            k += 1\n    return ans\n```",
        "sl_gold_code": "vector<int> lastVisitedIntegers(vector<string> &words) {\n    vector<int> ans, a;\n    int k = 0;\n    for (auto &s: words) {\n        if (s[0] != 'p') { \n            a.push_back(stoi(s));\n            k = 0;\n        } else {\n            ans.push_back(++k > a.size() ? -1 : a[a.size() - k]); \n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    k = 0\n    for s in words:\n        if s[0] != 'p':  \n            nums.append(int(s))\n            k = 0\n        else:\n            k += 1\n            ans.append(-1 if k > len(nums) else nums[-k])  \n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 13,
        "prediction_id": 0,
        "pro_prediction": "def minOperations(s1: str, s2: str, x: int) -> int:\n    if s1 == s2:\n        return 0\n    p = []\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            p.append(i)\n    if len(p) % 2:\n        return -1\n    f0, f1 = 0, x\n    for i in range(1, len(p)):\n        new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)\n        f0, f1 = f1, new_f\n    return f1 // 2",
        "main_fun_name": "minOperations",
        "raw_prediction": "```python\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    if s1 == s2:\n        return 0\n    p = []\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            p.append(i)\n    if len(p) % 2:\n        return -1\n    f0, f1 = 0, x\n    for i in range(1, len(p)):\n        new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)\n        f0, f1 = f1, new_f\n    return f1 // 2\n```",
        "sl_gold_code": "int minOperations(string s1, string s2, int x) {\n    if (s1 == s2) return 0;\n    vector<int> p;\n    for (int i = 0; i < s1.size(); i++)\n        if (s1[i] != s2[i])\n            p.push_back(i);\n    if (p.size() % 2) return -1;\n    int f0 = 0, f1 = x;\n    for (int i = 1; i < p.size(); i++) {\n        int new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2);\n        f0 = f1;\n        f1 = new_f;\n    }\n    return f1 / 2;\n}",
        "tl_gold_code": "def minOperations(s1, s2, x):\n    if s1 == s2:\n        return 0\n    p = [i for i in range(len(s1)) if s1[i] != s2[i]]\n    if len(p) % 2:\n        return -1\n    f0, f1 = 0, x\n    for i in range(1, len(p)):\n        new_f = min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)\n        f0, f1 = f1, new_f\n    return f1 // 2"
    },
    {
        "task": "c++_python",
        "problem_id": 14,
        "prediction_id": 0,
        "pro_prediction": "def minProcessingTime(processorTime: List[int], tasks: List[int]) -> int:\n    processorTime.sort()\n    tasks.sort(reverse=True)\n    ans = 0\n    for i in range(len(processorTime)):\n        ans = max(ans, processorTime[i] + tasks[i * 4])\n    return ans",
        "main_fun_name": "minProcessingTime",
        "raw_prediction": "```python\nfrom typing import List\n\ndef minProcessingTime(processorTime: List[int], tasks: List[int]) -> int:\n    processorTime.sort()\n    tasks.sort(reverse=True)\n    ans = 0\n    for i in range(len(processorTime)):\n        ans = max(ans, processorTime[i] + tasks[i * 4])\n    return ans\n```",
        "sl_gold_code": "int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {\n    sort(processorTime.begin(), processorTime.end());\n    sort(tasks.begin(), tasks.end(), greater<int>());\n    int ans = 0;\n    for (int i = 0; i < processorTime.size(); i++) {\n        ans = max(ans, processorTime[i] + tasks[i * 4]);\n    }\n    return ans;\n}",
        "tl_gold_code": "def minProcessingTime(processorTime: List[int], tasks: List[int]) -> int:\n        processorTime.sort()\n        tasks.sort(reverse=True)\n        return max(p + t for p, t in zip(processorTime, tasks[::4]))"
    },
    {
        "task": "c++_python",
        "problem_id": 15,
        "prediction_id": 0,
        "pro_prediction": "def differenceOfSums(n: int, m: int) -> int:\n    return n * (n + 1) // 2 - n // m * (n // m + 1) * m",
        "main_fun_name": "differenceOfSums",
        "raw_prediction": "```python\ndef differenceOfSums(n: int, m: int) -> int:\n    return n * (n + 1) // 2 - n // m * (n // m + 1) * m\n```",
        "sl_gold_code": "int differenceOfSums(int n, int m) {\n    return n * (n + 1) / 2 - n / m * (n / m + 1) * m;\n}",
        "tl_gold_code": "def differenceOfSums(n: int, m: int) -> int:\n        return n * (n + 1) // 2 - n // m * (n // m + 1) * m"
    },
    {
        "task": "c++_python",
        "problem_id": 16,
        "prediction_id": 0,
        "pro_prediction": "def minSizeSubarray(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    n = len(nums)\n    ans = float('inf')\n    left = 0\n    sum = 0\n    for right in range(n * 2):\n        sum += nums[right % n]\n        while sum > target % total:\n            sum -= nums[left % n]\n            left += 1\n        if sum == target % total:\n            ans = min(ans, right - left + 1)\n    return -1 if ans == float('inf') else ans + target // total * n",
        "main_fun_name": "minSizeSubarray",
        "raw_prediction": "```python\nfrom typing import List\n\ndef minSizeSubarray(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    n = len(nums)\n    ans = float('inf')\n    left = 0\n    sum = 0\n    for right in range(n * 2):\n        sum += nums[right % n]\n        while sum > target % total:\n            sum -= nums[left % n]\n            left += 1\n        if sum == target % total:\n            ans = min(ans, right - left + 1)\n    return -1 if ans == float('inf') else ans + target // total * n\n```",
        "sl_gold_code": "int minSizeSubarray(vector<int> &nums, int target) {\n    long long total = accumulate(nums.begin(), nums.end(), 0LL);\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    long long sum = 0;\n    for (int right = 0; right < n * 2; right++) {\n        sum += nums[right % n];\n        while (sum > target % total) {\n            sum -= nums[left++ % n];\n        }\n        if (sum == target % total) {\n            ans = min(ans, right - left + 1);\n        }\n    }\n    return ans == INT_MAX ? -1 : ans + target / total * n;\n}",
        "tl_gold_code": "def minSizeSubarray(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    n = len(nums)\n    ans = inf\n    left = s = 0\n    for right in range(n * 2):\n        s += nums[right % n]\n        while s > target % total:\n            s -= nums[left % n]\n            left += 1\n        if s == target % total:\n            ans = min(ans, right - left + 1)\n    return ans + target // total * n if ans < inf else -1"
    },
    {
        "task": "c++_python",
        "problem_id": 17,
        "prediction_id": 0,
        "pro_prediction": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = 0\n    pre_max = nums[0]\n    for j in range(1, n - 1):\n        ans = max(ans, (pre_max - nums[j]) * suf_max[j + 1])\n        pre_max = max(pre_max, nums[j])\n    return ans",
        "main_fun_name": "maximumTripletValue",
        "raw_prediction": "```python\nfrom typing import List\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = 0\n    pre_max = nums[0]\n    for j in range(1, n - 1):\n        ans = max(ans, (pre_max - nums[j]) * suf_max[j + 1])\n        pre_max = max(pre_max, nums[j])\n    return ans\n```",
        "sl_gold_code": "long long maximumTripletValue(vector<int> &nums) {\n    int n = nums.size();\n    vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = max(pre_max, nums[j]);\n    }\n    return ans;\n}",
        "tl_gold_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 18,
        "prediction_id": 0,
        "pro_prediction": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = 0\n    pre_max = nums[0]\n    for j in range(1, n - 1):\n        ans = max(ans, (pre_max - nums[j]) * suf_max[j + 1])\n        pre_max = max(pre_max, nums[j])\n    return ans",
        "main_fun_name": "maximumTripletValue",
        "raw_prediction": "```python\nfrom typing import List\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = 0\n    pre_max = nums[0]\n    for j in range(1, n - 1):\n        ans = max(ans, (pre_max - nums[j]) * suf_max[j + 1])\n        pre_max = max(pre_max, nums[j])\n    return ans\n```",
        "sl_gold_code": "long long maximumTripletValue(vector<int> &nums) {\n    int n = nums.size();\n    vector<int> suf_max(n + 1, 0);\n    for (int i = n - 1; i > 1; i--) {\n        suf_max[i] = max(suf_max[i + 1], nums[i]);\n    }\n    long long ans = 0;\n    int pre_max = nums[0];\n    for (int j = 1; j < n - 1; j++) {\n        ans = max(ans, (long long) (pre_max - nums[j]) * suf_max[j + 1]);\n        pre_max = max(pre_max, nums[j]);\n    }\n    return ans;\n}",
        "tl_gold_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n = len(nums)\n    suf_max = [0] * (n + 1)\n    for i in range(n - 1, 1, -1):\n        suf_max[i] = max(suf_max[i + 1], nums[i])\n    ans = pre_max = 0\n    for j, x in enumerate(nums):\n        ans = max(ans, (pre_max - x) * suf_max[j + 1])\n        pre_max = max(pre_max, x)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 19,
        "prediction_id": 0,
        "pro_prediction": "def maxSubarrays(nums: List[int]) -> int:\n    ans = 0\n    a = -1\n    for x in nums:\n        a &= x\n        if a == 0:\n            ans += 1\n            a = -1\n    return max(ans, 1)",
        "main_fun_name": "maxSubarrays",
        "raw_prediction": "```python\nfrom typing import List\n\ndef maxSubarrays(nums: List[int]) -> int:\n    ans = 0\n    a = -1\n    for x in nums:\n        a &= x\n        if a == 0:\n            ans += 1\n            a = -1\n    return max(ans, 1)\n```",
        "sl_gold_code": "int maxSubarrays(vector<int> &nums) {\n    int ans = 0;\n    int a = -1; \n    for (int x : nums) {\n        a &= x;\n        if (a == 0) {\n            ans++; \n            a = -1;\n        }\n    }\n    return max(ans, 1); \n}",
        "tl_gold_code": "def maxSubarrays(nums: List[int]) -> int:\n    ans = 0\n    a = -1\n    for x in nums:\n        a &= x\n        if a == 0:\n            ans += 1 \n            a = -1\n    return max(ans, 1)"
    },
    {
        "task": "c++_python",
        "problem_id": 20,
        "prediction_id": 0,
        "pro_prediction": "def minOperations(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    ans = 0\n    for c in cnt.values():\n        if c == 1:\n            return -1\n        ans += (c + 2) // 3\n    return ans",
        "main_fun_name": "minOperations",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import Counter\n\ndef minOperations(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    ans = 0\n    for c in cnt.values():\n        if c == 1:\n            return -1\n        ans += (c + 2) // 3\n    return ans\n```",
        "sl_gold_code": "int minOperations(vector<int> &nums) {\n    unordered_map<int, int> cnt;\n    for (int x : nums) {\n        cnt[x]++;\n    }\n    int ans = 0;\n    for (auto &[_, c] : cnt) {\n        if (c == 1) {\n            return -1;\n        }\n        ans += (c + 2) / 3;\n    }\n    return ans;\n}",
        "tl_gold_code": "def minOperations(nums):\n    cnt = {}\n    for x in nums:\n        cnt[x] = cnt.get(x, 0) + 1\n    ans = 0\n    for c in cnt.values():\n        if c == 1:\n            return -1\n        ans += (c + 2) // 3\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 21,
        "prediction_id": 0,
        "pro_prediction": "def minOperations(nums: List[int], k: int) -> int:\n    n = len(nums)\n    u = (2 << k) - 2\n    s = 0\n    for i in range(n - 1, -1, -1):\n        s |= 1 << nums[i]\n        if (s & u) == u:\n            return n - i",
        "main_fun_name": "minOperations",
        "raw_prediction": "```python\ndef minOperations(nums: List[int], k: int) -> int:\n    n = len(nums)\n    u = (2 << k) - 2\n    s = 0\n    for i in range(n - 1, -1, -1):\n        s |= 1 << nums[i]\n        if (s & u) == u:\n            return n - i\n```",
        "sl_gold_code": "int minOperations(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    long long u = (2LL << k) - 2;\n    long long s = 0;\n    for (int i = n - 1; ; --i) {\n        s |= 1LL << nums[i];\n        if ((s & u) == u) {\n            return n - i;\n        }\n    }\n}",
        "tl_gold_code": "def minOperations(nums: List[int], k: int) -> int:\n    u = (2 << k) - 2  \n    s, n = 0, len(nums)\n    for i in range(n - 1, -1, -1):\n        s |= 1 << nums[i]\n        if (s & u) == u:\n            return n - i"
    },
    {
        "task": "c++_python",
        "problem_id": 22,
        "prediction_id": 0,
        "pro_prediction": "def maxNumberOfAlloys(n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    ans = 0\n    mx = min(stock) + budget\n    for com in composition:\n        def check(num: int) -> bool:\n            money = 0\n            for i in range(n):\n                if stock[i] < com[i] * num:\n                    money += (com[i] * num - stock[i]) * cost[i]\n                    if money > budget:\n                        return False\n            return True\n        left, right = 0, mx + 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            (left if check(mid) else right) = mid\n        ans = max(ans, left)\n    return ans",
        "main_fun_name": "maxNumberOfAlloys",
        "raw_prediction": "```python\nfrom typing import List\nfrom functools import reduce\n\ndef maxNumberOfAlloys(n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    ans = 0\n    mx = min(stock) + budget\n    for com in composition:\n        def check(num: int) -> bool:\n            money = 0\n            for i in range(n):\n                if stock[i] < com[i] * num:\n                    money += (com[i] * num - stock[i]) * cost[i]\n                    if money > budget:\n                        return False\n            return True\n        left, right = 0, mx + 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            (left if check(mid) else right) = mid\n        ans = max(ans, left)\n    return ans\n```",
        "sl_gold_code": "int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>> &composition, vector<int> &stock, vector<int> &cost) {\n    int ans = 0;\n    int mx = *min_element(stock.begin(), stock.end()) + budget;\n    for (auto &com: composition) {\n        auto check = [&](long long num) -> bool {\n            long long money = 0;\n            for (int i = 0; i < n; i++) {\n                if (stock[i] < com[i] * num) {\n                    money += (com[i] * num - stock[i]) * cost[i];\n                    if (money > budget) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        int left = 0, right = mx + 1;\n        while (left + 1 < right) { \n            int mid = (left + right) / 2;\n            (check(mid) ? left : right) = mid;\n        }\n        ans = max(ans, left);\n    }\n    return ans;\n}",
        "tl_gold_code": "def maxNumberOfAlloys(n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    ans = 0\n    mx = min(stock) + budget\n    for com in composition:\n        def check(num: int) -> int:\n            money = 0\n            for s, base, c in zip(stock, com, cost):\n                if s < base * num:\n                    money += (base * num - s) * c\n                    if money > budget:\n                        return False\n            return True\n        left, right = 0, mx + 1\n        while left + 1 < right:  \n            mid = (left + right) // 2\n            if check(mid):\n                left = mid\n            else:\n                right = mid\n        ans = max(ans, left)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 23,
        "prediction_id": 0,
        "pro_prediction": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = nums[0] > 0\n    for i in range(n - 1):\n        if nums[i] < i + 1 and i + 1 < nums[i + 1]:\n            ans += 1\n    return ans + 1",
        "main_fun_name": "countWays",
        "raw_prediction": "```python\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = nums[0] > 0\n    for i in range(n - 1):\n        if nums[i] < i + 1 and i + 1 < nums[i + 1]:\n            ans += 1\n    return ans + 1\n```",
        "sl_gold_code": "int countWays(vector<int> &nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    int ans = nums[0] > 0; \n    for (int i = 0; i < n - 1; i++) {\n        if (nums[i] < i + 1 && i + 1 < nums[i + 1]) {\n            ans++;\n        }\n    }\n    return ans + 1;\n}",
        "tl_gold_code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = nums[0] > 0  \n    for i, (x, y) in enumerate(pairwise(nums)):\n        if x < i + 1 < y:\n            ans += 1\n    return ans + 1"
    },
    {
        "task": "c++_python",
        "problem_id": 24,
        "prediction_id": 0,
        "pro_prediction": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        if bin(i).count('1') == k:\n            ans += nums[i]\n    return ans",
        "main_fun_name": "sumIndicesWithKSetBits",
        "raw_prediction": "```python\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        if bin(i).count('1') == k:\n            ans += nums[i]\n    return ans\n```",
        "sl_gold_code": "int sumIndicesWithKSetBits(vector<int> &nums, int k) {\n    int ans = 0, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (__builtin_popcount(i) == k) {\n            ans += nums[i];\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def sumIndicesWithKSetBits(nums, k):\n    ans = 0\n    for i in range(len(nums)):\n        if bin(i).count('1') == k:\n            ans += nums[i]\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 25,
        "prediction_id": 0,
        "pro_prediction": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    ans = 0\n    cnt = defaultdict(int)\n    for p in coordinates:\n        for i in range(k + 1):\n            it = (p[0] ^ i) * 2000000 + (p[1] ^ (k - i))\n            ans += cnt[it]\n        cnt[p[0] * 2000000 + p[1]] += 1\n    return ans",
        "main_fun_name": "countPairs",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    ans = 0\n    cnt = defaultdict(int)\n    for p in coordinates:\n        for i in range(k + 1):\n            it = (p[0] ^ i) * 2000000 + (p[1] ^ (k - i))\n            ans += cnt[it]\n        cnt[p[0] * 2000000 + p[1]] += 1\n    return ans\n```",
        "sl_gold_code": "int countPairs(vector<vector<int>> &coordinates, int k) {\n    int ans = 0;\n    unordered_map<long long, int> cnt;\n    for (auto &p: coordinates) {\n        for (int i = 0; i <= k; i++) {\n            auto it = cnt.find((p[0] ^ i) * 2000000LL + (p[1] ^ (k - i)));\n            if (it != cnt.end()) {\n                ans += it->second;\n            }\n        }\n        cnt[p[0] * 2000000LL + p[1]]++;\n    }\n    return ans;\n}",
        "tl_gold_code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    ans = 0\n    cnt = Counter()\n    for x, y in coordinates:\n        for i in range(k + 1):\n            ans += cnt[x ^ i, y ^ (k - i)]  \n        cnt[x, y] += 1  \n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 26,
        "prediction_id": 0,
        "pro_prediction": "def minimumRightShifts(nums: List[int]) -> int:\n    i = 1\n    n = len(nums)\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i == n:\n        return 0\n    if nums[0] < nums[n - 1]:\n        return -1\n    mid = i\n    i += 1\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i < n:\n        return -1\n    return n - mid",
        "main_fun_name": "minimumRightShifts",
        "raw_prediction": "```python\ndef minimumRightShifts(nums: List[int]) -> int:\n    i = 1\n    n = len(nums)\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i == n:\n        return 0\n    if nums[0] < nums[n - 1]:\n        return -1\n    mid = i\n    i += 1\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i < n:\n        return -1\n    return n - mid\n```",
        "sl_gold_code": "int minimumRightShifts(vector<int>& nums) {\n    int i = 1;\n    int n = nums.size();\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i == n) {\n        return 0;\n    }\n    if (nums[0] < nums[n - 1]) {\n        return -1;\n    }\n    int mid = i;\n    i++;\n    while (i < n && nums[i - 1] < nums[i]) {\n        i++;\n    }\n    if (i < n) {\n        return -1;\n    }\n    return n - mid;\n}",
        "tl_gold_code": "def minimumRightShifts(nums: List[int]) -> int:\n    i, n = 1, len(nums)\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i == n:\n        return 0\n    if nums[0] < nums[-1]:\n        return -1\n    mid = i\n    i += 1\n    while i < n and nums[i - 1] < nums[i]:\n        i += 1\n    if i < n:\n        return -1\n    return n - mid"
    },
    {
        "task": "c++_python",
        "problem_id": 27,
        "prediction_id": 0,
        "pro_prediction": "def minLengthAfterRemovals(nums):\n    maxCnt = 0\n    cnt = 1\n    pre = nums[0]\n    n = len(nums)\n    for i in range(1, n):\n        if pre == nums[i]:\n            cnt += 1\n        else:\n            maxCnt = max(maxCnt, cnt)\n            pre = nums[i]\n            cnt = 1\n    maxCnt = max(maxCnt, cnt)\n    if maxCnt * 2 > n:\n        return maxCnt - (n - maxCnt)\n    else:\n        if n % 2 == 0:\n            return 0\n        else:\n            return 1",
        "main_fun_name": "minLengthAfterRemovals",
        "raw_prediction": "```python\ndef minLengthAfterRemovals(nums):\n    maxCnt = 0\n    cnt = 1\n    pre = nums[0]\n    n = len(nums)\n    for i in range(1, n):\n        if pre == nums[i]:\n            cnt += 1\n        else:\n            maxCnt = max(maxCnt, cnt)\n            pre = nums[i]\n            cnt = 1\n    maxCnt = max(maxCnt, cnt)\n    if maxCnt * 2 > n:\n        return maxCnt - (n - maxCnt)\n    else:\n        if n % 2 == 0:\n            return 0\n        else:\n            return 1\n```",
        "sl_gold_code": "int minLengthAfterRemovals(vector<int> &nums) {\n    int maxCnt = 0, cnt = 1, pre = nums[0];\n    int n = nums.size();\n    for(int i = 1; i < n; ++i) {\n        if(pre == nums[i]) cnt++;\n        else {\n            maxCnt = max(maxCnt, cnt);\n            pre = nums[i];\n            cnt = 1;\n        }\n    }\n    maxCnt = max(maxCnt, cnt);\n    if(maxCnt * 2 > n) return maxCnt - (n - maxCnt);\n    else {\n        if(n % 2 == 0) return 0;\n        else return 1;\n    }\n}",
        "tl_gold_code": "def minLengthAfterRemovals(nums):\n    maxCnt = cnt = 1\n    pre = nums[0]\n    n = len(nums)\n    for i in range(1, n):\n        if pre == nums[i]:\n            cnt += 1\n        else:\n            maxCnt = max(maxCnt, cnt)\n            pre = nums[i]\n            cnt = 1\n    maxCnt = max(maxCnt, cnt)\n    if maxCnt * 2 > n:\n        return maxCnt - (n - maxCnt)\n    else:\n        return 0 if n % 2 == 0 else 1"
    },
    {
        "task": "c++_python",
        "problem_id": 28,
        "prediction_id": 0,
        "pro_prediction": "def numberOfPoints(nums: List[List[int]]) -> int:\n    diff = [0] * 102\n    for p in nums:\n        diff[p[0]] += 1\n        diff[p[1] + 1] -= 1\n    ans = s = 0\n    for d in diff:\n        s += d\n        ans += s > 0\n    return ans",
        "main_fun_name": "numberOfPoints",
        "raw_prediction": "```python\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    diff = [0] * 102\n    for p in nums:\n        diff[p[0]] += 1\n        diff[p[1] + 1] -= 1\n    ans = s = 0\n    for d in diff:\n        s += d\n        ans += s > 0\n    return ans\n```",
        "sl_gold_code": "int numberOfPoints(vector<vector<int>> &nums) {\n    int diff[102]{};\n    for (auto &p: nums) {\n        diff[p[0]]++;\n        diff[p[1] + 1]--;\n    }\n    int ans = 0, s = 0;\n    for (int d: diff) {\n        s += d;\n        ans += s > 0;\n    }\n    return ans;\n}",
        "tl_gold_code": "def numberOfPoints(nums):\n    diff = [0] * 102\n    for p in nums:\n        diff[p[0]] += 1\n        diff[p[1] + 1] -= 1\n    ans = s = 0\n    for d in diff:\n        s += d\n        ans += s > 0\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 29,
        "prediction_id": 0,
        "pro_prediction": "def isReachableAtTime(sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n    if sx == fx and sy == fy:\n        return t != 1\n    return max(abs(sx - fx), abs(sy - fy)) <= t",
        "main_fun_name": "isReachableAtTime",
        "raw_prediction": "```python\ndef isReachableAtTime(sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n    if sx == fx and sy == fy:\n        return t != 1\n    return max(abs(sx - fx), abs(sy - fy)) <= t\n```",
        "sl_gold_code": "bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    if (sx == fx && sy == fy)\n        return t != 1;\n    return max(abs(sx - fx), abs(sy - fy)) <= t;\n}",
        "tl_gold_code": "def isReachableAtTime(sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n    if sx == fx and sy == fy:\n        return t != 1\n    return max(abs(sx - fx), abs(sy - fy)) <= t"
    },
    {
        "task": "c++_python",
        "problem_id": 30,
        "prediction_id": 0,
        "pro_prediction": "def countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    ans = 0\n    preSum = [0] * (n + 1)\n    for i in range(n):\n        preSum[i + 1] = preSum[i] + (nums[i] % modulo == k)\n    map = defaultdict(int)\n    for i in range(n + 1):\n        ans += map[(preSum[i] % modulo - k + modulo) % modulo]\n        map[preSum[i] % modulo] += 1\n    return ans",
        "main_fun_name": "countInterestingSubarrays",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    ans = 0\n    preSum = [0] * (n + 1)\n    for i in range(n):\n        preSum[i + 1] = preSum[i] + (nums[i] % modulo == k)\n    map = defaultdict(int)\n    for i in range(n + 1):\n        ans += map[(preSum[i] % modulo - k + modulo) % modulo]\n        map[preSum[i] % modulo] += 1\n    return ans\n```",
        "sl_gold_code": "long countInterestingSubarrays(vector<int> nums, int modulo, int k) {\n    int n = nums.size();\n    long ans = 0;\n    vector<int> preSum(n+1);\n    for(int i=0;i<n;i++)\n        preSum[i+1] = preSum[i] + (nums[i] % modulo == k?1:0);\n    unordered_map<int,int> map;\n    for(int i=0;i<=n;i++){\n        if(map.count((preSum[i]%modulo - k + modulo)%modulo))\n            ans += map[(preSum[i]%modulo - k + modulo)%modulo];\n        map[preSum[i]%modulo]++;\n    }\n    return ans;\n}",
        "tl_gold_code": "def countInterestingSubarrays(nums, modulo, k):\n    n = len(nums)\n    ans = 0\n    preSum = [0] * (n + 1)\n    for i in range(n):\n        preSum[i+1] = preSum[i] + (1 if nums[i] % modulo == k else 0)\n    count_map = {}\n    for i in range(n + 1):\n        key = (preSum[i] % modulo - k + modulo) % modulo\n        if key in count_map:\n            ans += count_map[key]\n        count_map[preSum[i] % modulo] = count_map.get(preSum[i] % modulo, 0) + 1\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 31,
        "prediction_id": 0,
        "pro_prediction": "def minimumOperations(num: str) -> int:\n    len_num = len(num)\n    zero = len_num - 1 if '0' in num else len_num\n    return min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero)\n\n\ndef f(target: str, num: str) -> int:\n    i = num.rfind(target[1])\n    if i < 0:\n        return len(num)\n    i = num[:i].rfind(target[0])\n    if i < 0:\n        return len(num)\n    return len(num) - i - 2",
        "main_fun_name": "minimumOperations",
        "raw_prediction": "```python\ndef minimumOperations(num: str) -> int:\n    len_num = len(num)\n    zero = len_num - 1 if '0' in num else len_num\n    return min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero)\n\ndef f(target: str, num: str) -> int:\n    i = num.rfind(target[1])\n    if i < 0:\n        return len(num)\n    i = num[:i].rfind(target[0])\n    if i < 0:\n        return len(num)\n    return len(num) - i - 2\n```",
        "sl_gold_code": "int minimumOperations(string num) {\n    int len = num.length();\n    int zero = num.find(\"0\") != string::npos ? len - 1 : len;\n    return min({f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero});\n}\nint f(string target, string num) {\n    int i = num.rfind(target[1]);\n    if (i < 0) return num.length();\n    i = num.substr(0, i).rfind(target[0]);\n    if (i < 0) return num.length();\n    return num.length() - i - 2;\n}",
        "tl_gold_code": "def minimumOperations(num):\n    len_num = len(num)\n    zero = len_num - 1 if \"0\" in num else len_num\n    return min(f(\"00\", num), f(\"25\", num), f(\"50\", num), f(\"75\", num), zero)\ndef f(target, num):\n    try:\n        i = num.rfind(target[1])\n        if i < 0:\n            return len(num)\n        i = num[:i].rfind(target[0])\n        if i < 0:\n            return len(num)\n        return len(num) - i - 2\n    except IndexError:\n        return len(num)"
    },
    {
        "task": "c++_python",
        "problem_id": 32,
        "prediction_id": 0,
        "pro_prediction": "def countSymmetricIntegers(low: int, high: int) -> int:\n    ans = 0\n    for i in range(low, high + 1):\n        s = str(i)\n        n = len(s)\n        if n % 2 > 0:\n            continue\n        sum = 0\n        for j in range(n // 2):\n            sum += int(s[j])\n        for j in range(n // 2, n):\n            sum -= int(s[j])\n        if sum == 0:\n            ans += 1\n    return ans",
        "main_fun_name": "countSymmetricIntegers",
        "raw_prediction": "```python\ndef countSymmetricIntegers(low: int, high: int) -> int:\n    ans = 0\n    for i in range(low, high + 1):\n        s = str(i)\n        n = len(s)\n        if n % 2 > 0:\n            continue\n        sum = 0\n        for j in range(n // 2):\n            sum += int(s[j])\n        for j in range(n // 2, n):\n            sum -= int(s[j])\n        if sum == 0:\n            ans += 1\n    return ans\n```",
        "sl_gold_code": "int countSymmetricIntegers(int low, int high) {\n    int ans = 0;\n    for (int i = low; i <= high; i++) {\n        string s = to_string(i);\n        int n = s.length();\n        if (n % 2 > 0) {\n            continue;\n        }\n        int sum = 0;\n        for (int j = 0; j < n / 2; j++) {\n            sum += s[j];\n        }\n        for (int j = n / 2; j < n; j++) {\n            sum -= s[j];\n        }\n        if (sum == 0) {\n            ans++;\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def countSymmetricIntegers(low, high):\n    ans = 0\n    for i in range(low, high + 1):\n        s = str(i)\n        n = len(s)\n        if n % 2 > 0:\n            continue\n        sum = 0\n        for j in range(n // 2):\n            sum += int(s[j])\n        for j in range(n // 2, n):\n            sum -= int(s[j])\n        if sum == 0:\n            ans += 1\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 33,
        "prediction_id": 0,
        "pro_prediction": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = sum_ = 0\n    cnt = Counter()\n    for i in range(k - 1):\n        sum_ += nums[i]\n        cnt[nums[i]] += 1\n    for i in range(k - 1, len(nums)):\n        sum_ += nums[i]\n        cnt[nums[i]] += 1\n        if len(cnt) >= m:\n            ans = max(ans, sum_)\n        out = nums[i - k + 1]\n        sum_ -= out\n        if cnt[out] == 1:\n            del cnt[out]\n        else:\n            cnt[out] -= 1\n    return ans",
        "main_fun_name": "maxSum",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import Counter\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = sum_ = 0\n    cnt = Counter()\n    for i in range(k - 1):\n        sum_ += nums[i]\n        cnt[nums[i]] += 1\n    for i in range(k - 1, len(nums)):\n        sum_ += nums[i]\n        cnt[nums[i]] += 1\n        if len(cnt) >= m:\n            ans = max(ans, sum_)\n        out = nums[i - k + 1]\n        sum_ -= out\n        if cnt[out] == 1:\n            del cnt[out]\n        else:\n            cnt[out] -= 1\n    return ans\n```",
        "sl_gold_code": "long long maxSum(vector<int> &nums, int m, int k) {\n    long long ans = 0, sum = 0;\n    unordered_map<int, int> cnt;\n    for (int i = 0; i < k - 1; i++) { \n        sum += nums[i];\n        cnt[nums[i]]++;\n    }\n    for (int i = k - 1; i < nums.size(); i++) {\n        sum += nums[i]; \n        cnt[nums[i]]++;\n        if (cnt.size() >= m)\n            ans = max(ans, sum);\n        int out = nums[i - k + 1];\n        sum -= out; \n        if (--cnt[out] == 0)\n            cnt.erase(out);\n    }\n    return ans;\n}",
        "tl_gold_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    s = sum(nums[:k - 1])  \n    cnt = Counter(nums[:k - 1])\n    for out, in_ in zip(nums, nums[k - 1:]):\n        s += in_  \n        cnt[in_] += 1\n        if len(cnt) >= m:\n            ans = max(ans, s)\n        s -= out  \n        cnt[out] -= 1\n        if cnt[out] == 0:\n            del cnt[out]\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 34,
        "prediction_id": 0,
        "pro_prediction": "def checkStrings(s1: str, s2: str) -> bool:\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2",
        "main_fun_name": "checkStrings",
        "raw_prediction": "```python\ndef checkStrings(s1: str, s2: str) -> bool:\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2\n```",
        "sl_gold_code": "bool checkStrings(string s1, string s2) {\n    int cnt1[2][26]{}, cnt2[2][26]{};\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0;\n}",
        "tl_gold_code": "def checkStrings(s1, s2):\n    cnt1 = [[0] * 26, [0] * 26]\n    cnt2 = [[0] * 26, [0] * 26]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2"
    },
    {
        "task": "c++_python",
        "problem_id": 35,
        "prediction_id": 0,
        "pro_prediction": "def canBeEqual(s1: str, s2: str) -> bool:\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2",
        "main_fun_name": "canBeEqual",
        "raw_prediction": "```python\ndef canBeEqual(s1: str, s2: str) -> bool:\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2\n```",
        "sl_gold_code": "bool canBeEqual(string s1, string s2) {\n    int cnt1[2][26]{}, cnt2[2][26]{};\n    for (int i = 0; i < s1.length(); i++) {\n        cnt1[i % 2][s1[i] - 'a']++;\n        cnt2[i % 2][s2[i] - 'a']++;\n    }\n    return memcmp(cnt1, cnt2, sizeof(cnt1)) == 0;\n}",
        "tl_gold_code": "def canBeEqual(s1, s2):\n    cnt1 = [[0] * 26 for _ in range(2)]\n    cnt2 = [[0] * 26 for _ in range(2)]\n    for i in range(len(s1)):\n        cnt1[i % 2][ord(s1[i]) - ord('a')] += 1\n        cnt2[i % 2][ord(s2[i]) - ord('a')] += 1\n    return cnt1 == cnt2"
    },
    {
        "task": "c++_python",
        "problem_id": 36,
        "prediction_id": 0,
        "pro_prediction": "def furthestDistanceFromOrigin(moves: str) -> int:\n    cn = 0\n    ans = 0\n    for move in moves:\n        if move == 'L':\n            ans -= 1\n        elif move == 'R':\n            ans += 1\n        else:\n            cn += 1\n    return abs(ans) + cn",
        "main_fun_name": "furthestDistanceFromOrigin",
        "raw_prediction": "```python\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    cn = 0\n    ans = 0\n    for move in moves:\n        if move == 'L':\n            ans -= 1\n        elif move == 'R':\n            ans += 1\n        else:\n            cn += 1\n    return abs(ans) + cn\n```",
        "sl_gold_code": "int furthestDistanceFromOrigin(string moves) {\n    int cn = 0;\n    int ans = 0;\n    for (int i = 0; i < moves.length(); i++) {\n        if (moves[i] == 'L') {\n            ans--;\n        } else if (moves[i] == 'R') {\n            ans++;\n        } else {\n            cn++;\n        }\n    }\n    return abs(ans) + cn;\n}",
        "tl_gold_code": "def furthestDistanceFromOrigin(moves):\n    cn = 0\n    ans = 0\n    for i in range(len(moves)):\n        if moves[i] == 'L':\n            ans -= 1\n        elif moves[i] == 'R':\n            ans += 1\n        else:\n            cn += 1\n    return abs(ans) + cn"
    },
    {
        "task": "c++_python",
        "problem_id": 37,
        "prediction_id": 0,
        "pro_prediction": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    n, ans = len(nums), 0\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[nums[i]].append(i - len(pos[nums[i]]))\n    for ps in pos:\n        if len(ps) <= ans: continue\n        left = 0\n        for right in range(len(ps)):\n            while ps[right] - ps[left] > k: \n                left += 1\n            ans = max(ans, right - left + 1)\n    return ans",
        "main_fun_name": "longestEqualSubarray",
        "raw_prediction": "```python\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    n, ans = len(nums), 0\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[nums[i]].append(i - len(pos[nums[i]]))\n    for ps in pos:\n        if len(ps) <= ans: continue\n        left = 0\n        for right in range(len(ps)):\n            while ps[right] - ps[left] > k: \n                left += 1\n            ans = max(ans, right - left + 1)\n    return ans\n```",
        "sl_gold_code": "int longestEqualSubarray(vector<int> &nums, int k) {\n    int n = nums.size(), ans = 0;\n    vector<vector<int>> pos(n + 1);\n    for (int i = 0; i < n; i++)\n        pos[nums[i]].push_back(i - pos[nums[i]].size());\n    for (auto &ps: pos) {\n        if (ps.size() <= ans) continue;\n        int left = 0;\n        for (int right = 0; right < ps.size(); right++) {\n            while (ps[right] - ps[left] > k) \n                left++;\n            ans = max(ans, right - left + 1);\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    pos = [[] for _ in range(len(nums) + 1)]\n    for i, x in enumerate(nums):\n        pos[x].append(i - len(pos[x]))\n    ans = 0\n    for ps in pos:\n        if len(ps) <= ans: continue\n        left = 0\n        for right, p in enumerate(ps):\n            while p - ps[left] > k:  \n                left += 1\n            ans = max(ans, right - left + 1)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 38,
        "prediction_id": 0,
        "pro_prediction": "def isAcronym(words: List[str], s: str) -> bool:\n    if len(words) != len(s):\n        return False\n    for i in range(len(words)):\n        if words[i][0] != s[i]:\n            return False\n    return True",
        "main_fun_name": "isAcronym",
        "raw_prediction": "```python\ndef isAcronym(words: List[str], s: str) -> bool:\n    if len(words) != len(s):\n        return False\n    for i in range(len(words)):\n        if words[i][0] != s[i]:\n            return False\n    return True\n```",
        "sl_gold_code": "bool isAcronym(vector<string> &words, string s) {\n    if (words.size() != s.length())\n        return false;\n    for (int i = 0; i < words.size(); i++)\n        if (words[i][0] != s[i])\n            return false;\n    return true;\n}",
        "tl_gold_code": "def isAcronym(words, s):\n    if len(words) != len(s):\n        return False\n    for i in range(len(words)):\n        if words[i][0] != s[i]:\n            return False\n    return True"
    },
    {
        "task": "c++_python",
        "problem_id": 39,
        "prediction_id": 0,
        "pro_prediction": "def minimumSum(n: int, k: int) -> int:\n    m = min(k // 2, n)\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2",
        "main_fun_name": "minimumSum",
        "raw_prediction": "```python\ndef minimumSum(n: int, k: int) -> int:\n    m = min(k // 2, n)\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2\n```",
        "sl_gold_code": "int minimumSum(int n, int k) {\n    int m = min(k / 2, n);\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;\n}",
        "tl_gold_code": "def minimumSum(n: int, k: int) -> int:\n        m = min(k // 2, n)\n        return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2"
    },
    {
        "task": "c++_python",
        "problem_id": 40,
        "prediction_id": 0,
        "pro_prediction": "def minimumOperations(nums: List[int]) -> int:\n    g = []\n    for x in nums:\n        j = upperBound(g, x)\n        if j == len(g):\n            g.append(x)\n        else:\n            g[j] = x\n    return len(nums) - len(g)\n\n\ndef upperBound(g: List[int], target: int) -> int:\n    left = -1\n    right = len(g)\n    while left + 1 < right:\n        mid = left + (right - left) // 2\n        if g[mid] <= target:\n            left = mid\n        else:\n            right = mid\n    return right",
        "main_fun_name": "minimumOperations",
        "raw_prediction": "```python\nfrom typing import List\n\ndef minimumOperations(nums: List[int]) -> int:\n    g = []\n    for x in nums:\n        j = upperBound(g, x)\n        if j == len(g):\n            g.append(x)\n        else:\n            g[j] = x\n    return len(nums) - len(g)\n\ndef upperBound(g: List[int], target: int) -> int:\n    left = -1\n    right = len(g)\n    while left + 1 < right:\n        mid = left + (right - left) // 2\n        if g[mid] <= target:\n            left = mid\n        else:\n            right = mid\n    return right\n```",
        "sl_gold_code": "int minimumOperations(vector<int>& nums) {\n    vector<int> g;\n    for (int x : nums) {\n        int j = upperBound(g, x);\n        if (j == g.size()) g.push_back(x);\n        else g[j] = x;\n    }\n    return nums.size() - g.size();\n}\nint upperBound(vector<int>& g, int target) {\n    int left = -1;\n    int right = g.size();\n    while (left + 1 < right) {\n        int mid = left + (right - left) / 2;\n        if (g[mid] <= target)\n            left = mid;\n        else\n            right = mid;\n    }\n    return right;\n}",
        "tl_gold_code": "def minimumOperations(nums):\n    g = []\n    for x in nums:\n        j = upper_bound(g, x)\n        if j == len(g):\n            g.append(x)\n        else:\n            g[j] = x\n    return len(nums) - len(g)\ndef upper_bound(g, target):\n    left, right = -1, len(g)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if g[mid] <= target:\n            left = mid\n        else:\n            right = mid\n    return right"
    },
    {
        "task": "c++_python",
        "problem_id": 41,
        "prediction_id": 0,
        "pro_prediction": "def countPairs(nums: List[int], target: int) -> int:\n    nums.sort()\n    ans = 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            ans += right - left\n            left += 1\n        else:\n            right -= 1\n    return ans",
        "main_fun_name": "countPairs",
        "raw_prediction": "```python\nfrom typing import List\n\ndef countPairs(nums: List[int], target: int) -> int:\n    nums.sort()\n    ans = 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            ans += right - left\n            left += 1\n        else:\n            right -= 1\n    return ans\n```",
        "sl_gold_code": "int countPairs(vector<int> &nums, int target) {\n    sort(nums.begin(), nums.end());\n    int ans = 0, left = 0, right = nums.size() - 1;\n    while (left < right) {\n        if (nums[left] + nums[right] < target) {\n            ans += right - left;\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def countPairs(nums: List[int], target: int) -> int:\n    nums.sort()\n    ans = left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < target:\n            ans += right - left\n            left += 1\n        else:\n            right -= 1\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 42,
        "prediction_id": 0,
        "pro_prediction": "def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    ans = sys.maxsize\n    n = len(nums)\n    s = {-(sys.maxsize // 2), sys.maxsize}\n    for i in range(x, n):\n        s.add(nums[i - x])\n        y = nums[i]\n        it = sorted(s, key=lambda x: abs(x - y))[0]\n        ans = min(ans, min(it - y, y - it))\n    return ans",
        "main_fun_name": "minAbsoluteDifference",
        "raw_prediction": "```python\nfrom typing import List\nimport sys\n\ndef minAbsoluteDifference(nums: List[int], x: int) -> int:\n    ans = sys.maxsize\n    n = len(nums)\n    s = {-(sys.maxsize // 2), sys.maxsize}\n    for i in range(x, n):\n        s.add(nums[i - x])\n        y = nums[i]\n        it = sorted(s, key=lambda x: abs(x - y))[0]\n        ans = min(ans, min(it - y, y - it))\n    return ans\n```",
        "sl_gold_code": "int minAbsoluteDifference(vector<int> &nums, int x) {\n    int ans = INT_MAX, n = nums.size();\n    set<int> s = {INT_MIN / 2, INT_MAX}; \n    for (int i = x; i < n; i++) {\n        s.insert(nums[i - x]);\n        int y = nums[i];\n        auto it = s.lower_bound(y); \n        ans = min(ans, min(*it - y, y - *prev(it))); \n    }\n    return ans;\n}",
        "tl_gold_code": "def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    ans = float('inf') \n    pre = [float('inf')] \n    for i in range(len(nums)-x):\n        insort_left(pre, nums[i]) \n        index = bisect_left(pre, nums[i+x])\n        tmp = min(abs(pre[index]-nums[i+x]) for index in (index, index-1))\n        ans = min(ans, tmp)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 43,
        "prediction_id": 0,
        "pro_prediction": "def doubleIt(head: ListNode) -> ListNode:\n    if head.val > 4:\n        head = ListNode(0, head)\n    cur = head\n    while cur:\n        cur.val = cur.val * 2 % 10\n        if cur.next and cur.next.val > 4:\n            cur.val += 1\n        cur = cur.next\n    return head",
        "main_fun_name": "doubleIt",
        "raw_prediction": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef doubleIt(head: ListNode) -> ListNode:\n    if head.val > 4:\n        head = ListNode(0, head)\n    cur = head\n    while cur:\n        cur.val = cur.val * 2 % 10\n        if cur.next and cur.next.val > 4:\n            cur.val += 1\n        cur = cur.next\n    return head\n```",
        "sl_gold_code": "ListNode *doubleIt(ListNode *head) {\n    if (head->val > 4)\n        head = new ListNode(0, head);\n    for (auto cur = head; cur; cur = cur->next) {\n        cur->val = cur->val * 2 % 10;\n        if (cur->next && cur->next->val > 4)\n            cur->val++;\n    }\n    return head;\n}",
        "tl_gold_code": "def doubleIt(head: Optional[ListNode]) -> Optional[ListNode]:\n    if head.val > 4:\n        head = ListNode(0, head)\n    cur = head\n    while cur:\n        cur.val = cur.val * 2 % 10\n        if cur.next and cur.next.val > 4:\n            cur.val += 1\n        cur = cur.next\n    return head"
    },
    {
        "task": "c++_python",
        "problem_id": 44,
        "prediction_id": 0,
        "pro_prediction": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    max_val = [float('-inf')] * 10\n    for v in nums:\n        max_d = 0\n        for x in str(v):\n            max_d = max(max_d, int(x))\n        ans = max(ans, v + max_val[max_d])\n        max_val[max_d] = max(max_val[max_d], v)\n    return ans",
        "main_fun_name": "maxSum",
        "raw_prediction": "```python\ndef maxSum(nums: List[int]) -> int:\n    ans = -1\n    max_val = [float('-inf')] * 10\n    for v in nums:\n        max_d = 0\n        for x in str(v):\n            max_d = max(max_d, int(x))\n        ans = max(ans, v + max_val[max_d])\n        max_val[max_d] = max(max_val[max_d], v)\n    return ans\n```",
        "sl_gold_code": "int maxSum(vector<int> &nums) {\n    int ans = -1;\n    vector<int> max_val(10, INT_MIN);\n    for (int v: nums) {\n        int max_d = 0;\n        for (int x = v; x; x /= 10)\n            max_d = max(max_d, x % 10);\n        ans = max(ans, v + max_val[max_d]);\n        max_val[max_d] = max(max_val[max_d], v);\n    }\n    return ans;\n}",
        "tl_gold_code": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    max_val = [-inf] * 10\n    for v in nums:\n        max_d = max(map(int, str(v)))\n        ans = max(ans, v + max_val[max_d])\n        max_val[max_d] = max(max_val[max_d], v)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 45,
        "prediction_id": 0,
        "pro_prediction": "def finalString(s: str) -> str:\n    q = deque()\n    tail = True\n    for c in s:\n        if c == 'i':\n            tail = not tail\n        elif tail:\n            q.append(c)\n        else:\n            q.appendleft(c)\n    return ''.join(q) if tail else ''.join(reversed(q))",
        "main_fun_name": "finalString",
        "raw_prediction": "```python\nfrom collections import deque\n\ndef finalString(s: str) -> str:\n    q = deque()\n    tail = True\n    for c in s:\n        if c == 'i':\n            tail = not tail\n        elif tail:\n            q.append(c)\n        else:\n            q.appendleft(c)\n    return ''.join(q) if tail else ''.join(reversed(q))\n```",
        "sl_gold_code": "string finalString(string s) {\n    deque<char> q;\n    bool tail = true;\n    for (char c: s) {\n        if (c == 'i') tail = !tail;\n        else if (tail) q.push_back(c);\n        else q.push_front(c);\n    }\n    return tail ? string(q.begin(), q.end()) : string(q.rbegin(), q.rend());\n}",
        "tl_gold_code": "def finalString(s: str) -> str:\n    q = deque()\n    tail = True\n    for c in s:\n        if c == 'i':\n            tail = not tail  \n        elif tail:  \n            q.append(c)\n        else:  \n            q.appendleft(c)\n    return ''.join(q if tail else reversed(q))"
    },
    {
        "task": "c++_python",
        "problem_id": 46,
        "prediction_id": 0,
        "pro_prediction": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False",
        "main_fun_name": "canSplitArray",
        "raw_prediction": "```python\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n```",
        "sl_gold_code": "bool canSplitArray(vector<int> &nums, int m) {\n    int n = nums.size();\n    if (n <= 2) return true;\n    for (int i = 1; i < n; i++)\n        if (nums[i - 1] + nums[i] >= m)\n            return true;\n    return false;\n}",
        "tl_gold_code": "def canSplitArray(nums, m):\n    n = len(nums)\n    if n <= 2: \n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False"
    },
    {
        "task": "c++_python",
        "problem_id": 47,
        "prediction_id": 0,
        "pro_prediction": "def longestAlternatingSubarray(a: List[int], threshold: int) -> int:\n    ans = 0\n    i = 0\n    n = len(a)\n    while i < n:\n        if a[i] % 2 or a[i] > threshold:\n            i += 1\n        else:\n            i0 = i\n            i += 1\n            while i < n and a[i] <= threshold and a[i] % 2 != a[i - 1] % 2:\n                i += 1\n            ans = max(ans, i - i0)\n    return ans",
        "main_fun_name": "longestAlternatingSubarray",
        "raw_prediction": "```python\ndef longestAlternatingSubarray(a: List[int], threshold: int) -> int:\n    ans = 0\n    i = 0\n    n = len(a)\n    while i < n:\n        if a[i] % 2 or a[i] > threshold:\n            i += 1\n        else:\n            i0 = i\n            i += 1\n            while i < n and a[i] <= threshold and a[i] % 2 != a[i - 1] % 2:\n                i += 1\n            ans = max(ans, i - i0)\n    return ans\n```",
        "sl_gold_code": "int longestAlternatingSubarray(vector<int>& a, int threshold) {\n    int ans = 0;\n    int i = 0;\n    int n = a.size();\n    while (i < n) {\n        if (a[i] % 2 || a[i] > threshold) {\n            i += 1;\n        } else {\n            int i0 = i;\n            i += 1;\n            while (i < n && a[i] <= threshold && a[i] % 2 != a[i - 1] % 2) {\n                i += 1;\n            }\n            ans = max(ans, i - i0);\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def longestAlternatingSubarray(a: List[int], threshold: int) -> int:\n    ans, i, n = 0, 0, len(a)\n    while i < n:\n        if a[i] % 2 or a[i] > threshold:\n            i += 1\n        else:\n            i0 = i\n            i += 1\n            while i < n and a[i] <= threshold and a[i] % 2 != a[i - 1] % 2:\n                i += 1 \n            ans = max(ans, i - i0)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 48,
        "prediction_id": 0,
        "pro_prediction": "def minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    umap = defaultdict(list)\n    for i in range(n):\n        umap[nums[i]].append(i)\n    ans = n\n    for v in umap.values():\n        v.append(v[0] + n)\n        mx = -1\n        for i in range(1, len(v)):\n            mx = max(mx, (v[i] - v[i - 1]) // 2)\n        ans = min(ans, mx)\n    return ans",
        "main_fun_name": "minimumSeconds",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    umap = defaultdict(list)\n    for i in range(n):\n        umap[nums[i]].append(i)\n    ans = n\n    for v in umap.values():\n        v.append(v[0] + n)\n        mx = -1\n        for i in range(1, len(v)):\n            mx = max(mx, (v[i] - v[i - 1]) // 2)\n        ans = min(ans, mx)\n    return ans\n```",
        "sl_gold_code": "int minimumSeconds(vector<int>& nums) {\n    int n = nums.size();\n    unordered_map<int, vector<int>> umap;\n    for (int i = 0; i < n; i++) {\n        umap[nums[i]].push_back(i);\n    }\n    int ans = n;\n    for (auto &iter : umap) {\n        auto &v = iter.second;\n        v.push_back(v[0] + n);\n        int mx = - 1;\n        for (int i = 1; i < v.size(); i++) {\n            mx = max(mx, (v[i] - v[i - 1]) / 2);\n        }\n        ans = min(ans, mx);\n    }\n    return ans;\n}",
        "tl_gold_code": "def minimumSeconds(nums: List[int]) -> int:\n    pos = defaultdict(list)\n    for i, x in enumerate(nums):\n        pos[x].append(i)\n    ans = n = len(nums)\n    for a in pos.values():\n        a.append(a[0] + n)\n        mx = max((j - i) // 2 for i, j in pairwise(a))\n        ans = min(ans, mx)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 49,
        "prediction_id": 0,
        "pro_prediction": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for h in hours:\n        ans += h >= target\n    return ans",
        "main_fun_name": "numberOfEmployeesWhoMetTarget",
        "raw_prediction": "```python\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for h in hours:\n        ans += h >= target\n    return ans\n```",
        "sl_gold_code": "int numberOfEmployeesWhoMetTarget(vector<int> &hours, int target) {\n    int ans = 0;\n    for (int h: hours) {\n        ans += h >= target;\n    }\n    return ans;\n}",
        "tl_gold_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n        ans = 0\n        for h in hours:\n                if h >= target:\n                        ans += 1\n        return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 50,
        "prediction_id": 0,
        "pro_prediction": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    def func(s: str):\n        t = \"\"\n        for i in s:\n            if i == ' ':\n                continue\n            if i == separator:\n                if t:\n                    ans.append(t)\n                t = \"\"\n            else:\n                t += i\n        if t:\n            ans.append(t)\n    for i in words:\n        func(i)\n    return ans",
        "main_fun_name": "splitWordsBySeparator",
        "raw_prediction": "```python\nfrom typing import List\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    def func(s: str):\n        t = \"\"\n        for i in s:\n            if i == ' ':\n                continue\n            if i == separator:\n                if t:\n                    ans.append(t)\n                t = \"\"\n            else:\n                t += i\n        if t:\n            ans.append(t)\n    for i in words:\n        func(i)\n    return ans\n```",
        "sl_gold_code": "vector<string> splitWordsBySeparator(vector<string>& words, char separator) {\n    vector<string> ans; \n    function<void(string)> func = [&](string str){\n        string t=\"\";\n        for(char i:str){\n            if(i==' ')continue;\n            if(i==separator){\n                if(t.size())ans.push_back(t);\n                t=\"\";\n            }else t+=i;\n        }\n        if(t.size())ans.push_back(t);\n    };\n    for(auto i:words){\n        func(i);\n    }\n    return ans;\n}",
        "tl_gold_code": "def splitWordsBySeparator(words, separator):\n    ans = []\n    def func(str):\n        t = \"\"\n        for i in str:\n            if i == ' ':\n                continue\n            if i == separator:\n                if t:\n                    ans.append(t)\n                t = \"\"\n            else:\n                t += i\n        if t:\n            ans.append(t)\n\n    for i in words:\n        func(i)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 51,
        "prediction_id": 0,
        "pro_prediction": "def miniMaxSum(a: List[int]) -> List[int]:\n    sum = sum(a)\n    max_val = max(a)\n    min_val = min(a)\n    return [sum - max_val, sum - min_val]",
        "main_fun_name": "miniMaxSum",
        "raw_prediction": "```python\nfrom typing import List\n\ndef miniMaxSum(a: List[int]) -> List[int]:\n    sum = sum(a)\n    max_val = max(a)\n    min_val = min(a)\n    return [sum - max_val, sum - min_val]\n```",
        "sl_gold_code": "vector<long> miniMaxSum(vector<int>& a) {\n    long long sum = std::accumulate(a.begin(), a.end(), 0LL);\n    int max = *std::max_element(a.begin(), a.end());\n    int min = *std::min_element(a.begin(), a.end());\n    return {sum - max, sum - min};\n}",
        "tl_gold_code": "def miniMaxSum(a):\n    s = sum(a)\n    max_ = max(a)\n    min_ = min(a)\n    return [s - max_, s - min_]"
    },
    {
        "task": "c++_python",
        "problem_id": 52,
        "prediction_id": 0,
        "pro_prediction": "def pickingNumbers(a: List[int]) -> int:\n    d = defaultdict(int)\n    for num in a:\n        d[num] += 1\n    best = 0\n    for i in range(99):\n        best = max(d[i] + d[i + 1], best)\n    return best",
        "main_fun_name": "pickingNumbers",
        "raw_prediction": "```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef pickingNumbers(a: List[int]) -> int:\n    d = defaultdict(int)\n    for num in a:\n        d[num] += 1\n    best = 0\n    for i in range(99):\n        best = max(d[i] + d[i + 1], best)\n    return best\n```",
        "sl_gold_code": "int pickingNumbers(const vector<int>& a) {\n    unordered_map<int, int> d;\n    for (int num : a) {\n        ++d[num];\n    }\n    int best = 0;\n    for (int i = 0; i < 99; ++i) {\n        best = max(d[i] + d[i + 1], best);\n    }\n    return best;\n}",
        "tl_gold_code": "def pickingNumbers(a):\n    from collections import Counter\n    d = Counter(a)\n    best = 0\n    for i in range(99):\n        best = max(d[i] + d[i+1], best)\n    return best"
    },
    {
        "task": "c++_python",
        "problem_id": 53,
        "prediction_id": 0,
        "pro_prediction": "def summingSeries(n: int) -> int:\n    return ((n % 1000000007) * (n % 1000000007)) % 1000000007",
        "main_fun_name": "summingSeries",
        "raw_prediction": "```python\ndef summingSeries(n: int) -> int:\n    return ((n % 1000000007) * (n % 1000000007)) % 1000000007\n```",
        "sl_gold_code": "int summingSeries(long n) {\n  return ((n % 1000000007)*(n % 1000000007)) % 1000000007;\n}",
        "tl_gold_code": "def summingSeries(n):\n    return (n*n) % 1000000007"
    },
    {
        "task": "c++_python",
        "problem_id": 54,
        "prediction_id": 0,
        "pro_prediction": "def matchingStrings(stringList: List[str], queries: List[str]) -> List[int]:\n    arr = []\n    for i in queries:\n        k = 0\n        for j in stringList:\n            if i == j:\n                k += 1\n        arr.append(k)\n    return arr",
        "main_fun_name": "matchingStrings",
        "raw_prediction": "```python\nfrom typing import List\n\ndef matchingStrings(stringList: List[str], queries: List[str]) -> List[int]:\n    arr = []\n    for i in queries:\n        k = 0\n        for j in stringList:\n            if i == j:\n                k += 1\n        arr.append(k)\n    return arr\n```",
        "sl_gold_code": "vector<int> matchingStrings(const vector<string>& stringList, const vector<string>& queries) {\n    vector<int> arr;\n    for (const auto& i : queries) {\n        int k = 0;\n        for (const auto& j : stringList) {\n            if (i == j) {\n                ++k;\n            }\n        }\n        arr.push_back(k);\n    }\n    return arr;\n}",
        "tl_gold_code": "def matchingStrings(stringList, queries):\n    k = 0\n    arr = []\n    for i in queries:\n        for j in stringList:\n            if i == j:\n                k += 1\n        arr.append(k)\n        k = 0\n        \n    return [i for i in arr]"
    },
    {
        "task": "c++_python",
        "problem_id": 55,
        "prediction_id": 0,
        "pro_prediction": "def climbingLeaderboard(ranked: List[int], player: List[int]) -> List[int]:\n    rank_set = set(ranked)\n    rank_nums = sorted(list(rank_set), reverse=True)\n    result = []\n    for score in player:\n        rank = bsearch(rank_nums, score)\n        result.append(rank)\n    return result\n\ndef bsearch(arr: List[int], x: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n    while low <= high:\n        mid = low + (high - low) // 2\n        if arr[mid] < x:\n            high = mid - 1\n        elif arr[mid] > x:\n            low = mid + 1\n        else:\n            return mid + 1\n    return low + 1\n",
        "main_fun_name": "climbingLeaderboard",
        "raw_prediction": "```python\nfrom typing import List\n\ndef bsearch(arr: List[int], x: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n    while low <= high:\n        mid = low + (high - low) // 2\n        if arr[mid] < x:\n            high = mid - 1\n        elif arr[mid] > x:\n            low = mid + 1\n        else:\n            return mid + 1\n    return low + 1\n\ndef climbingLeaderboard(ranked: List[int], player: List[int]) -> List[int]:\n    rank_set = set(ranked)\n    rank_nums = sorted(list(rank_set), reverse=True)\n    result = []\n    for score in player:\n        rank = bsearch(rank_nums, score)\n        result.append(rank)\n    return result\n```",
        "sl_gold_code": "int bsearch(const vector<int>& arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    int mid = 0;\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n        if (arr[mid] < x) {\n            high = mid - 1;\n        } else if (arr[mid] > x) {\n            low = mid + 1;\n        } else {\n            return mid + 1;\n        }\n    }\n    return low + 1;\n}\nvector<int> climbingLeaderboard(vector<int>& ranked, const vector<int>& player) {\n    unordered_set<int> rank_set(ranked.begin(), ranked.end());\n    vector<int> rank_nums(rank_set.begin(), rank_set.end());\n    sort(rank_nums.begin(), rank_nums.end(), greater<int>());\n    vector<int> result;\n    for (int score : player) {\n        int rank = bsearch(rank_nums, score);\n        result.push_back(rank);\n    }\n    return result;\n}",
        "tl_gold_code": "def bsearch(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0  # ranking\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] > x:\n            low = mid + 1\n        elif arr[mid] < x:\n            high = mid - 1\n        else:\n            return mid + 1\n    return low + 1\ndef climbingLeaderboard(ranked, player):\n    from collections import OrderedDict\n    rank_nums = list(OrderedDict.fromkeys(ranked))\n    result = []\n    for score in player:\n        rank = bsearch(rank_nums, score)\n        result.append(rank)\n    return result"
    },
    {
        "task": "c++_python",
        "problem_id": 56,
        "prediction_id": 0,
        "pro_prediction": "def arrayManipulation(n: int, queries: List[List[int]]) -> int:\n    arr = [0] * (n + 2)\n    max_val = 0\n    curr_sum = 0\n\n    for query in queries:\n        arr[query[0]] += query[2]\n        arr[query[1] + 1] -= query[2]\n\n    for val in arr:\n        curr_sum += val\n        if curr_sum > max_val:\n            max_val = curr_sum\n            \n    return max_val",
        "main_fun_name": "arrayManipulation",
        "raw_prediction": "```python\nfrom typing import List\n\ndef arrayManipulation(n: int, queries: List[List[int]]) -> int:\n    arr = [0] * (n + 2)\n    max_val = 0\n    curr_sum = 0\n\n    for query in queries:\n        arr[query[0]] += query[2]\n        arr[query[1] + 1] -= query[2]\n\n    for val in arr:\n        curr_sum += val\n        if curr_sum > max_val:\n            max_val = curr_sum\n            \n    return max_val\n```",
        "sl_gold_code": "long arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long> arr(n + 2, 0);\n    long max = 0; long sum = 0;\n    for(auto query: queries){\n        arr[query[0]] += query[2];\n        arr[query[1] + 1] -= query[2];\n    }\n    for (auto val : arr){\n        sum += val;\n        if(sum > max) max = sum;\n    }\n    return max;\n}",
        "tl_gold_code": "def arrayManipulation(n, queries):\n    arr = [0] * (n + 2)\n    max_val = 0\n    sum_val = 0\n    \n    for query in queries:\n        arr[query[0]] += query[2]\n        arr[query[1] + 1] -= query[2]\n    \n    for val in arr:\n        sum_val += val\n        max_val = max(max_val, sum_val)\n        \n    return max_val"
    },
    {
        "task": "c++_python",
        "problem_id": 57,
        "prediction_id": 0,
        "pro_prediction": "def deleteNode(llist: ListNode, position: int) -> ListNode:\n    if not llist:\n        return None\n    if position == 0:\n        new_head = llist.next\n        del llist\n        return new_head\n    current = llist\n    for _ in range(position - 1):\n        if not current or not current.next:\n            return llist\n        current = current.next\n    if not current or not current.next:\n        return llist\n    node_to_delete = current.next\n    current.next = current.next.next\n    del node_to_delete\n    return llist",
        "main_fun_name": "deleteNode",
        "raw_prediction": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteNode(llist: ListNode, position: int) -> ListNode:\n    if not llist:\n        return None\n    if position == 0:\n        new_head = llist.next\n        del llist\n        return new_head\n    current = llist\n    for _ in range(position - 1):\n        if not current or not current.next:\n            return llist\n        current = current.next\n    if not current or not current.next:\n        return llist\n    node_to_delete = current.next\n    current.next = current.next.next\n    del node_to_delete\n    return llist\n```",
        "sl_gold_code": "ListNode* deleteNode(ListNode* llist, int position) {\n    if (llist == nullptr) {\n        return nullptr;\n    }\n    if (position == 0) {\n        ListNode* newHead = llist->next;\n        delete llist; \n        return newHead;\n    }\n    ListNode* current = llist;\n    for (int i = 0; current != nullptr && i < position - 1; ++i) {\n        current = current->next;\n    }\n    if (current == nullptr || current->next == nullptr) {\n        return llist;\n    }\n    ListNode* nodeToDelete = current->next;\n    current->next = current->next->next;\n    delete nodeToDelete; \n    return llist;\n}",
        "tl_gold_code": "def deleteNode(llist, position):\n    if not llist:\n        return \n    if position == 0:\n        return llist.next\n    current = previous = llist\n    pointer = 1\n    while pointer < position+1:\n        previous = current\n        current = current.next\n        pointer += 1\n    previous.next = current.next\n    return llist"
    },
    {
        "task": "c++_python",
        "problem_id": 58,
        "prediction_id": 0,
        "pro_prediction": "def evaluateTree(root: TreeNode) -> bool:\n    if not root.left:\n        return root.val\n    l = evaluateTree(root.left)\n    r = evaluateTree(root.right)\n    return root.val == 2 and (l or r) or (l and r)",
        "main_fun_name": "evaluateTree",
        "raw_prediction": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef evaluateTree(root: TreeNode) -> bool:\n    if not root.left:\n        return root.val\n    l = evaluateTree(root.left)\n    r = evaluateTree(root.right)\n    return root.val == 2 and (l or r) or (l and r)\n```",
        "sl_gold_code": "bool evaluateTree(TreeNode* root) {\n    if (!root->left) {\n        return root->val;\n    }\n    bool l = evaluateTree(root->left);\n    bool r = evaluateTree(root->right);\n    return root->val == 2 ? l or r : l and r;\n}",
        "tl_gold_code": "def evaluateTree(root: Optional[TreeNode]) -> bool:\n    if root.left is None:\n        return bool(root.val)\n    l = evaluateTree(root.left)\n    r = evaluateTree(root.right)\n    return l or r if root.val == 2 else l and r"
    },
    {
        "task": "c++_python",
        "problem_id": 59,
        "prediction_id": 0,
        "pro_prediction": "def andXorOr(a: List[int]) -> int:\n    m = 0\n    s = []\n    for i in a:\n        while s and s[-1] >= i:\n            m = max(m, i ^ s.pop())\n        if s:\n            m = max(m, i ^ s[-1])\n        s.append(i)\n    return m",
        "main_fun_name": "andXorOr",
        "raw_prediction": "```python\nfrom typing import List\n\ndef andXorOr(a: List[int]) -> int:\n    m = 0\n    s = []\n    for i in a:\n        while s and s[-1] >= i:\n            m = max(m, i ^ s.pop())\n        if s:\n            m = max(m, i ^ s[-1])\n        s.append(i)\n    return m\n```",
        "sl_gold_code": "int andXorOr(vector<int> &a) {\n    int m = 0;\n    stack<int> s;\n    for (int i : a) {\n        while (!s.empty() && s.top() >= i) {\n            m = max(m, i ^ s.top());\n            s.pop();\n        }\n        if (!s.empty()) {\n            m = max(m, i ^ s.top());\n        }\n        s.push(i);\n    }\n    return m;\n}",
        "tl_gold_code": "def andXorOr(a):\n    m = 0\n    s = []\n    for i in a:     \n        while s and s[-1] >= i:\n            m = max(m, i^s.pop())\n        if s:\n            m = max(m, i^s[-1])\n        s.append(i)\n    return m"
    },
    {
        "task": "c++_python",
        "problem_id": 60,
        "prediction_id": 0,
        "pro_prediction": "def missingNumbers(arr: List[int], brr: List[int]) -> List[int]:\n    mp = {}\n    for i in range(len(brr)):\n        mp[brr[i]] = mp.get(brr[i], 0) + 1\n    for i in range(len(arr)):\n        mp[arr[i]] = mp.get(arr[i], 0) - 1\n    result = []\n    for key, value in mp.items():\n        if value > 0:\n            result.append(key)\n    return result",
        "main_fun_name": "missingNumbers",
        "raw_prediction": "```python\nfrom typing import List\n\ndef missingNumbers(arr: List[int], brr: List[int]) -> List[int]:\n    mp = {}\n    for i in range(len(brr)):\n        mp[brr[i]] = mp.get(brr[i], 0) + 1\n    for i in range(len(arr)):\n        mp[arr[i]] = mp.get(arr[i], 0) - 1\n    result = []\n    for key, value in mp.items():\n        if value > 0:\n            result.append(key)\n    return result\n```",
        "sl_gold_code": "vector<int> missingNumbers(vector<int> arr, vector<int> brr) {\n    map<int, int> mp;\n    for(int i = 0; i < brr.size(); i++) mp[brr[i]]++;\n    for(int i = 0; i < arr.size(); i++) mp[arr[i]]--;\n    map<int, int>::iterator it;\n    vector<int> result;\n    for(it = mp.begin(); it != mp.end(); it++)\n        if(it->second > 0) result.push_back(it->first);\n    \n    return result;\n}",
        "tl_gold_code": "def missingNumbers(arr, brr):\n    from collections import Counter\n    \n    mp = Counter(brr)\n    for num in arr:\n        mp[num] -= 1\n        \n    result = sorted([num for num, count in mp.items() if count > 0])\n    \n    return result"
    },
    {
        "task": "c++_python",
        "problem_id": 61,
        "prediction_id": 0,
        "pro_prediction": "def maximumSum(a: List[int], m: int) -> int:\n    max_val = 0\n    curr_sum = 0\n    s = SortedSet()\n    \n    for num in a:\n        curr_sum = (curr_sum + num) % m\n        if curr_sum > max_val:\n            max_val = curr_sum\n            \n        b = s.bisect_right(curr_sum)\n        if b != len(s):\n            possible_max = (curr_sum - s[b] + m) % m\n            if possible_max > max_val:\n                max_val = possible_max\n                \n        s.add(curr_sum)\n        \n    return max_val",
        "main_fun_name": "maximumSum",
        "raw_prediction": "```python\nfrom typing import List\nfrom sortedcontainers import SortedSet\n\ndef maximumSum(a: List[int], m: int) -> int:\n    max_val = 0\n    curr_sum = 0\n    s = SortedSet()\n    \n    for num in a:\n        curr_sum = (curr_sum + num) % m\n        if curr_sum > max_val:\n            max_val = curr_sum\n            \n        b = s.bisect_right(curr_sum)\n        if b != len(s):\n            possible_max = (curr_sum - s[b] + m) % m\n            if possible_max > max_val:\n                max_val = possible_max\n                \n        s.add(curr_sum)\n        \n    return max_val\n```\nNote: In Python, we use the `SortedSet` from the `sortedcontainers` library to mimic the behavior of `set` in C++ with the added functionality of `upper_bound`. The `bisect_right` method in Python's `SortedSet` is equivalent to `upper_bound` in C++.",
        "sl_gold_code": "long maximumSum(vector<long> &a, long m) {\n    long long max=0, sum=0;\n    set<long long> s;\n    for (auto i=a.begin() ; i!=a.end() ; i++) {\n        sum=(sum+*i)%m;\n        if (sum>max) max=sum;\n        auto b=s.upper_bound(sum);\n        if (b!=s.end()) {\n            long long possiblemax=(sum-*b+m)%m;\n            if (possiblemax>max) max=possiblemax;\n        }\n        s.insert(sum);\n    }\n    return max;\n}",
        "tl_gold_code": "def maximumSum(a, m):\n    max_sum = 0\n    current_sum = 0\n    sorted_sums = [0] \n    for value in a:\n        current_sum = (current_sum + value) % m\n        max_sum = max(max_sum, current_sum)\n        idx = bisect_right(sorted_sums, current_sum)\n        if idx < len(sorted_sums):\n            possible_max = (current_sum - sorted_sums[idx] + m) % m\n            max_sum = max(max_sum, possible_max)\n        insort(sorted_sums, current_sum)\n    return max_sum"
    },
    {
        "task": "c++_python",
        "problem_id": 62,
        "prediction_id": 0,
        "pro_prediction": "def formingMagicSquare(s: List[List[int]]) -> int:\n    magicSquares = [\n        [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\n        [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\n        [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\n        [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\n        [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\n        [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\n        [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\n        [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    ]\n    minCost = 8 * 3\n    for magicSquare in magicSquares:\n        cost = sum(abs(s[i][j] - magicSquare[i][j]) for i in range(3) for j in range(3))\n        minCost = min(cost, minCost)\n    return minCost",
        "main_fun_name": "formingMagicSquare",
        "raw_prediction": "```python\ndef formingMagicSquare(s: List[List[int]]) -> int:\n    magicSquares = [\n        [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\n        [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\n        [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\n        [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\n        [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\n        [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\n        [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\n        [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    ]\n    minCost = 8 * 3\n    for magicSquare in magicSquares:\n        cost = sum(abs(s[i][j] - magicSquare[i][j]) for i in range(3) for j in range(3))\n        minCost = min(cost, minCost)\n    return minCost\n```",
        "sl_gold_code": "int formingMagicSquare(vector<vector<int>>& s) {\n    vector<vector<vector<int>>> magicSquares = {\n        {{8, 1, 6}, {3, 5, 7}, {4, 9, 2}},\n        {{6, 1, 8}, {7, 5, 3}, {2, 9, 4}},\n        {{4, 9, 2}, {3, 5, 7}, {8, 1, 6}},\n        {{2, 9, 4}, {7, 5, 3}, {6, 1, 8}},\n        {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}},\n        {{4, 3, 8}, {9, 5, 1}, {2, 7, 6}},\n        {{6, 7, 2}, {1, 5, 9}, {8, 3, 4}},\n        {{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}\n    };\n    int minCost = 8 * 3;\n    for (const auto& magicSquare : magicSquares) {\n        int cost = 0;\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                cost += abs(s[i][j] - magicSquare[i][j]);\n            }\n        }\n        minCost = min(cost, minCost);\n    }\n    return minCost;\n}",
        "tl_gold_code": "def formingMagicSquare(s):\n    magicSquares = [\n        [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\n        [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\n        [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\n        [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\n        [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\n        [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\n        [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\n        [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    ]\n    minCost = 8*3\n    for magicSquare in magicSquares:\n        cost = 0\n        for i in range(3):\n            for j in range(3):\n                cost += abs(s[i][j] - magicSquare[i][j])\n        minCost = min(cost , minCost)\n    return minCost"
    },
    {
        "task": "c++_python",
        "problem_id": 63,
        "prediction_id": 0,
        "pro_prediction": "def isFibo(n: int) -> str:\n    start = 0\n    last = 1\n    while last <= n:\n        tmp = last + start\n        start = last\n        last = tmp\n        if last == n:\n            return \"IsFibo\"\n    return \"IsNotFibo\"",
        "main_fun_name": "isFibo",
        "raw_prediction": "```python\ndef isFibo(n: int) -> str:\n    start = 0\n    last = 1\n    while last <= n:\n        tmp = last + start\n        start = last\n        last = tmp\n        if last == n:\n            return \"IsFibo\"\n    return \"IsNotFibo\"\n```",
        "sl_gold_code": "string isFibo(long long n) {\n    long long start = 0, last = 1;\n    while (last <= n) {\n        long long tmp = last + start;\n        start = last;\n        last = tmp;\n        if (last == n) {\n            return \"IsFibo\";\n        }\n    }\n    return \"IsNotFibo\";\n}",
        "tl_gold_code": "def isFibo(n):\n    start = 0\n    last = 1\n    while last <= n:\n        tmp = last + start\n        start = last\n        last = tmp\n        if last== n:\n            return \"IsFibo\"\n    return \"IsNotFibo\""
    },
    {
        "task": "c++_python",
        "problem_id": 64,
        "prediction_id": 0,
        "pro_prediction": "def solve(l: int, r: int) -> int:\n    seen = set()\n    q = deque()\n    for i in range(10):\n        q.append(i)\n    while q:\n        u = q.pop()\n        if len(str(u)) >= 20:\n            continue\n        if u in seen:\n            continue\n        seen.add(u)\n        length = len(str(u))\n        for k in range(length, length + 5):\n            if len(str(u * k)) == k:\n                q.append(u * k)\n    count = 0\n    for s in seen:\n        if l <= s <= r:\n            count += 1\n    print(f\"[{l}, {r}]: {count}\")\n    return count",
        "main_fun_name": "solve",
        "raw_prediction": "```python\ndef solve(l: int, r: int) -> int:\n    seen = set()\n    q = deque()\n    for i in range(10):\n        q.append(i)\n    while q:\n        u = q.pop()\n        if len(str(u)) >= 20:\n            continue\n        if u in seen:\n            continue\n        seen.add(u)\n        length = len(str(u))\n        for k in range(length, length + 5):\n            if len(str(u * k)) == k:\n                q.append(u * k)\n    count = 0\n    for s in seen:\n        if l <= s <= r:\n            count += 1\n    print(f\"[{l}, {r}]: {count}\")\n    return count\n```",
        "sl_gold_code": "int solve(long long l, long long r) {\n    set<long long> seen;\n    deque<long long> q;\n    for (int i = 0; i < 10; ++i) q.push_back(i);\n    while (!q.empty()) {\n        long long u = q.back();\n        q.pop_back();\n        if (to_string(u).length() >= 20) continue;\n        if (seen.find(u) != seen.end()) continue;\n        seen.insert(u);\n        int length = to_string(u).length();\n        for (int k = length; k < length + 5; ++k) {\n            if (to_string(u * k).length() == k) {\n                q.push_back(u * k);\n            }\n        }\n    }\n    int count = 0;\n    for (const auto &s : seen) {\n        if (l <= s && s <= r) count++;\n    }\n    cout << \"[\" << l << \", \" << r << \"]: \" << count << endl;\n    return count;\n}",
        "tl_gold_code": "def solve(l, r):\n    from collections import deque\n    seen = set()\n    q = deque()\n    q.extend(range(10))\n    while q:\n        u = q.pop()\n        if len(str(u)) >= 20:\n            continue\n        if u in seen:\n            continue\n        seen.add(u)\n        length = len(str(u))\n        for k in range(length, length + 5):\n            if len(str(u * k)) == k:\n                q.append(u * k)\n    print(f'[{l}, {r}]: {sum(l <= s <= r for s in seen)}')\n    return sum(l <= s <= r for s in seen)"
    },
    {
        "task": "c++_python",
        "problem_id": 65,
        "prediction_id": 0,
        "pro_prediction": "def cavityMap(grid: List[str]) -> List[str]:\n    for k in range(1, len(grid) - 1):\n        for j in range(1, len(grid[k]) - 1):\n            if (grid[k][j - 1] < grid[k][j] > grid[k][j + 1] and \n                grid[k + 1][j] < grid[k][j] and grid[k - 1][j] < grid[k][j]):\n                grid[k] = grid[k][:j] + 'X' + grid[k][j+1:]\n    return grid",
        "main_fun_name": "cavityMap",
        "raw_prediction": "```python\ndef cavityMap(grid: List[str]) -> List[str]:\n    for k in range(1, len(grid) - 1):\n        for j in range(1, len(grid[k]) - 1):\n            if (grid[k][j - 1] < grid[k][j] > grid[k][j + 1] and \n                grid[k + 1][j] < grid[k][j] and grid[k - 1][j] < grid[k][j]):\n                grid[k] = grid[k][:j] + 'X' + grid[k][j+1:]\n    return grid\n```",
        "sl_gold_code": "vector<string> cavityMap(vector<string> grid) {\n    for (size_t k = 1; k < grid.size() - 1; ++k) {\n        for (size_t j = 1; j < grid[k].size() - 1; ++j) {\n            if (grid[k][j - 1] < grid[k][j] && grid[k][j] > grid[k][j + 1] &&\n                grid[k + 1][j] < grid[k][j] && grid[k - 1][j] < grid[k][j]) {\n                grid[k][j] = 'X';\n            }\n        }\n    }\n    return grid;\n}",
        "tl_gold_code": "def cavityMap(grid):\n    for k in range(1,len(grid)-1):\n        i = grid[k]\n        d = grid[k+1]\n        u = grid[k-1]\n        for j in range(1, len(grid)-1):\n            if (i[j-1] < i[j] > i[j+1]) and (d[j] <i[j] > u[j]):\n                x= list(grid[k])\n                x[j] = \"X\"\n                grid[k] = \"\".join(x)\n    return grid"
    },
    {
        "task": "c++_python",
        "problem_id": 66,
        "prediction_id": 0,
        "pro_prediction": "def solve(a: int, b: int) -> int:\n    m = a\n    n = b\n    ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)))\n    return m*n - 1",
        "main_fun_name": "solve",
        "raw_prediction": "```python\ndef solve(a: int, b: int) -> int:\n    m = a\n    n = b\n    ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)))\n    return m*n - 1\n```",
        "sl_gold_code": "long solve(int a, int b) {\n    long m = a;\n    long n = b;\n    long ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)));\n    return m*n - 1;\n}",
        "tl_gold_code": "def solve(a, b):\n    m = a\n    n = b\n    ans = min(((m-1)*n+(n-1)), ((n-1)*m+(m-1)))\n    return m*n - 1"
    },
    {
        "task": "c++_python",
        "problem_id": 67,
        "prediction_id": 0,
        "pro_prediction": "def minimumLoss(price: List[int]) -> int:\n    map = {price[i]: i for i in range(len(price))}\n    price.sort()\n    min = float('inf')\n    for i in range(len(price) - 1):\n        currentMin = price[i + 1] - price[i]\n        if currentMin < min and map[price[i]] > map[price[i + 1]]:\n            min = currentMin\n    return int(min)",
        "main_fun_name": "minimumLoss",
        "raw_prediction": "```python\nfrom typing import List\n\ndef minimumLoss(price: List[int]) -> int:\n    map = {price[i]: i for i in range(len(price))}\n    price.sort()\n    min = float('inf')\n    for i in range(len(price) - 1):\n        currentMin = price[i + 1] - price[i]\n        if currentMin < min and map[price[i]] > map[price[i + 1]]:\n            min = currentMin\n    return int(min)\n```",
        "sl_gold_code": "int minimumLoss(vector<long> price) {\n    unordered_map<long, int> map;\n    for (int i = 0; i < price.size(); ++i) {\n        map[price[i]] = i;\n    }\n    sort(price.begin(), price.end());\n    long min = numeric_limits<int>::max();\n    for (int i = 0; i < price.size() - 1; ++i) {\n        long currentMin = price[i + 1] - price[i];\n        if (currentMin < min && map[price[i]] > map[price[i + 1]]) min = currentMin;\n    }\n    return static_cast<int>(min);\n}",
        "tl_gold_code": "def minimumLoss(price):\n    map_index = {p: i for i, p in enumerate(price)}\n    price.sort()\n    min_loss = float('inf')\n    for i in range(len(price) - 1):\n        current_loss = price[i+1] - price[i]\n        if current_loss < min_loss and map_index[price[i]] > map_index[price[i+1]]:\n            min_loss = current_loss\n    return int(min_loss)"
    },
    {
        "task": "c++_python",
        "problem_id": 68,
        "prediction_id": 0,
        "pro_prediction": "def dayOfProgrammer(year: int) -> str:\n    if year == 1918:\n        return \"26.09.1918\"\n    leap_year = True\n    if (year % 4 != 0) or (year > 1918 and year % 100 == 0 and year % 400 != 0):\n        leap_year = False\n    return f\"12.09.{year}\" if leap_year else f\"13.09.{year}\"",
        "main_fun_name": "dayOfProgrammer",
        "raw_prediction": "```python\ndef dayOfProgrammer(year: int) -> str:\n    if year == 1918:\n        return \"26.09.1918\"\n    leap_year = True\n    if (year % 4 != 0) or (year > 1918 and year % 100 == 0 and year % 400 != 0):\n        leap_year = False\n    return f\"12.09.{year}\" if leap_year else f\"13.09.{year}\"\n```",
        "sl_gold_code": "string dayOfProgrammer(int year) {\n    if (year == 1918) {\n        return \"26.09.1918\";\n    }\n    bool leap_year = true;\n    if ((year % 4 != 0) || (year > 1918 && year % 100 == 0 && year % 400 != 0)) {\n        leap_year = false;\n    }\n    return leap_year ? \"12.09.\" + to_string(year) : \"13.09.\" + to_string(year);\n}",
        "tl_gold_code": "def dayOfProgrammer(year):\n    if 1918==year:\n        return '26.09.1918'\n    leap_year = True\n    if year % 4 or year > 1918 and not year % 100 and year % 400:\n        leap_year = False\n    return '.'.join(['12' if leap_year else '13', '09', str(year)])"
    },
    {
        "task": "c++_python",
        "problem_id": 69,
        "prediction_id": 0,
        "pro_prediction": "def acmTeam(topic: List[str]) -> List[int]:\n    teamLen = len(topic)\n    topicLen = len(topic[0])\n    maxKnown = 0\n    maxTeams = 0\n    for i in range(teamLen):\n        t1 = topic[i]\n        for j in range(i + 1, teamLen):\n            know = 0\n            t2 = topic[j]\n            for k in range(topicLen):\n                if t1[k] == '1' or t2[k] == '1':\n                    know += 1\n            if know == maxKnown:\n                maxTeams += 1\n            elif know > maxKnown:\n                maxKnown = know\n                maxTeams = 1\n    return [maxKnown, maxTeams]",
        "main_fun_name": "acmTeam",
        "raw_prediction": "```python\ndef acmTeam(topic: List[str]) -> List[int]:\n    teamLen = len(topic)\n    topicLen = len(topic[0])\n    maxKnown = 0\n    maxTeams = 0\n    for i in range(teamLen):\n        t1 = topic[i]\n        for j in range(i + 1, teamLen):\n            know = 0\n            t2 = topic[j]\n            for k in range(topicLen):\n                if t1[k] == '1' or t2[k] == '1':\n                    know += 1\n            if know == maxKnown:\n                maxTeams += 1\n            elif know > maxKnown:\n                maxKnown = know\n                maxTeams = 1\n    return [maxKnown, maxTeams]\n```",
        "sl_gold_code": "vector<int> acmTeam(const vector<string>& topic) {\n    int teamLen = topic.size();\n    int topicLen = topic[0].size();\n    int maxKnown = 0;\n    int maxTeams = 0;\n    for (int i = 0; i < teamLen; ++i) {\n        const string& t1 = topic[i];\n        for (int j = i + 1; j < teamLen; ++j) {\n            int know = 0;\n            const string& t2 = topic[j];\n            for (int k = 0; k < topicLen; ++k) {\n                if (t1[k] == '1' || t2[k] == '1')\n                    ++know;\n            }\n            if (know == maxKnown)\n                ++maxTeams;\n            else if (know > maxKnown) {\n                maxKnown = know;\n                maxTeams = 1;\n            }\n        }\n    }\n    return {maxKnown, maxTeams};\n}",
        "tl_gold_code": "def acmTeam(topic):\n    teamLen = len(topic)\n    topicLen = len(topic[0])\n    maxKnown = 0\n    maxTeams = 0\n    for i in range(teamLen):\n        t1 = topic[i]\n        for j in range(i + 1, teamLen):\n            know = 0\n            t2 = topic[j]\n            for k in range(topicLen):\n                if t1[k] == '1' or t2[k] == '1':\n                    know += 1\n            if know == maxKnown:\n                maxTeams += 1\n            elif know > maxKnown:\n                maxKnown = know\n                maxTeams = 1\n    return [maxKnown, maxTeams]"
    },
    {
        "task": "c++_python",
        "problem_id": 70,
        "prediction_id": 0,
        "pro_prediction": "def timeInWords(h: int, m: int) -> str:\n    hour = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                     \"ten\", \"eleven\", \"twelve\"]\n    minutes = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                        \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                        \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                        \"twenty eight\", \"twenty nine\"]\n    if m == 0:\n        return hour[h - 1] + \" o' clock\"\n    elif m == 15:\n        return \"quarter past \" + hour[h - 1]\n    elif m == 30:\n        return \"half past \" + hour[h - 1]\n    elif m == 45:\n        return \"quarter to \" + hour[h % 12]\n    elif m == 1:\n        return minutes[m - 1] + \" minute past \" + hour[h - 1]\n    elif m > 0 and m < 30:\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1]\n    else:\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12]",
        "main_fun_name": "timeInWords",
        "raw_prediction": "```python\ndef timeInWords(h: int, m: int) -> str:\n    hour = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                     \"ten\", \"eleven\", \"twelve\"]\n    minutes = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                        \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                        \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                        \"twenty eight\", \"twenty nine\"]\n    if m == 0:\n        return hour[h - 1] + \" o' clock\"\n    elif m == 15:\n        return \"quarter past \" + hour[h - 1]\n    elif m == 30:\n        return \"half past \" + hour[h - 1]\n    elif m == 45:\n        return \"quarter to \" + hour[h % 12]\n    elif m == 1:\n        return minutes[m - 1] + \" minute past \" + hour[h - 1]\n    elif m > 0 and m < 30:\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1]\n    else:\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12]\n```",
        "sl_gold_code": "string timeInWords(int h, int m) {\n    vector<string> hour = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n                                     \"ten\", \"eleven\", \"twelve\"};\n    vector<string> minutes = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                                        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \n                                        \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"twenty one\", \"twenty two\", \n                                        \"twenty three\", \"twenty four\", \"twenty five\", \"twenty six\", \"twenty seven\", \n                                        \"twenty eight\", \"twenty nine\"};\n    if (m == 0) {\n        return hour[h - 1] + \" o' clock\";\n    } else if (m == 15) {\n        return \"quarter past \" + hour[h - 1];\n    } else if (m == 30) {\n        return \"half past \" + hour[h - 1];\n    } else if (m == 45) {\n        return \"quarter to \" + hour[h % 12];\n    } else if (m == 1) {\n        return minutes[m - 1] + \" minute past \" + hour[h - 1];\n    } else if (m > 0 && m < 30) {\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1];\n    } else {\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12];\n    }\n}",
        "tl_gold_code": "def timeInWords(h, m):\n    hour = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\"]\n    minutes = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\",\n               \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \n               \"twenty one\", \"twenty two\", \"twenty three\", \"twenty four\", \"twenty five\", \n               \"twenty six\", \"twenty seven\", \"twenty eight\", \"twenty nine\"]\n    if m == 0:\n        return hour[h - 1] + \" o' clock\"\n    elif m == 15:\n        return \"quarter past \" + hour[h - 1]\n    elif m == 30:\n        return \"half past \" + hour[h - 1]\n    elif m == 45:\n        return \"quarter to \" + hour[(h % 12)]\n    elif m == 1:\n        return minutes[m - 1] + \" minute past \" + hour[h - 1]\n    elif 0 < m < 30:\n        return minutes[m - 1] + \" minutes past \" + hour[h - 1]\n    else:\n        return minutes[60 - m - 1] + \" minutes to \" + hour[h % 12]"
    },
    {
        "task": "c++_python",
        "problem_id": 71,
        "prediction_id": 0,
        "pro_prediction": "def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    g = [[] for _ in range(n)]\n    deg = [0] * n\n    for e in edges:\n        x, y = e\n        g[x].append(y)\n        g[y].append(x)\n        deg[x] += 1\n        deg[y] += 1\n    left_edges = n - 1\n    q = []\n    for i in range(n):\n        if deg[i] == 1 and coins[i] == 0:\n            q.append(i)\n    while q:\n        left_edges -= 1\n        x = q.pop()\n        for y in g[x]:\n            if deg[y] - 1 == 1 and coins[y] == 0:\n                q.append(y)\n                deg[y] -= 1\n    for i in range(n):\n        if deg[i] == 1 and coins[i]:\n            q.append(i)\n    left_edges -= len(q)\n    for x in q:\n        for y in g[x]:\n            if deg[y] - 1 == 1:\n                left_edges -= 1\n                deg[y] -= 1\n    return max(left_edges * 2, 0)",
        "main_fun_name": "collectTheCoins",
        "raw_prediction": "```python\nfrom typing import List\n\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    g = [[] for _ in range(n)]\n    deg = [0] * n\n    for e in edges:\n        x, y = e\n        g[x].append(y)\n        g[y].append(x)\n        deg[x] += 1\n        deg[y] += 1\n    left_edges = n - 1\n    q = []\n    for i in range(n):\n        if deg[i] == 1 and coins[i] == 0:\n            q.append(i)\n    while q:\n        left_edges -= 1\n        x = q.pop()\n        for y in g[x]:\n            if deg[y] - 1 == 1 and coins[y] == 0:\n                q.append(y)\n                deg[y] -= 1\n    for i in range(n):\n        if deg[i] == 1 and coins[i]:\n            q.append(i)\n    left_edges -= len(q)\n    for x in q:\n        for y in g[x]:\n            if deg[y] - 1 == 1:\n                left_edges -= 1\n                deg[y] -= 1\n    return max(left_edges * 2, 0)\n```",
        "sl_gold_code": "int collectTheCoins(vector<int> &coins, vector<vector<int>> &edges) {\n    int n = coins.size();\n    vector<vector<int>> g(n);\n    vector<int> deg(n);\n    for (auto &e: edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x); \n        deg[x]++;\n        deg[y]++; \n    }\n    int left_edges = n - 1; \n    vector<int> q;\n    for (int i = 0; i < n; i++)\n        if (deg[i] == 1 && coins[i] == 0) \n            q.push_back(i);\n    while (!q.empty()) {\n        left_edges--; \n        int x = q.back(); q.pop_back();\n        for (int y: g[x])\n            if (--deg[y] == 1 && coins[y] == 0) \n                q.push_back(y);\n    }\n    for (int i = 0; i < n; i++)\n        if (deg[i] == 1 && coins[i]) \n            q.push_back(i);\n    left_edges -= q.size(); \n    for (int x: q) \n        for (int y: g[x])\n            if (--deg[y] == 1) \n                left_edges--; \n    return max(left_edges * 2, 0);\n}",
        "tl_gold_code": "def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)  \n    deg = list(map(len, g))  \n    left_edges = n - 1      \n    q = []\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c == 0:  \n            q.append(i)\n    while q:\n        left_edges -= 1  \n        for y in g[q.pop()]:\n            deg[y] -= 1\n            if deg[y] == 1 and coins[y] == 0:  \n                q.append(y)\n    for i, (d, c) in enumerate(zip(deg, coins)):\n        if d == 1 and c:  \n            q.append(i)\n    left_edges -= len(q)  \n    for x in q:  \n        for y in g[x]:\n            deg[y] -= 1\n            if deg[y] == 1:  \n                left_edges -= 1  \n    return max(left_edges * 2, 0)"
    },
    {
        "task": "c++_python",
        "problem_id": 72,
        "prediction_id": 0,
        "pro_prediction": "def matrixRotation(matrix: List[List[int]], r: int) -> List[List[int]]:\n    l = 0\n    br = len(matrix)\n    bc = len(matrix[0])\n    while l < min(br, bc) // 2:\n        rr = r % (2 * (br + bc - 4 * l - 2))\n        while rr > 0:\n            rr -= 1\n            buf = matrix[l][l]\n            for j in range(l, bc - l - 1):\n                matrix[l][j] = matrix[l][j + 1]\n            for i in range(l, br - l - 1):\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]\n            for j in range(bc - l - 1, l, -1):\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]\n            for i in range(br - l - 1, l + 1, -1):\n                matrix[i][l] = matrix[i - 1][l]\n            matrix[l + 1][l] = buf\n        l += 1\n    return matrix",
        "main_fun_name": "matrixRotation",
        "raw_prediction": "```python\ndef matrixRotation(matrix: List[List[int]], r: int) -> List[List[int]]:\n    l = 0\n    br = len(matrix)\n    bc = len(matrix[0])\n    while l < min(br, bc) // 2:\n        rr = r % (2 * (br + bc - 4 * l - 2))\n        while rr > 0:\n            rr -= 1\n            buf = matrix[l][l]\n            for j in range(l, bc - l - 1):\n                matrix[l][j] = matrix[l][j + 1]\n            for i in range(l, br - l - 1):\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]\n            for j in range(bc - l - 1, l, -1):\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]\n            for i in range(br - l - 1, l + 1, -1):\n                matrix[i][l] = matrix[i - 1][l]\n            matrix[l + 1][l] = buf\n        l += 1\n    return matrix\n```",
        "sl_gold_code": "vector<vector<int>> matrixRotation(vector<vector<int>>& matrix, int r) {\n    int l = 0;\n    int br = matrix.size();\n    int bc = matrix[0].size();\n    while (l < min(br, bc) / 2) {\n        int rr = r % (2 * (br + bc - 4 * l - 2));\n        while (rr--) {\n            int buf = matrix[l][l];\n            for (int j = l; j < bc - l - 1; ++j) {\n                matrix[l][j] = matrix[l][j + 1];\n            }\n            for (int i = l; i < br - l - 1; ++i) {\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1];\n            }\n            for (int j = bc - l - 1; j > l; --j) {\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1];\n            }\n            for (int i = br - l - 1; i > l + 1; --i) {\n                matrix[i][l] = matrix[i - 1][l];\n            }\n            matrix[l + 1][l] = buf;\n        }\n        ++l;\n    }\n    return matrix;\n}",
        "tl_gold_code": "def matrixRotation(matrix, r):\n    l, br, bc = 0, len(matrix), len(matrix[0])\n    while l < min(br, bc) / 2:\n        rr = r % (2 * (br + bc - l * 4 - 2))\n        while (rr) != 0:\n            rr -= 1\n            buf = matrix[l][l]\n            for j in range(l, bc - l - 1):\n                matrix[l][j] = matrix[l][j + 1]\n            for i in range(l, br - l - 1):\n                matrix[i][bc - l - 1] = matrix[i + 1][bc - l - 1]\n            for j in range(bc - l - 1, l, -1):\n                matrix[br - l - 1][j] = matrix[br - l - 1][j - 1]\n            for i in range(br - l - 1, l + 1, -1):\n                matrix[i][l] = matrix[i - 1][l]\n            matrix[l + 1][l] = buf\n        l += 1\n    return matrix"
    },
    {
        "task": "c++_python",
        "problem_id": 73,
        "prediction_id": 0,
        "pro_prediction": "def divisorSubstrings(num: int, k: int) -> int:\n    s = str(num)\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        tmp = int(s[i:i+k])\n        if tmp and num % tmp == 0:\n            res += 1\n    return res",
        "main_fun_name": "divisorSubstrings",
        "raw_prediction": "```python\ndef divisorSubstrings(num: int, k: int) -> int:\n    s = str(num)\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        tmp = int(s[i:i+k])\n        if tmp and num % tmp == 0:\n            res += 1\n    return res\n```",
        "sl_gold_code": "int divisorSubstrings(int num, int k) {\n    string s = to_string(num);\n    int n = s.size();\n    int res = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        int tmp = stoi(s.substr(i, k));\n        if (tmp && num % tmp == 0) {\n            ++res;\n        }\n    }\n    return res;\n}",
        "tl_gold_code": "def divisorSubstrings(num: int, k: int) -> int:\n    s = str(num)\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        tmp = int(s[i:i+k])\n        if tmp != 0 and num % tmp == 0:\n            res += 1\n    return res"
    },
    {
        "task": "c++_python",
        "problem_id": 74,
        "prediction_id": 0,
        "pro_prediction": "def solve(a: List[int]) -> List[int]:\n    result = []\n    cum = [0] * len(a)\n    cum[0] = a[0]\n    for i in range(1, len(a)):\n        cum[i] = cum[i - 1] + a[i]\n    total = cum[-1]\n    for i in range(len(cum)):\n        if total % cum[i] == 0:\n            j = i + 1\n            segment_sum = 0\n            while j < len(a) and segment_sum < cum[i]:\n                segment_sum += a[j]\n                if segment_sum == cum[i]:\n                    segment_sum = 0\n                j += 1\n            if segment_sum == 0 and (j == len(a) or cum[i] == total):\n                result.append(cum[i])\n    return result",
        "main_fun_name": "solve",
        "raw_prediction": "```python\nfrom typing import List\n\ndef solve(a: List[int]) -> List[int]:\n    result = []\n    cum = [0] * len(a)\n    cum[0] = a[0]\n    for i in range(1, len(a)):\n        cum[i] = cum[i - 1] + a[i]\n    total = cum[-1]\n    for i in range(len(cum)):\n        if total % cum[i] == 0:\n            j = i + 1\n            segment_sum = 0\n            while j < len(a) and segment_sum < cum[i]:\n                segment_sum += a[j]\n                if segment_sum == cum[i]:\n                    segment_sum = 0\n                j += 1\n            if segment_sum == 0 and (j == len(a) or cum[i] == total):\n                result.append(cum[i])\n    return result\n```",
        "sl_gold_code": "vector<int> solve(const vector<int>& a) {\n    vector<int> result;\n    vector<int> cum(a.size(), 0);\n    cum[0] = a[0];\n    for (size_t i = 1; i < a.size(); i++) {\n        cum[i] = cum[i - 1] + a[i];\n    }\n    int total = cum.back();\n    for (size_t i = 0; i < cum.size(); i++) {\n        if (total % cum[i] == 0) {\n            size_t j = i + 1;\n            int segment_sum = 0;\n            while (j < a.size() && segment_sum < cum[i]) {\n                segment_sum += a[j];\n                if (segment_sum == cum[i]) {\n                    segment_sum = 0;\n                }\n                j++;\n            }\n            if (segment_sum == 0 && (j == a.size() || cum[i] == total)) {\n                result.push_back(cum[i]);\n            }\n        }\n    }\n    return result;\n}",
        "tl_gold_code": "def solve(a):\n    result = []\n    cum = [0] * len(a)\n    cum[0] = a[0]\n    for i in range(1, len(a)):\n        cum[i] = cum[i-1] + a[i]\n    total = cum[-1]\n    for i in range(len(cum)):\n        if total % cum[i] == 0:\n            j = i + 1\n            segment_sum = 0\n            while j < len(a) and segment_sum < cum[i]:\n                segment_sum += a[j]\n                if segment_sum == cum[i]:\n                    segment_sum = 0\n                j += 1\n            if segment_sum == 0 and (j == len(a) or cum[i] == total):\n                result.append(cum[i])\n    return result"
    },
    {
        "task": "c++_python",
        "problem_id": 75,
        "prediction_id": 0,
        "pro_prediction": "def maximumToys(prices: List[int], k: int) -> int:\n    prices.sort()\n    toys = 0\n    for price in prices:\n        if price <= k:\n            k -= price\n            toys += 1\n        else:\n            break\n    return toys",
        "main_fun_name": "maximumToys",
        "raw_prediction": "```python\ndef maximumToys(prices: List[int], k: int) -> int:\n    prices.sort()\n    toys = 0\n    for price in prices:\n        if price <= k:\n            k -= price\n            toys += 1\n        else:\n            break\n    return toys\n```",
        "sl_gold_code": "int maximumToys(vector<int>& prices, int k) {\n    sort(prices.begin(), prices.end());\n    int toys = 0;\n    for (int price : prices) {\n        if (price <= k) {\n            k -= price;\n            ++toys;\n        } else {\n            break;\n        }\n    }\n    return toys;\n}",
        "tl_gold_code": "def maximumToys(prices, k):\n    prices = sorted(prices)\n    toys = 0\n    for i in prices:\n        if i <= k:\n            k = k - i\n            toys = toys + 1\n        else:\n            break\n    return toys"
    },
    {
        "task": "c++_python",
        "problem_id": 76,
        "prediction_id": 0,
        "pro_prediction": "def sumOfSquares(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            ans += nums[i - 1] * nums[i - 1]\n    return ans",
        "main_fun_name": "sumOfSquares",
        "raw_prediction": "```python\ndef sumOfSquares(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            ans += nums[i - 1] * nums[i - 1]\n    return ans\n```",
        "sl_gold_code": "int sumOfSquares(vector<int> &nums) {\n    int ans = 0, n = nums.size();\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            ans += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return ans;\n}",
        "tl_gold_code": "def sumOfSquares(nums):\n    ans = 0\n    n = len(nums)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            ans += nums[i - 1] ** 2\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 77,
        "prediction_id": 0,
        "pro_prediction": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    sum_d = 0\n    d = [0] * (n + 1)\n    for i in range(n):\n        sum_d += d[i]\n        x = nums[i]\n        x += sum_d\n        if x == 0:\n            continue\n        if x < 0 or i + k > n:\n            return False\n        sum_d -= x\n        d[i + k] += x\n    return True",
        "main_fun_name": "checkArray",
        "raw_prediction": "```python\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    sum_d = 0\n    d = [0] * (n + 1)\n    for i in range(n):\n        sum_d += d[i]\n        x = nums[i]\n        x += sum_d\n        if x == 0:\n            continue\n        if x < 0 or i + k > n:\n            return False\n        sum_d -= x\n        d[i + k] += x\n    return True\n```",
        "sl_gold_code": "bool checkArray(vector<int> &nums, int k) {\n    int n = nums.size(), sum_d = 0;\n    vector<int> d(n + 1);\n    for (int i = 0; i < n; i++) {\n        sum_d += d[i];\n        int x = nums[i];\n        x += sum_d;\n        if (x == 0) continue;\n        if (x < 0 || i + k > n) return false;\n        sum_d -= x;\n        d[i + k] += x;\n    }\n    return true;\n}",
        "tl_gold_code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    d = [0] * (n + 1)\n    sum_d = 0\n    for i, x in enumerate(nums):\n        sum_d += d[i]\n        x += sum_d\n        if x == 0: continue  \n        if x < 0 or i + k > n: return False  \n        sum_d -= x  \n        d[i + k] += x\n    return True"
    },
    {
        "task": "c++_python",
        "problem_id": 78,
        "prediction_id": 0,
        "pro_prediction": "def maxNonDecreasingLength(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    if n == 1:\n        return 1\n    dp = [[1, 1] for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        if nums1[i] >= nums1[i-1]:\n            dp[i][0] = max(dp[i][0], dp[i-1][0]+1)\n        if nums1[i] >= nums2[i-1]:\n            dp[i][0] = max(dp[i][0], dp[i-1][1]+1)\n        if nums2[i] >= nums1[i-1]:\n            dp[i][1] = max(dp[i][1], dp[i-1][0]+1)\n        if nums2[i] >= nums2[i-1]:\n            dp[i][1] = max(dp[i][1], dp[i-1][1]+1)\n        ans = max(ans, max(dp[i][0], dp[i][1]))\n    return ans",
        "main_fun_name": "maxNonDecreasingLength",
        "raw_prediction": "```python\ndef maxNonDecreasingLength(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    if n == 1:\n        return 1\n    dp = [[1, 1] for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        if nums1[i] >= nums1[i-1]:\n            dp[i][0] = max(dp[i][0], dp[i-1][0]+1)\n        if nums1[i] >= nums2[i-1]:\n            dp[i][0] = max(dp[i][0], dp[i-1][1]+1)\n        if nums2[i] >= nums1[i-1]:\n            dp[i][1] = max(dp[i][1], dp[i-1][0]+1)\n        if nums2[i] >= nums2[i-1]:\n            dp[i][1] = max(dp[i][1], dp[i-1][1]+1)\n        ans = max(ans, max(dp[i][0], dp[i][1]))\n    return ans\n```",
        "sl_gold_code": "int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size();\n    if (n == 1) return 1;\n    vector<vector<int>> dp(n, vector<int>(2, 1));\n    int ans = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i][0] = dp[i][1] = 1;\n        if (nums1[i] >= nums1[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][0]+1);\n        if (nums1[i] >= nums2[i-1]) dp[i][0] = max(dp[i][0], dp[i-1][1]+1);\n        if (nums2[i] >= nums1[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][0]+1);\n        if (nums2[i] >= nums2[i-1]) dp[i][1] = max(dp[i][1], dp[i-1][1]+1);\n        ans = max(ans, max(dp[i][0], dp[i][1]));\n    }\n    return ans;\n}",
        "tl_gold_code": "def maxNonDecreasingLength(nums1, nums2):\n    n = len(nums1)\n    if n == 1:\n        return 1\n    dp = [[1] * 2 for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        dp[i][0] = dp[i][1] = 1\n        if nums1[i] >= nums1[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][0] + 1)\n        if nums1[i] >= nums2[i - 1]:\n            dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\n        if nums2[i] >= nums1[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][0] + 1)\n        if nums2[i] >= nums2[i - 1]:\n            dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\n        ans = max(ans, max(dp[i][0], dp[i][1]))\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 79,
        "prediction_id": 0,
        "pro_prediction": "def maximumJumps(nums: List[int], target: int) -> int:\n    dp = [0] * len(nums)\n    for i in range(1, len(nums)):\n        res = float('-inf')\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= target:\n                res = max(res, dp[j] + 1)\n        dp[i] = res\n    return dp[-1] if dp[-1] >= 0 else -1",
        "main_fun_name": "maximumJumps",
        "raw_prediction": "```python\ndef maximumJumps(nums: List[int], target: int) -> int:\n    dp = [0] * len(nums)\n    for i in range(1, len(nums)):\n        res = float('-inf')\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= target:\n                res = max(res, dp[j] + 1)\n        dp[i] = res\n    return dp[-1] if dp[-1] >= 0 else -1\n```",
        "sl_gold_code": "int maximumJumps(vector<int>& nums, int target) {\n    vector<int> dp(nums.size());\n    dp[0] = 0;\n    for(int i = 1; i < nums.size(); ++i)\n    {\n        int res = INT_MIN;\n        for(int j = 0; j < i; ++j)\n        {\n            if(abs(nums[i] - nums[j]) <= target)\n                res = max(res, dp[j] + 1);\n            dp[i] = res;\n        }\n    }\n    return dp.back() < 0 ? -1 : dp.back();\n}",
        "tl_gold_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-inf] * n\n    f[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= target:\n                f[i] = max(f[i], f[j] + 1)\n    return -1 if f[-1] < 0 else f[-1]"
    },
    {
        "task": "c++_python",
        "problem_id": 80,
        "prediction_id": 0,
        "pro_prediction": "def theMaximumAchievableX(num: int, t: int) -> int:\n    return num + t * 2",
        "main_fun_name": "theMaximumAchievableX",
        "raw_prediction": "```python\ndef theMaximumAchievableX(num: int, t: int) -> int:\n    return num + t * 2\n```",
        "sl_gold_code": "int theMaximumAchievableX(int num, int t){\n    return num+t*2;\n}",
        "tl_gold_code": "def theMaximumAchievableX(num: int, t: int) -> int:\n        return num + t * 2"
    },
    {
        "task": "c++_python",
        "problem_id": 81,
        "prediction_id": 0,
        "pro_prediction": "def countBlackBlocks(m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n    ans = [0] * 5\n    sum = (m-1) * (n-1)\n    st = set()\n    num = len(coordinates)\n    for i in range(num):\n        st.insert(coordinates[i][0] * n + coordinates[i][1])\n    arr = [[[0, -1], [-1, -1], [-1, 0]], \n           [[0, 1], [-1, 0], [-1, 1]], \n           [[0, -1], [1, 0], [1, -1]], \n           [[0, 1], [1, 0], [1, 1]]]\n    for i in range(num):\n        x = coordinates[i][0]\n        y = coordinates[i][1]\n        for a in arr:\n            cnt = 1\n            for dx, dy in a:\n                nx = x + dx\n                ny = y + dy\n                if nx < 0 or ny < 0 or nx >= m or ny >= n:\n                    cnt = 0\n                    break\n                if (nx * n + ny) in st:\n                    cnt += 1\n            ans[cnt] += 1\n    for i in range(2, 5):\n        ans[i] //= i\n    ans[0] = sum - sum(ans[1:])\n    return ans",
        "main_fun_name": "countBlackBlocks",
        "raw_prediction": "```python\nfrom typing import List\n\ndef countBlackBlocks(m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n    ans = [0] * 5\n    sum = (m-1) * (n-1)\n    st = set()\n    num = len(coordinates)\n    for i in range(num):\n        st.insert(coordinates[i][0] * n + coordinates[i][1])\n    arr = [[[0, -1], [-1, -1], [-1, 0]], \n           [[0, 1], [-1, 0], [-1, 1]], \n           [[0, -1], [1, 0], [1, -1]], \n           [[0, 1], [1, 0], [1, 1]]]\n    for i in range(num):\n        x = coordinates[i][0]\n        y = coordinates[i][1]\n        for a in arr:\n            cnt = 1\n            for dx, dy in a:\n                nx = x + dx\n                ny = y + dy\n                if nx < 0 or ny < 0 or nx >= m or ny >= n:\n                    cnt = 0\n                    break\n                if (nx * n + ny) in st:\n                    cnt += 1\n            ans[cnt] += 1\n    for i in range(2, 5):\n        ans[i] //= i\n    ans[0] = sum - sum(ans[1:])\n    return ans\n```",
        "sl_gold_code": "vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& coordinates) {\n    vector<long long> ans(5);\n    long long sum = (long long)(m-1) * (n-1);\n    unordered_set<long long> st;\n    int num = coordinates.size();\n    for(int i = 0; i < num; i++)\n        st.insert((long long)coordinates[i][0] * n + coordinates[i][1]);\n    vector<vector<pair<int, int>>> arr(4);\n    arr[0] = {{0, -1}, {-1, -1}, {-1, 0}};\n    arr[1] = {{0, 1}, {-1, 0}, {-1, 1}};\n    arr[2] = {{0, -1}, {1, 0}, {1, -1}};\n    arr[3] = {{0, 1}, {1, 0}, {1, 1}};\n    for(int i = 0; i < num; i++) {\n        long long x = coordinates[i][0], y = coordinates[i][1];\n        for(auto &a : arr) {\n            int cnt = 1;\n            for(auto& [dx, dy] : a) {\n                long long nx = x + dx, ny = y + dy;\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\n                    cnt = 0;\n                    break;\n                }\n                if(st.count(nx * n + ny)) cnt++;\n            }\n            ans[cnt]++;\n        }            \n    }\n    for(int i = 2; i <= 4; i++) ans[i] /= i;\n    ans[0] = sum - ans[1] - ans[2] - ans[3] - ans[4];\n    return ans;\n}",
        "tl_gold_code": "def countBlackBlocks(m, n, coordinates):\n    ans = [0] * 5\n    sum_blocks = (m - 1) * (n - 1)\n    st = set((x * n + y) for x, y in coordinates)\n    arr = [\n        [(0, -1), (-1, -1), (-1, 0)],\n        [(0, 1), (-1, 0), (-1, 1)],\n        [(0, -1), (1, 0), (1, -1)],\n        [(0, 1), (1, 0), (1, 1)]\n    ]\n    for x, y in coordinates:\n        for a in arr:\n            cnt = 1\n            for dx, dy in a:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or ny < 0 or nx >= m or ny >= n:\n                    cnt = 0\n                    break\n                if (nx * n + ny) in st:\n                    cnt += 1\n            ans[cnt] += 1\n    for i in range(2, 5):\n        ans[i] //= i\n    ans[0] = sum_blocks - sum(ans[1:])\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 82,
        "prediction_id": 0,
        "pro_prediction": "def minimumBeautifulSubstrings(s: str) -> int:\n    if s[0] == '0':\n        return -1\n    s1 = {\n        \"1\": 1,\n        \"101\": 1,\n        \"11001\": 1,\n        \"1111101\": 1,\n        \"1001110001\": 1,\n        \"110000110101\": 1,\n        \"11110100001001\": 1\n    }\n    n = len(s)\n    s2 = \"\"\n    f = [float('inf')] * (n + 10)\n    f[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            s2 = \"\"\n            for k in range(i, j + 1):\n                s2 += s[k]\n            if s2 in s1:\n                f[j + 1] = min(f[j + 1], f[i] + 1)\n    if f[n] == float('inf'):\n        return -1\n    return f[n]",
        "main_fun_name": "minimumBeautifulSubstrings",
        "raw_prediction": "```python\ndef minimumBeautifulSubstrings(s: str) -> int:\n    if s[0] == '0':\n        return -1\n    s1 = {\n        \"1\": 1,\n        \"101\": 1,\n        \"11001\": 1,\n        \"1111101\": 1,\n        \"1001110001\": 1,\n        \"110000110101\": 1,\n        \"11110100001001\": 1\n    }\n    n = len(s)\n    s2 = \"\"\n    f = [float('inf')] * (n + 10)\n    f[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            s2 = \"\"\n            for k in range(i, j + 1):\n                s2 += s[k]\n            if s2 in s1:\n                f[j + 1] = min(f[j + 1], f[i] + 1)\n    if f[n] == float('inf'):\n        return -1\n    return f[n]\n```",
        "sl_gold_code": "int minimumBeautifulSubstrings(string s) {\n    if(s[0]==0) return -1;\n    unordered_map<string,int>s1;\n    int n = s.size();\n    s1[\"1\"]++;\n    s1[\"101\"]++;\n    s1[\"11001\"]++;\n    s1[\"1111101\"]++;\n    s1[\"1001110001\"]++;\n    s1[\"110000110101\"]++;\n    s1[\"11110100001001\"]++;\n    string s2=\"\";\n    vector<int>f(n+10,1e9);\n    f[0]=0;\n    for(int i =0;i<n;i++)\n        for(int j =i;j<n;j++)\n        {\n            s2=\"\";\n            for(int k=i;k<=j;k++)\n                s2+=s[k];\n            if(s1.find(s2)!=s1.end()) f[j+1]=min(f[j+1],f[i]+1);\n        }\n    if(f[n]==1e9) return -1;\n    return f[n];\n}",
        "tl_gold_code": "def minimumBeautifulSubstrings(s):\n    if s[0] == '0':\n        return -1\n    beautiful_strings = {\"1\", \"101\", \"11001\", \"1111101\", \"1001110001\", \"110000110101\", \"11110100001001\"}\n    n = len(s)\n    f = [float('inf')] * (n + 10)\n    f[0] = 0\n    for i in range(n):\n        for j in range(i, n):\n            current_substring = s[i:j+1]\n            if current_substring in beautiful_strings:\n                f[j+1] = min(f[j+1], f[i] + 1)\n    if f[n] == float('inf'):\n        return -1\n    return f[n]"
    },
    {
        "task": "c++_python",
        "problem_id": 83,
        "prediction_id": 0,
        "pro_prediction": "def gcdAndLcm(x: int, y: int) -> int:\n    n = x * y\n    ans = 0\n    for i in range(x, y + 1):\n        if n % i == 0 and gcd(i, n // i) == x and lcm(i, n // i) == y:\n            ans += 1\n    return ans\n\n\ndef gcd(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    while y != 0:\n        r = x % y\n        x = y\n        y = r\n    return x\n\n\ndef lcm(x: int, y: int) -> int:\n    return x // gcd(x, y) * y",
        "main_fun_name": "gcdAndLcm",
        "raw_prediction": "```python\ndef gcdAndLcm(x: int, y: int) -> int:\n    n = x * y\n    ans = 0\n    for i in range(x, y + 1):\n        if n % i == 0 and gcd(i, n // i) == x and lcm(i, n // i) == y:\n            ans += 1\n    return ans\n\ndef gcd(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    while y != 0:\n        r = x % y\n        x = y\n        y = r\n    return x\n\ndef lcm(x: int, y: int) -> int:\n    return x // gcd(x, y) * y\n```",
        "sl_gold_code": "int gcdAndLcm(int x, int y) {\n    int n = x * y;\n    int ans = 0;\n    for (int i = x; i <= y; ++i) {\n        if (n % i == 0 && gcd(i, n / i) == x && lcm(i, n / i) == y) {\n            ans++;\n        }\n    }\n    return ans;\n}\nint gcd(int x, int y) {\n    if (x < y) {\n        std::swap(x, y);\n    }\n    while (y != 0) {\n        int r = x % y;\n        x = y;\n        y = r;\n    }\n    return x;\n}\nint lcm(int x, int y) {\n    return x / gcd(x, y) * y;\n}",
        "tl_gold_code": "def gcdAndLcm(x: int, y: int) -> int:\n    n = x * y\n    ans = 0\n    for i in range(x,y+1):\n        if n % i == 0 and gcd(i, n // i) == x and lcm(i, n // i) == y:\n            ans += 1\n    return ans\ndef gcd(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    r = x % y  \n    while r != 0:\n        x = y\n        y = r\n        r = x % y\n    return y\ndef lcm(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    m = x\n    while x % y != 0:\n        x = x+m\n    return x"
    },
    {
        "task": "c++_python",
        "problem_id": 84,
        "prediction_id": 0,
        "pro_prediction": "def findFirstPairExceedingSum(pairs: List[List[int]]) -> int:\n    maxSum = 0\n    dayIndex = 0\n    for i in range(len(pairs)):\n        a = pairs[i][0]\n        b = pairs[i][1]\n        sum = a + b\n        if sum > 8 and sum > maxSum:\n            maxSum = sum\n            dayIndex = i + 1\n    return dayIndex",
        "main_fun_name": "findFirstPairExceedingSum",
        "raw_prediction": "```python\ndef findFirstPairExceedingSum(pairs: List[List[int]]) -> int:\n    maxSum = 0\n    dayIndex = 0\n    for i in range(len(pairs)):\n        a = pairs[i][0]\n        b = pairs[i][1]\n        sum = a + b\n        if sum > 8 and sum > maxSum:\n            maxSum = sum\n            dayIndex = i + 1\n    return dayIndex\n```",
        "sl_gold_code": "int findFirstPairExceedingSum(vector<vector<int>>& pairs) {\n      int maxSum = 0;\n      int dayIndex = 0;\n      for (int i = 0; i < pairs.size(); ++i) {\n          int a = pairs[i][0];\n          int b = pairs[i][1];\n          int sum = a + b;\n          if (sum > 8 && sum > maxSum) {\n              maxSum = sum;\n              dayIndex = i + 1;\n          }\n      }\n      return dayIndex;\n  }",
        "tl_gold_code": "def findFirstPairExceedingSum(pairs: List[List[int]]) -> int:\n    max_sum = 0\n    day_index = 0\n    for i, pair in enumerate(pairs, start=1):\n        a = pair[0]\n        b = pair[1]\n        sum = a + b\n        if sum > 8 and sum > max_sum:\n            max_sum = sum\n            day_index = i\n    return day_index"
    },
    {
        "task": "c++_python",
        "problem_id": 85,
        "prediction_id": 0,
        "pro_prediction": "def maximumValue(strs: List[str]) -> int:\n    res = 0\n    for s in strs:\n        is_digits = all(isdigit(c) for c in s)\n        res = max(res, int(s) if is_digits else len(s))\n    return res",
        "main_fun_name": "maximumValue",
        "raw_prediction": "```python\ndef maximumValue(strs: List[str]) -> int:\n    res = 0\n    for s in strs:\n        is_digits = all(isdigit(c) for c in s)\n        res = max(res, int(s) if is_digits else len(s))\n    return res\n```",
        "sl_gold_code": "int maximumValue(vector<string>& strs) {\n    int res = 0;\n    for (auto& s : strs) {\n        bool isDigits = true;\n        for (char& c : s) {\n            isDigits &= isdigit(c);\n        }\n        res = max(res, isDigits ? stoi(s) : (int)s.size());\n    }\n    return res;\n}",
        "tl_gold_code": "def maximumValue(strs: List[str]) -> int:\n    res = 0\n    for s in strs:\n        is_digits = all(c.isdigit() for c in s)\n        res = max(res, int(s) if is_digits else len(s))\n    return res"
    },
    {
        "task": "c++_python",
        "problem_id": 86,
        "prediction_id": 0,
        "pro_prediction": "def countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    cnt = [0] * 10\n    for x in nums:\n        for y in range(1, 10):\n            if cnt[y] and gcd(x % 10, y) == 1:\n                ans += cnt[y]\n        while x >= 10:\n            x //= 10\n        cnt[x] += 1\n    return ans",
        "main_fun_name": "countBeautifulPairs",
        "raw_prediction": "```python\nfrom math import gcd\nfrom typing import List\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    cnt = [0] * 10\n    for x in nums:\n        for y in range(1, 10):\n            if cnt[y] and gcd(x % 10, y) == 1:\n                ans += cnt[y]\n        while x >= 10:\n            x //= 10\n        cnt[x] += 1\n    return ans\n```",
        "sl_gold_code": "int countBeautifulPairs(vector<int> &nums) {\n    int ans = 0, cnt[10]{};\n    for (int x: nums) {\n        for (int y = 1; y < 10; y++)\n            if (cnt[y] && gcd(x % 10, y) == 1)\n                ans += cnt[y];\n        while (x >= 10) x /= 10;\n        cnt[x]++;\n    }\n    return ans;\n}",
        "tl_gold_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    ans, cnt = 0, [0] * 10\n    for x in nums:\n        for y in range(1, 10):\n            if cnt[y] and gcd(x % 10, y) == 1:\n                ans += cnt[y]\n        while x >= 10: x //= 10\n        cnt[x] += 1\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 87,
        "prediction_id": 0,
        "pro_prediction": "def countServers(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    nq = len(queries)\n    id = list(range(nq))\n    cnt = [0] * (n + 1)\n    id.sort(key=lambda i: queries[i])\n    logs.sort(key=lambda a: a[1])\n    ans = [0] * nq\n    out_of_range = n\n    left = right = 0\n    for i in id:\n        while right < len(logs) and logs[right][1] <= queries[i]:\n            if cnt[logs[right][0]] == 0:\n                out_of_range -= 1\n            cnt[logs[right][0]] += 1\n            right += 1\n        while left < len(logs) and logs[left][1] < queries[i] - x:\n            cnt[logs[left][0]] -= 1\n            if cnt[logs[left][0]] == 0:\n                out_of_range += 1\n            left += 1\n        ans[i] = out_of_range\n    return ans",
        "main_fun_name": "countServers",
        "raw_prediction": "Here's the translated code in Python:\n\n\n```python\nfrom typing import List\n\ndef countServers(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    nq = len(queries)\n    id = list(range(nq))\n    cnt = [0] * (n + 1)\n    id.sort(key=lambda i: queries[i])\n    logs.sort(key=lambda a: a[1])\n    ans = [0] * nq\n    out_of_range = n\n    left = right = 0\n    for i in id:\n        while right < len(logs) and logs[right][1] <= queries[i]:\n            if cnt[logs[right][0]] == 0:\n                out_of_range -= 1\n            cnt[logs[right][0]] += 1\n            right += 1\n        while left < len(logs) and logs[left][1] < queries[i] - x:\n            cnt[logs[left][0]] -= 1\n            if cnt[logs[left][0]] == 0:\n                out_of_range += 1\n            left += 1\n        ans[i] = out_of_range\n    return ans\n```\nNote that in Python, we don't need to specify the size of arrays like in C++. Instead, we can use list comprehensions and lambda functions to achieve similar functionality. Also, the `iota` function from C++ is replaced with a simple `range` function in Python.",
        "sl_gold_code": "vector<int> countServers(int n, vector<vector<int>> &logs, int x, vector<int> &queries) {\n    int nq = queries.size(), id[nq], cnt[n + 1];\n    memset(cnt, 0, sizeof(cnt));\n    iota(id, id + nq, 0);\n    sort(id, id + nq, [&](int i, int j) {\n        return queries[i] < queries[j];\n    });\n    sort(logs.begin(), logs.end(), [](const auto &a, const auto &b) {\n        return a[1] < b[1];\n    });\n    vector<int> ans(nq);\n    int out_of_range = n, left = 0, right = 0;\n    for (int i: id) {\n        while (right < logs.size() && logs[right][1] <= queries[i])\n            if (cnt[logs[right++][0]]++ == 0)\n                out_of_range--;\n        while (left < logs.size() && logs[left][1] < queries[i] - x)\n            if (--cnt[logs[left++][0]] == 0)\n                out_of_range++;\n        ans[i] = out_of_range;\n    }\n    return ans;\n}",
        "tl_gold_code": "def countServers(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    logs.sort(key=lambda p: p[1])  \n    ans = [0] * len(queries)\n    cnt = [0] * (n + 1)\n    out_of_range = n\n    left = right = 0\n    for qi, q in sorted(enumerate(queries), key=lambda p: p[1]):\n        while right < len(logs) and logs[right][1] <= q:  \n            i = logs[right][0]\n            if cnt[i] == 0: out_of_range -= 1\n            cnt[i] += 1\n            right += 1\n        while left < len(logs) and logs[left][1] < q - x:  \n            i = logs[left][0]\n            cnt[i] -= 1\n            if cnt[i] == 0: out_of_range += 1\n            left += 1\n        ans[qi] = out_of_range\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 88,
        "prediction_id": 0,
        "pro_prediction": "def isPossible(n: int, edges: List[List[int]]) -> bool:\n    g = [set() for _ in range(n + 1)]\n    for e in edges:\n        x, y = e\n        g[x].add(y)\n        g[y].add(x)\n    odd = [i for i in range(1, n + 1) if len(g[i]) % 2]\n    m = len(odd)\n    if m == 0: return True\n    if m == 2:\n        x, y = odd\n        if y not in g[x]: return True\n        for i in range(1, n + 1):\n            if i != x and i != y and i not in g[x] and i not in g[y]:\n                return True\n        return False\n    if m == 4:\n        a, b, c, d = odd\n        return (b not in g[a] and d not in g[c]) or \\\n               (c not in g[a] and d not in g[b]) or \\\n               (d not in g[a] and c not in g[b])\n    return False",
        "main_fun_name": "isPossible",
        "raw_prediction": "```python\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    g = [set() for _ in range(n + 1)]\n    for e in edges:\n        x, y = e\n        g[x].add(y)\n        g[y].add(x)\n    odd = [i for i in range(1, n + 1) if len(g[i]) % 2]\n    m = len(odd)\n    if m == 0: return True\n    if m == 2:\n        x, y = odd\n        if y not in g[x]: return True\n        for i in range(1, n + 1):\n            if i != x and i != y and i not in g[x] and i not in g[y]:\n                return True\n        return False\n    if m == 4:\n        a, b, c, d = odd\n        return (b not in g[a] and d not in g[c]) or \\\n               (c not in g[a] and d not in g[b]) or \\\n               (d not in g[a] and c not in g[b])\n    return False\n```",
        "sl_gold_code": "bool isPossible(int n, vector<vector<int>> &edges) {\n    unordered_set<int> g[n + 1];\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].insert(y);\n        g[y].insert(x);\n    }\n    vector<int> odd;\n    for (int i = 1; i <= n; ++i)\n        if (g[i].size() % 2) odd.push_back(i);\n    int m = odd.size();\n    if (m == 0) return true;\n    if (m == 2) {\n        int x = odd[0], y = odd[1];\n        if (!g[x].count(y)) return true;\n        for (int i = 1; i <= n; ++i)\n            if (i != x && i != y && !g[i].count(x) && !g[i].count(y))\n                return true;\n        return false;\n    }\n    if (m == 4) {\n        int a = odd[0], b = odd[1], c = odd[2], d = odd[3];\n        return !g[a].count(b) && !g[c].count(d) ||\n                !g[a].count(c) && !g[b].count(d) ||\n                !g[a].count(d) && !g[b].count(c);\n    }\n    return false;\n}",
        "tl_gold_code": "def isPossible(n: int, edges: List[List[int]]) -> bool:\n    g = defaultdict(set)\n    for x, y in edges:\n        g[x].add(y)\n        g[y].add(x)\n    odd = [i for i, nb in g.items() if len(nb) % 2]\n    m = len(odd)\n    if m == 0: return True\n    if m == 2:\n        x, y = odd\n        return x not in g[y] or any(\n            i != x and i != y and x not in g[i] and y not in g[i]\n            for i in range(1, n + 1))\n    if m == 4:\n        a, b, c, d = odd\n        return b not in g[a] and d not in g[c] or \\\n                c not in g[a] and d not in g[b] or \\\n                d not in g[a] and c not in g[b]\n    return False"
    },
    {
        "task": "c++_python",
        "problem_id": 89,
        "prediction_id": 0,
        "pro_prediction": "def minExtraChar(s: str, dictionary: List[str]) -> int:\n    set = unordered_set(dictionary)\n    n = len(s)\n    f = [0] * (n + 1)\n    for i in range(n):\n        f[i + 1] = f[i] + 1\n        for j in range(i + 1):\n            if s[j:i + 1] in set:\n                f[i + 1] = min(f[i + 1], f[j])\n    return f[n]",
        "main_fun_name": "minExtraChar",
        "raw_prediction": "```python\ndef minExtraChar(s: str, dictionary: List[str]) -> int:\n    set = unordered_set(dictionary)\n    n = len(s)\n    f = [0] * (n + 1)\n    for i in range(n):\n        f[i + 1] = f[i] + 1\n        for j in range(i + 1):\n            if s[j:i + 1] in set:\n                f[i + 1] = min(f[i + 1], f[j])\n    return f[n]\n```",
        "sl_gold_code": "int minExtraChar(string s, vector<string> &dictionary) {\n    unordered_set<string> set(dictionary.begin(), dictionary.end());\n    int n = s.size();\n    vector<int> f(n + 1);\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = f[i] + 1;\n        for (int j = 0; j < i+1; j++) {\n            if (set.count(s.substr(j, i - j + 1))) {\n                f[i + 1] = min(f[i + 1], f[j]);\n            }\n        }\n    }\n    return f[n];\n}",
        "tl_gold_code": "def minExtraChar(s: str, dictionary: List[str]) -> int:\n    d = set(dictionary)\n    n = len(s)\n    f = [0] * (n + 1)\n    for i in range(n):\n        f[i + 1] = f[i] + 1  \n        for j in range(i + 1):  \n            if s[j:i + 1] in d:\n                f[i + 1] = min(f[i + 1], f[j])\n    return f[n]"
    },
    {
        "task": "c++_python",
        "problem_id": 90,
        "prediction_id": 0,
        "pro_prediction": "def maximumPoints(edges: List[List[int]], coins: List[int], k: int) -> int:\n    g = [[] for _ in range(len(coins))]\n    for e in edges:\n        x, y = e\n        g[x].append(y)\n        g[y].append(x)\n    return dfs(0, -1, g, coins, k)[0]\n\n\ndef dfs(x: int, fa: int, g: List[List[int]], coins: List[int], k: int) -> List[int]:\n    res1 = [0] * 14\n    res2 = [0] * 14\n    for y in g[x]:\n        if y == fa:\n            continue\n        r = dfs(y, x, g, coins, k)\n        for j in range(14):\n            res1[j] += r[j]\n            if j < 13:\n                res2[j] += r[j + 1]\n    for j in range(14):\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)))\n    return res1",
        "main_fun_name": "maximumPoints",
        "raw_prediction": "```python\nfrom typing import List\n\ndef maximumPoints(edges: List[List[int]], coins: List[int], k: int) -> int:\n    g = [[] for _ in range(len(coins))]\n    for e in edges:\n        x, y = e\n        g[x].append(y)\n        g[y].append(x)\n    return dfs(0, -1, g, coins, k)[0]\n\ndef dfs(x: int, fa: int, g: List[List[int]], coins: List[int], k: int) -> List[int]:\n    res1 = [0] * 14\n    res2 = [0] * 14\n    for y in g[x]:\n        if y == fa:\n            continue\n        r = dfs(y, x, g, coins, k)\n        for j in range(14):\n            res1[j] += r[j]\n            if j < 13:\n                res2[j] += r[j + 1]\n    for j in range(14):\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)))\n    return res1\n```",
        "sl_gold_code": "int maximumPoints(vector<vector<int>> &edges, vector<int> &coins, int k) {\n    vector<vector<int>> g(coins.size());\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    return dfs(0, -1, g, coins, k)[0];\n}\narray<int, 14> dfs(int x, int fa, const vector<vector<int>> &g, const vector<int> &coins, int k) {\n    array<int, 14> res1{}, res2{};\n    for (int y : g[x]) {\n        if (y == fa) continue;\n        auto r = dfs(y, x, g, coins, k);\n        for (int j = 0; j < 14; j++) {\n            res1[j] += r[j];\n            if (j < 13) {\n                res2[j] += r[j + 1];\n            }\n        }\n    }\n    for (int j = 0; j < 14; j++) {\n        res1[j] = max(res1[j] + (coins[x] >> j) - k, res2[j] + (coins[x] >> (j + 1)));\n    }\n    return res1;\n}",
        "tl_gold_code": "def maximumPoints(edges: List[List[int]], coins: List[int], k: int) -> int:\n    g = [[] for _ in coins]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    return dfs(0, -1, g, coins, k)[0]\ndef dfs(x: int, fa: int, g, coins, k) -> List[int]:\n    res1 = [0] * 14\n    res2 = [0] * 14\n    for y in g[x]:\n        if y == fa: continue\n        r = dfs(y, x, g, coins, k)\n        for j, v in enumerate(r):\n            res1[j] += v\n            if j < 13:\n                res2[j] += r[j + 1]\n    for j, (r1, r2) in enumerate(zip(res1, res2)):\n        res1[j] = max(r1 + (coins[x] >> j) - k, r2 + (coins[x] >> (j + 1)))\n    return res1"
    },
    {
        "task": "c++_python",
        "problem_id": 91,
        "prediction_id": 0,
        "pro_prediction": "def countCompleteComponents(n: int, edges: List[List[int]]) -> int:\n    g = [[] for _ in range(n)]\n    for e in edges:\n        x, y = e[0], e[1]\n        g[x].append(y)\n        g[y].append(x)\n    vis = [0] * n\n    ans = 0\n    v = 0\n    e = 0\n    for i in range(n):\n        if not vis[i]:\n            v = 0\n            e = 0\n            dfs(i, vis, g, v, e)\n            ans += e == v * (v - 1)\n    return ans\n\n\ndef dfs(x: int, vis: List[int], g: List[List[int]], v: int, e: int) -> None:\n    vis[x] = 1\n    v += 1\n    e += len(g[x])\n    for y in g[x]:\n        if not vis[y]:\n            dfs(y, vis, g, v, e)",
        "main_fun_name": "countCompleteComponents",
        "raw_prediction": "```python\nfrom typing import List\n\ndef countCompleteComponents(n: int, edges: List[List[int]]) -> int:\n    g = [[] for _ in range(n)]\n    for e in edges:\n        x, y = e[0], e[1]\n        g[x].append(y)\n        g[y].append(x)\n    vis = [0] * n\n    ans = 0\n    v = 0\n    e = 0\n    for i in range(n):\n        if not vis[i]:\n            v = 0\n            e = 0\n            dfs(i, vis, g, v, e)\n            ans += e == v * (v - 1)\n    return ans\n\ndef dfs(x: int, vis: List[int], g: List[List[int]], v: int, e: int) -> None:\n    vis[x] = 1\n    v += 1\n    e += len(g[x])\n    for y in g[x]:\n        if not vis[y]:\n            dfs(y, vis, g, v, e)\n```",
        "sl_gold_code": "int countCompleteComponents(int n, vector<vector<int>> &edges) {\n    vector<vector<int>> g(n);\n    for (auto &e : edges) {\n        int x = e[0], y = e[1];\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> vis(n, 0);\n    int ans = 0, v, e;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            v = 0;\n            e = 0;\n            dfs(i, vis, g, v, e);\n            ans += e == v * (v - 1);\n        }\n    }\n    return ans;\n}\nvoid dfs(int x, vector<int> &vis, vector<vector<int>> &g, int &v, int &e) {\n    vis[x] = 1;\n    v++;\n    e += g[x].size();\n    for (int y : g[x])\n        if (!vis[y])\n            dfs(y, vis, g, v, e);\n}",
        "tl_gold_code": "def dfs(x: int, g: List[List[int]], vis: List[bool], counts: List[int]) -> None:\n    vis[x] = True\n    counts[0] += 1\n    counts[1] += len(g[x])\n    for y in g[x]:\n        if not vis[y]:\n            dfs(y, g, vis, counts)\ndef countCompleteComponents(n: int, edges: List[List[int]]) -> int:\n    g = [[] for _ in range(n)]\n    for x, y in edges:\n        g[x].append(y)\n        g[y].append(x)\n    vis = [False] * n\n    ans = 0\n    for i in range(n):\n        if not vis[i]:\n            counts = [0, 0]\n            dfs(i, g, vis, counts)\n            v, e = counts\n            ans += e == v * (v - 1)\n    return ans"
    },
    {
        "task": "c++_python",
        "problem_id": 92,
        "prediction_id": 0,
        "pro_prediction": "def isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    n = len(grid)\n    m = len(grid[0])\n    if not reach(0, 0, grid):\n        return True\n    grid[0][0] = grid[n - 1][m - 1] = 1\n    if not reach(0, 0, grid):\n        return True\n    return False\n\ndef reach(x: int, y: int, grid: List[List[int]]) -> bool:\n    n = len(grid)\n    m = len(grid[0])\n    if x == n - 1 and y == m - 1:\n        return True\n    grid[x][y] = 0\n    x1, y1 = x, y + 1\n    if y1 < m and grid[x1][y1] == 1:\n        ret = reach(x1, y1, grid)\n        if ret:\n            return ret\n    x2, y2 = x + 1, y\n    if x2 < n and grid[x2][y2] == 1:\n        return reach(x2, y2, grid)\n    return False\n",
        "main_fun_name": "isPossibleToCutPath",
        "raw_prediction": "```python\ndef reach(x: int, y: int, grid: List[List[int]]) -> bool:\n    n = len(grid)\n    m = len(grid[0])\n    if x == n - 1 and y == m - 1:\n        return True\n    grid[x][y] = 0\n    x1, y1 = x, y + 1\n    if y1 < m and grid[x1][y1] == 1:\n        ret = reach(x1, y1, grid)\n        if ret:\n            return ret\n    x2, y2 = x + 1, y\n    if x2 < n and grid[x2][y2] == 1:\n        return reach(x2, y2, grid)\n    return False\n\ndef isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    n = len(grid)\n    m = len(grid[0])\n    if not reach(0, 0, grid):\n        return True\n    grid[0][0] = grid[n - 1][m - 1] = 1\n    if not reach(0, 0, grid):\n        return True\n    return False\n```",
        "sl_gold_code": "bool reach(int x, int y, vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (x == n - 1 && y == m - 1) {\n        return true;\n    }\n    grid[x][y] = 0;\n    int x1 = x, y1 = y + 1;\n    if (y1 < m && grid[x1][y1] == 1) {\n        bool ret = reach(x1, y1, grid);\n        if (ret) {\n            return ret;\n        }\n    }\n    int x2 = x + 1, y2 = y;\n    if (x2 < n && grid[x2][y2] == 1) {\n        return reach(x2, y2, grid);\n    }\n    return false;\n}\nbool isPossibleToCutPath(vector<vector<int>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    grid[0][0] = 1; grid[n - 1][m - 1] = 1;\n    if (!reach(0, 0, grid)) {\n        return true;\n    }\n    return false;\n}",
        "tl_gold_code": "def reach(x: int, y: int, grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if x == n - 1 and y == m - 1:\n        return True\n    grid[x][y] = 0\n    x1, y1 = x, y + 1\n    if y1 < m and grid[x1][y1] == 1:\n        ret = reach(x1, y1, grid)\n        if ret:\n            return ret\n    x2, y2 = x + 1, y\n    if x2 < n and grid[x2][y2] == 1:\n        return reach(x2, y2, grid)\n    return False\ndef isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    n, m = len(grid), len(grid[0])\n    if not reach(0, 0, grid):\n        return True\n    grid[0][0], grid[n - 1][m - 1] = 1, 1\n    if not reach(0, 0, grid):\n        return True\n    return False"
    },
    {
        "task": "c++_python",
        "problem_id": 93,
        "prediction_id": 0,
        "pro_prediction": "def validPath(n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    adj = [[] for _ in range(n)]\n    for edge in edges:\n        x, y = edge\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    return dfs(source, destination, adj, visited)\n\n\ndef dfs(source: int, destination: int, adj: List[List[int]], visited: List[bool]) -> bool:\n    if source == destination:\n        return True\n    visited[source] = True\n    for next in adj[source]:\n        if not visited[next] and dfs(next, destination, adj, visited):\n            return True\n    return False",
        "main_fun_name": "validPath",
        "raw_prediction": "```python\nfrom typing import List\n\ndef validPath(n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    adj = [[] for _ in range(n)]\n    for edge in edges:\n        x, y = edge\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    return dfs(source, destination, adj, visited)\n\ndef dfs(source: int, destination: int, adj: List[List[int]], visited: List[bool]) -> bool:\n    if source == destination:\n        return True\n    visited[source] = True\n    for next in adj[source]:\n        if not visited[next] and dfs(next, destination, adj, visited):\n            return True\n    return False\n```",
        "sl_gold_code": "bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n    vector<list<int>> adj(n);\n    for (auto& edge : edges) {\n        int x = edge[0], y = edge[1];\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    vector<bool> visited(n, false);\n    return dfs(source, destination, adj, visited);\n}\nbool dfs(int source, int destination, vector<list<int>>& adj, vector<bool>& visited) {\n    if (source == destination) {\n        return true;\n    }\n    visited[source] = true;\n    for (int next : adj[source]) {\n        if (!visited[next] && dfs(next, destination, adj, visited)) {\n            return true;\n        }\n    }\n    return false;\n}",
        "tl_gold_code": "def validPath(n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    adj = {i: [] for i in range(n)}\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    return dfs(source, destination, adj, visited)\ndef dfs(source: int, destination: int, adj: dict, visited: List[bool]) -> bool:\n    if source == destination:\n        return True\n    visited[source] = True\n    for next in adj[source]:\n        if not visited[next] and dfs(next, destination, adj, visited):\n            return True\n    return False"
    },
    {
        "task": "c++_python",
        "problem_id": 94,
        "prediction_id": 0,
        "pro_prediction": "def isSubPath(head: ListNode, root: TreeNode) -> bool:\n    if not root:\n        return False\n    return dfs(root, head) or isSubPath(head, root.left) or isSubPath(head, root.right)\ndef dfs(rt: TreeNode, head: ListNode) -> bool:\n    if not head:\n        return True\n    if not rt:\n        return False\n    if rt.val != head.val:\n        return False\n    return dfs(rt.left, head.next) or dfs(rt.right, head.next)\n",
        "main_fun_name": "isSubPath",
        "raw_prediction": "```python\nclass Solution:\n    def dfs(self, rt: TreeNode, head: ListNode) -> bool:\n        if not head:\n            return True\n        if not rt:\n            return False\n        if rt.val != head.val:\n            return False\n        return dfs(rt.left, head.next) or dfs(rt.right, head.next)\n\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if not root:\n            return False\n        return dfs(root, head) or isSubPath(head, root.left) or isSubPath(head, root.right)\n```",
        "sl_gold_code": "bool dfs(TreeNode* rt, ListNode* head) {\n    if (head == NULL) return true;\n    if (rt == NULL) return false;\n    if (rt->val != head->val) return false;\n    return dfs(rt->left, head->next) || dfs(rt->right, head->next);\n}\nbool isSubPath(ListNode* head, TreeNode* root) {\n    if (root == NULL) return false;\n    return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\n}",
        "tl_gold_code": "def dfs(head: ListNode, rt: TreeNode) -> bool:\n    if not head:\n        return True\n    if not rt:\n        return False\n    if rt.val != head.val:\n        return False\n    return dfs(head.next, rt.left) or dfs(head.next, rt.right)\ndef isSubPath(head: ListNode, root: TreeNode) -> bool:\n    if not root:\n        return False\n    return dfs(head, root) or isSubPath(head, root.left) or isSubPath(head, root.right)"
    },
    {
        "task": "c++_python",
        "problem_id": 95,
        "prediction_id": 0,
        "pro_prediction": "def getAllElements(root1: TreeNode, root2: TreeNode) -> List[int]:\n    nums1, nums2 = [], []\n    inorder(root1, nums1)\n    inorder(root2, nums2)\n    merged = []\n    p1, p2 = iter(nums1), iter(nums2)\n    while True:\n        try:\n            if next(p1) < next(p2):\n                merged.append(next(p1))\n            else:\n                merged.append(next(p2))\n        except StopIteration:\n            merged.extend(p1 if p1 is not None else p2)\n            break\n    return merged\n\ndef inorder(node, res):\n    if node:\n        inorder(node.left, res)\n        res.append(node.val)\n        inorder(node.right, res)\n",
        "main_fun_name": "getAllElements",
        "raw_prediction": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder(node, res):\n    if node:\n        inorder(node.left, res)\n        res.append(node.val)\n        inorder(node.right, res)\n\ndef getAllElements(root1: TreeNode, root2: TreeNode) -> List[int]:\n    nums1, nums2 = [], []\n    inorder(root1, nums1)\n    inorder(root2, nums2)\n    merged = []\n    p1, p2 = iter(nums1), iter(nums2)\n    while True:\n        try:\n            if next(p1) < next(p2):\n                merged.append(next(p1))\n            else:\n                merged.append(next(p2))\n        except StopIteration:\n            merged.extend(p1 if p1 is not None else p2)\n            break\n    return merged\n```",
        "sl_gold_code": "void inorder(TreeNode *node, vector<int> &res) {\n    if (node) {\n        inorder(node->left, res);\n        res.push_back(node->val);\n        inorder(node->right, res);\n    }\n}\nvector<int> getAllElements(TreeNode *root1, TreeNode *root2) {\n    vector<int> nums1, nums2;\n    inorder(root1, nums1);\n    inorder(root2, nums2);\n    vector<int> merged;\n    auto p1 = nums1.begin(), p2 = nums2.begin();\n    while (true) {\n        if (p1 == nums1.end()) {\n            merged.insert(merged.end(), p2, nums2.end());\n            break;\n        }\n        if (p2 == nums2.end()) {\n            merged.insert(merged.end(), p1, nums1.end());\n            break;\n        }\n        if (*p1 < *p2) {\n            merged.push_back(*p1++);\n        } else {\n            merged.push_back(*p2++);\n        }\n    }\n    return merged;\n}",
        "tl_gold_code": "def inorder(node, res):\n    if node:\n        inorder(node.left, res)\n        res.append(node.val)\n        inorder(node.right, res)\ndef getAllElements(root1, root2):\n    nums1, nums2 = [], []\n    inorder(root1, nums1)\n    inorder(root2, nums2)\n    merged = []\n    p1, p2 = 0, 0\n    while True:\n        if p1 == len(nums1):\n            merged.extend(nums2[p2:])\n            break\n        if p2 == len(nums2):\n            merged.extend(nums1[p1:])\n            break\n        if nums1[p1] < nums2[p2]:\n            merged.append(nums1[p1])\n            p1 += 1\n        else:\n            merged.append(nums2[p2])\n            p2 += 1\n    return merged"
    },
    {
        "task": "c++_python",
        "problem_id": 96,
        "prediction_id": 0,
        "pro_prediction": "def maxLevelSum(root: TreeNode) -> int:\n    sums = []\n    dfs(root, 0, sums)\n    return sums.index(max(sums)) + 1\ndef dfs(node, level, sums):\n    if not node:\n        return\n    if level == len(sums):\n        sums.append(node.val)\n    else:\n        sums[level] += node.val\n    dfs(node.left, level + 1, sums)\n    dfs(node.right, level + 1, sums)\n",
        "main_fun_name": "maxLevelSum",
        "raw_prediction": "```python\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        sums = []\n        dfs(root, 0, sums)\n        return sums.index(max(sums)) + 1\n\n    def dfs(self, node, level, sums):\n        if not node:\n            return\n        if level == len(sums):\n            sums.append(node.val)\n        else:\n            sums[level] += node.val\n        dfs(node.left, level + 1, sums)\n        dfs(node.right, level + 1, sums)\n```",
        "sl_gold_code": "int maxLevelSum(TreeNode* root) {\n    std::vector<int> sums;\n    dfs(root, 0, sums);\n    return (int)(std::max_element(sums.begin(), sums.end()) - sums.begin()) + 1;\n}\nvoid dfs(TreeNode* node, int level, std::vector<int>& sums) {\n    if (!node) return;\n    if (level == sums.size()) {\n        sums.push_back(node->val);\n    } else {\n        sums[level] += node->val;\n    }\n    dfs(node->left, level + 1, sums);\n    dfs(node->right, level + 1, sums);\n}",
        "tl_gold_code": "def maxLevelSum(root: Optional[TreeNode]) -> int:\n    sums = []\n    dfs(root, 0, sums)\n    return sums.index(max(sums)) + 1  \ndef dfs(node: TreeNode, level: int, sums) -> None:\n    if level == len(sums):\n        sums.append(node.val)\n    else:\n        sums[level] += node.val\n    if node.left:\n        dfs(node.left, level + 1, sums)\n    if node.right:\n        dfs(node.right, level + 1, sums)"
    },
    {
        "task": "c++_python",
        "problem_id": 97,
        "prediction_id": 0,
        "pro_prediction": "def sumRootToLeaf(root: TreeNode) -> int:\n    return dfs(root, 0)\n\ndef dfs(root: TreeNode, val: int) -> int:\n    if root is None:\n        return 0\n    val = (val << 1) | root.val\n    if root.left is None and root.right is None:\n        return val\n    return dfs(root.left, val) + dfs(root.right, val)\n",
        "main_fun_name": "sumRootToLeaf",
        "raw_prediction": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef dfs(root: TreeNode, val: int) -> int:\n    if root is None:\n        return 0\n    val = (val << 1) | root.val\n    if root.left is None and root.right is None:\n        return val\n    return dfs(root.left, val) + dfs(root.right, val)\n\ndef sumRootToLeaf(root: TreeNode) -> int:\n    return dfs(root, 0)\n```",
        "sl_gold_code": "int dfs(TreeNode *root, int val) {\n    if (root == nullptr) {\n        return 0;\n    }\n    val = (val << 1) | root->val;\n    if (root->left == nullptr && root->right == nullptr) {\n        return val;\n    }\n    return dfs(root->left, val) + dfs(root->right, val);\n}\nint sumRootToLeaf(TreeNode* root) {\n    return dfs(root, 0);\n}",
        "tl_gold_code": "def sumRootToLeaf(root: Optional[TreeNode]) -> int:\n    return dfs(root, 0)\ndef dfs(node: Optional[TreeNode], val: int) -> int:\n    if node is None:\n        return 0\n    val = (val << 1) | node.val\n    if node.left is None and node.right is None:\n        return val\n    return dfs(node.left, val) + dfs(node.right, val)"
    },
    {
        "task": "c++_python",
        "problem_id": 98,
        "prediction_id": 0,
        "pro_prediction": "def isCousins(root: TreeNode, x: int, y: int) -> bool:\n    x_info = dfs(root, None, 0, x)\n    y_info = dfs(root, None, 0, y)\n    return x_info[1] == y_info[1] and x_info[0] != y_info[0]\ndef dfs(root: TreeNode, fa: TreeNode, depth: int, t: int) -> List[int]:\n    if not root:  \n        return [-1, -1]\n    if root.val == t:\n        return [fa.val if fa else 1, depth]\n    left = dfs(root.left, root, depth + 1, t)\n    if left[0] != -1:  \n        return left\n    return dfs(root.right, root, depth + 1, t)\n",
        "main_fun_name": "isCousins",
        "raw_prediction": "```python\nclass Solution:\n    def dfs(self, root: TreeNode, fa: TreeNode, depth: int, t: int) -> List[int]:\n        if not root:  \n            return [-1, -1]\n        if root.val == t:\n            return [fa.val if fa else 1, depth]\n        left = dfs(root.left, root, depth + 1, t)\n        if left[0] != -1:  \n            return left\n        return dfs(root.right, root, depth + 1, t)\n\n    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:\n        x_info = dfs(root, None, 0, x)\n        y_info = dfs(root, None, 0, y)\n        return x_info[1] == y_info[1] and x_info[0] != y_info[0]\n```",
        "sl_gold_code": "vector<int> dfs(TreeNode* root, TreeNode* fa, int depth, int t){\n    if(root ==nullptr)  return vector<int>{-1, -1};\n    if(root->val == t){\n        return vector<int>{fa != nullptr ? fa->val : 1, depth};\n    }\n    vector<int> l = dfs(root->left, root, depth + 1, t);\n    if(l[0] != -1)  return l;\n    return dfs(root->right, root, depth + 1, t);\n}\nbool isCousins(TreeNode* root, int x, int y) {\n    vector<int> xi = dfs(root, nullptr, 0, x);\n    vector<int> yi = dfs(root, nullptr, 0, y);\n    return xi[1] == yi[1] && xi[0] != yi[0];\n}",
        "tl_gold_code": "def dfs(root, fa, depth, t):\n    if root is None:\n        return [-1, -1]\n    if root.val == t:\n        return [fa.val if fa else -1, depth]\n    l = dfs(root.left, root, depth + 1, t)\n    if l[0] != -1:\n        return l\n    return dfs(root.right, root, depth + 1, t)\ndef isCousins(root, x, y):\n    xi = dfs(root, None, 0, x)\n    yi = dfs(root, None, 0, y)\n    return xi[1] == yi[1] and xi[0] != yi[0]"
    },
    {
        "task": "c++_python",
        "problem_id": 99,
        "prediction_id": 0,
        "pro_prediction": "def longestSquareStreak(nums: List[int]) -> int:\n    ans = 0\n    s = set(nums)\n    for x in s:\n        cnt = 0\n        while x in s:\n            cnt += 1\n            if x > math.isqrt(max(s)):\n                break\n            x *= x\n        ans = max(ans, cnt)\n    return ans if ans > 1 else -1",
        "main_fun_name": "longestSquareStreak",
        "raw_prediction": "```python\nfrom typing import List\nimport math\n\ndef longestSquareStreak(nums: List[int]) -> int:\n    ans = 0\n    s = set(nums)\n    for x in s:\n        cnt = 0\n        while x in s:\n            cnt += 1\n            if x > math.isqrt(max(s)):\n                break\n            x *= x\n        ans = max(ans, cnt)\n    return ans if ans > 1 else -1\n```",
        "sl_gold_code": "int longestSquareStreak(vector<int>& nums) {\n    int ans = 0;\n    unordered_set<int> s(nums.begin(), nums.end());\n    for (int x : s) {\n        int cnt = 0;\n        while (s.find(x) != s.end()) {\n            cnt += 1;\n            if (x > std::sqrt(INT_MAX)) break;\n            x *= x;\n        }\n        ans = max(ans, cnt);\n    }\n    return ans > 1 ? ans : -1;\n}",
        "tl_gold_code": "def longestSquareStreak(nums: List[int]) -> int:\n    ans, s = 0, set(nums)\n    for x in s:\n        cnt = 0\n        while x in s:\n            cnt += 1\n            x *= x\n        ans = max(ans, cnt)\n    return ans if ans > 1 else -1"
    },
    {
        "task": "c++_python",
        "problem_id": 100,
        "prediction_id": 0,
        "pro_prediction": "def appendCharacters(s: str, t: str) -> int:\n    j = 0\n    m = len(t)\n    for c in s:\n        if c == t[j]:\n            j += 1\n            if j == m:\n                return 0\n    return m - j",
        "main_fun_name": "appendCharacters",
        "raw_prediction": "```python\ndef appendCharacters(s: str, t: str) -> int:\n    j = 0\n    m = len(t)\n    for c in s:\n        if c == t[j]:\n            j += 1\n            if j == m:\n                return 0\n    return m - j\n```",
        "sl_gold_code": "int appendCharacters(string s, string t) {\n    int j = 0, m = t.size();\n    for (char c : s) {\n        if (c == t[j]) {\n            j += 1;\n            if (j == m) return 0;\n        }\n    }\n    return m - j;\n}",
        "tl_gold_code": "def appendCharacters(s: str, t: str) -> int:\n    j, m = 0, len(t)\n    for c in s:\n        if c == t[j]:\n            j += 1\n            if j == m: return 0\n    return m - j"
    }
]